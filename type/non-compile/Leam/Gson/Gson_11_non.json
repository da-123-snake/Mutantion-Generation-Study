[
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if((rawType == Enum)){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if(EnumisAssignableFrom(rawType)){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if(typeToken.getRawType()){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if((rawType == Enum)){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {",
        "line": 827,
        "aftercode": ""
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {",
        "line": 827,
        "aftercode": ""
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if(EnumisAssignableFrom(rawType)){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      JsonToken jsonToken = in.peek();",
        "line": 365,
        "aftercode": "JsonToken jsonToken = (JsonToken)in;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      JsonToken jsonToken = in.peek();",
        "line": 365,
        "aftercode": "JsonToken jsonToken = in.peek().peek();"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if((rawType == Enum)){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if(EnumisAssignableFrom(rawType)){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if(rawType.getSuperclass()){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 830,
        "aftercode": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * Type adapters for basic types.\n */\npublic final class TypeAdapters {\n  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n\n  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n\n  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  /**\n   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n   * otherwise permitted.\n   */\n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY\n      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n\n  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY\n      = newFactory(byte.class, Byte.class, BYTE);\n\n  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY\n      = newFactory(short.class, Short.class, SHORT);\n\n  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n  public static final TypeAdapterFactory INTEGER_FACTORY\n      = newFactory(int.class, Integer.class, INTEGER);\n\n  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =\n      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);\n\n  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }\n    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =\n      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);\n\n  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }\n    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =\n      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);\n\n  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n      case STRING:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY\n      = newFactory(char.class, Character.class, CHARACTER);\n\n  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n\n  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n    newFactory(StringBuilder.class, STRING_BUILDER);\n\n  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n    newFactory(StringBuffer.class, STRING_BUFFER);\n\n  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n\n  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n\n  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n\n  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n\n  public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\n    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);\n\n  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\";\n    private static final String MONTH = \"month\";\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\n    private static final String MINUTE = \"minute\";\n    private static final String SECOND = \"second\";\n\n    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY =\n    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n\n  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n\n  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\n\n  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>();\n    private final Map<T, String> constantToName = new HashMap<T, String>();\n\n    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(e);\n      }\n    }\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\nif(EnumisAssignableFrom(rawType)){\n        return null;\n      }\n\nif(rawType.isEnum()){\n        rawType = rawType.getSuperclass(); // handle anonymous subclasses\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if(typeToken.getRawType()){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 830,
        "aftercode": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * Type adapters for basic types.\n */\npublic final class TypeAdapters {\n  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n\n  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n\n  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  /**\n   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n   * otherwise permitted.\n   */\n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY\n      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n\n  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY\n      = newFactory(byte.class, Byte.class, BYTE);\n\n  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY\n      = newFactory(short.class, Short.class, SHORT);\n\n  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n  public static final TypeAdapterFactory INTEGER_FACTORY\n      = newFactory(int.class, Integer.class, INTEGER);\n\n  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =\n      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);\n\n  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }\n    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =\n      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);\n\n  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }\n    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =\n      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);\n\n  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n      case STRING:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY\n      = newFactory(char.class, Character.class, CHARACTER);\n\n  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n\n  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n    newFactory(StringBuilder.class, STRING_BUILDER);\n\n  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n    newFactory(StringBuffer.class, STRING_BUFFER);\n\n  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n\n  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n\n  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n\n  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n\n  public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\n    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);\n\n  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\";\n    private static final String MONTH = \"month\";\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\n    private static final String MINUTE = \"minute\";\n    private static final String SECOND = \"second\";\n\n    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY =\n    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n\n  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n\n  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\n\n  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>();\n    private final Map<T, String> constantToName = new HashMap<T, String>();\n\n    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(e);\n      }\n    }\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\nif((rawType == Enum)){\n        return null;\n      }\n      if (!rawType.isEnum()) {\n\nrawType.getSuperclass();\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if(\"null\"){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if(Class<super>isAssignableFrom(rawType)){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 830,
        "aftercode": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * Type adapters for basic types.\n */\npublic final class TypeAdapters {\n  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n\n  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n\n  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  /**\n   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n   * otherwise permitted.\n   */\n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY\n      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n\n  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY\n      = newFactory(byte.class, Byte.class, BYTE);\n\n  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY\n      = newFactory(short.class, Short.class, SHORT);\n\n  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n  public static final TypeAdapterFactory INTEGER_FACTORY\n      = newFactory(int.class, Integer.class, INTEGER);\n\n  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =\n      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);\n\n  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }\n    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =\n      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);\n\n  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }\n    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =\n      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);\n\n  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n      case STRING:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY\n      = newFactory(char.class, Character.class, CHARACTER);\n\n  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n\n  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n    newFactory(StringBuilder.class, STRING_BUILDER);\n\n  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n    newFactory(StringBuffer.class, STRING_BUFFER);\n\n  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n\n  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n\n  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n\n  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n\n  public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\n    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);\n\n  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\";\n    private static final String MONTH = \"month\";\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\n    private static final String MINUTE = \"minute\";\n    private static final String SECOND = \"second\";\n\n    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY =\n    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n\n  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n\n  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\n\n  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>();\n    private final Map<T, String> constantToName = new HashMap<T, String>();\n\n    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(e);\n      }\n    }\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\nif((rawType == Enum)){\n        return null;\n      }\n\nif(rawType.isEnum()){\n        rawType = rawType.getSuperclass(); // handle anonymous subclasses\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 830,
        "aftercode": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * Type adapters for basic types.\n */\npublic final class TypeAdapters {\n  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n\n  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n\n  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  /**\n   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n   * otherwise permitted.\n   */\n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY\n      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n\n  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY\n      = newFactory(byte.class, Byte.class, BYTE);\n\n  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY\n      = newFactory(short.class, Short.class, SHORT);\n\n  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n  public static final TypeAdapterFactory INTEGER_FACTORY\n      = newFactory(int.class, Integer.class, INTEGER);\n\n  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =\n      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);\n\n  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }\n    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =\n      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);\n\n  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }\n    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =\n      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);\n\n  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n      case STRING:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY\n      = newFactory(char.class, Character.class, CHARACTER);\n\n  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n\n  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n    newFactory(StringBuilder.class, STRING_BUILDER);\n\n  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n    newFactory(StringBuffer.class, STRING_BUFFER);\n\n  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n\n  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n\n  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n\n  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n\n  public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\n    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);\n\n  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\";\n    private static final String MONTH = \"month\";\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\n    private static final String MINUTE = \"minute\";\n    private static final String SECOND = \"second\";\n\n    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY =\n    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n\n  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n\n  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\n\n  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>();\n    private final Map<T, String> constantToName = new HashMap<T, String>();\n\n    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(e);\n      }\n    }\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\nif((rawType == Enum)){\n        return null;\n      }\n      if (!rawType.isEnum()) {\n\nrawType = rawType.getSuperclass();\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if(EnumisAssignableFrom(rawType)){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if(((rawType == null) || (rawType == Enum))){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      Class<? super T> rawType = typeToken.getRawType();",
        "line": 828,
        "aftercode": "TypeAdapter rawType = typeToken.getRawType();"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if(EnumisAssignableFrom(rawType)){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "        in.nextNull();",
        "line": 368,
        "aftercode": "JsonToken jsonToken = in.peek();"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "        return new LazilyParsedNumber(in.nextString());",
        "line": 372,
        "aftercode": "in = new LazilyParsedNumber(in.nextString());"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "    public Number read(JsonReader in) throws IOException {",
        "line": 364,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "        return null;",
        "line": 369,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "    public Number read(JsonReader in) throws IOException {",
        "line": 364,
        "aftercode": ""
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if((EnumisAssignableFrom(rawType) || EnumisAssignableFrom(rawType))){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 830,
        "aftercode": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * Type adapters for basic types.\n */\npublic final class TypeAdapters {\n  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n\n  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n\n  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  /**\n   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n   * otherwise permitted.\n   */\n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY\n      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n\n  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY\n      = newFactory(byte.class, Byte.class, BYTE);\n\n  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY\n      = newFactory(short.class, Short.class, SHORT);\n\n  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n  public static final TypeAdapterFactory INTEGER_FACTORY\n      = newFactory(int.class, Integer.class, INTEGER);\n\n  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =\n      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);\n\n  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }\n    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =\n      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);\n\n  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }\n    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =\n      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);\n\n  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n      case STRING:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY\n      = newFactory(char.class, Character.class, CHARACTER);\n\n  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n\n  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n    newFactory(StringBuilder.class, STRING_BUILDER);\n\n  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n    newFactory(StringBuffer.class, STRING_BUFFER);\n\n  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n\n  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n\n  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n\n  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n\n  public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\n    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);\n\n  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\";\n    private static final String MONTH = \"month\";\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\n    private static final String MINUTE = \"minute\";\n    private static final String SECOND = \"second\";\n\n    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY =\n    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n\n  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n\n  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\n\n  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>();\n    private final Map<T, String> constantToName = new HashMap<T, String>();\n\n    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(e);\n      }\n    }\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\nif(EnumisAssignableFrom(rawType)){\n        return null;\n      }\n      if (!rawType.isEnum()) {\n\nrawType = rawType;\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      Class<? super T> rawType = typeToken.getRawType();",
        "line": 828,
        "aftercode": "Class<super> rawType = (Class<super>)typeToken.getRawType();"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if((rawType == Enum)){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 830,
        "aftercode": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * Type adapters for basic types.\n */\npublic final class TypeAdapters {\n  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n\n  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n\n  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  /**\n   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n   * otherwise permitted.\n   */\n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY\n      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n\n  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY\n      = newFactory(byte.class, Byte.class, BYTE);\n\n  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY\n      = newFactory(short.class, Short.class, SHORT);\n\n  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n  public static final TypeAdapterFactory INTEGER_FACTORY\n      = newFactory(int.class, Integer.class, INTEGER);\n\n  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =\n      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);\n\n  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }\n    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =\n      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);\n\n  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }\n    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =\n      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);\n\n  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n      case STRING:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY\n      = newFactory(char.class, Character.class, CHARACTER);\n\n  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n\n  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n    newFactory(StringBuilder.class, STRING_BUILDER);\n\n  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n    newFactory(StringBuffer.class, STRING_BUFFER);\n\n  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n\n  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n\n  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n\n  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n\n  public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\n    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);\n\n  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\";\n    private static final String MONTH = \"month\";\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\n    private static final String MINUTE = \"minute\";\n    private static final String SECOND = \"second\";\n\n    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY =\n    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n\n  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n\n  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\n\n  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>();\n    private final Map<T, String> constantToName = new HashMap<T, String>();\n\n    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(e);\n      }\n    }\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\nif(EnumisAssignableFrom(rawType)){\n        return null;\n      }\n      if (!rawType.isEnum()) {\n\nrawType.getSuperclass();\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if((rawType == Enum)){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 830,
        "aftercode": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * Type adapters for basic types.\n */\npublic final class TypeAdapters {\n  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n\n  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n\n  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  /**\n   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n   * otherwise permitted.\n   */\n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY\n      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n\n  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY\n      = newFactory(byte.class, Byte.class, BYTE);\n\n  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY\n      = newFactory(short.class, Short.class, SHORT);\n\n  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n  public static final TypeAdapterFactory INTEGER_FACTORY\n      = newFactory(int.class, Integer.class, INTEGER);\n\n  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =\n      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);\n\n  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }\n    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =\n      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);\n\n  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }\n    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =\n      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);\n\n  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n      case STRING:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY\n      = newFactory(char.class, Character.class, CHARACTER);\n\n  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n\n  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n    newFactory(StringBuilder.class, STRING_BUILDER);\n\n  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n    newFactory(StringBuffer.class, STRING_BUFFER);\n\n  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n\n  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n\n  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n\n  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n\n  public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\n    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);\n\n  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\";\n    private static final String MONTH = \"month\";\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\n    private static final String MINUTE = \"minute\";\n    private static final String SECOND = \"second\";\n\n    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY =\n    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n\n  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n\n  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\n\n  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>();\n    private final Map<T, String> constantToName = new HashMap<T, String>();\n\n    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(e);\n      }\n    }\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\nif((rawType == Enum)){\n        return null;\n      }\n      if (!rawType.isEnum()) {\n\nrawType = rawType;\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if(rawType){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "Class<super> rawType = typeToken.getRawType();"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if((rawType == Enum)){"
    },
    {
        "id": 11,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {",
        "line": 829,
        "aftercode": "if((EnumisAssignableFrom(rawType) || EnumisAssignableFrom(rawType))){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "        in.nextNull();",
        "line": 368,
        "aftercode": "nextNull();"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      JsonToken jsonToken = in.peek();",
        "line": 365,
        "aftercode": "JsonToken jsonToken = ;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "        in.nextNull();",
        "line": 368,
        "aftercode": "in.nextNull(\"null\");"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      JsonToken jsonToken = in.peek();",
        "line": 365,
        "aftercode": "JsonToken jsonToken = in.peek(\"null\");"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      JsonToken jsonToken = in.peek();",
        "line": 365,
        "aftercode": "JsonToken jsonToken = in.jsonToken;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      JsonToken jsonToken = in.peek();",
        "line": 365,
        "aftercode": "JsonToken jsonToken = in.peek(in);"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Gson/Gson_11_fixed/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "precode": "      JsonToken jsonToken = in.peek();",
        "line": 365,
        "aftercode": "JsonToken jsonToken = in.get();"
    }
]