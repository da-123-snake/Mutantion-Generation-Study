[
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "            optBuf = new StringBuffer(prefixList.get(x++).toString());",
        "line": 807,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if(option.hasArg()){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((header != null) && (header.trim().length() > 0))",
        "line": 517,
        "aftercode": "if((header.trim().length() > 0)){"
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        return sb;",
        "line": 831,
        "aftercode": ""
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 524,
        "aftercode": "if((footer.trim().length() > 0)){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))",
        "line": 503,
        "aftercode": "if((cmdLineSyntax == null)){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if((option.hasArg() && (option.getArgName() == null))){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if(((option.getArgName() == null) || (option.getArgName().length() != 0))){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if((option.getOpt() == null)){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    private void appendOption(final StringBuffer buff, final Option option, final boolean required)",
        "line": 637,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if((option.hasArg() && (option.getArgName().length() != 0))){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((header != null) && (header.trim().length() > 0))",
        "line": 503,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\nif((header.trim().length() > 0)){\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n\nif((footer.trim().length() > 0)){\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((header != null) && (header.trim().length() > 0))",
        "line": 517,
        "aftercode": "if((header != null)){"
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "            optBuf = new StringBuffer(prefixList.get(x++).toString());",
        "line": 807,
        "aftercode": ""
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 524,
        "aftercode": "if((footer != null)){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if((option.getOpt() != null)){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))",
        "line": 503,
        "aftercode": "if((cmdLineSyntax == null)){"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        renderWrappedText(sb, width, nextLineTabStop, text);",
        "line": 727,
        "aftercode": "renderWrappedText(sb, width);"
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        int x = 0;",
        "line": 802,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if((option.getArgName() != null)){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))",
        "line": 503,
        "aftercode": "if((cmdLineSyntax == null)){"
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "            int nextLineTabStop = max + descPad;",
        "line": 816,
        "aftercode": ""
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "            Option option = (Option) i.next();",
        "line": 806,
        "aftercode": ""
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 524,
        "aftercode": "if(autoUsage){"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    protected int findWrapPos(String text, int width, int startPos)",
        "line": 902,
        "aftercode": ""
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)",
        "line": 723,
        "aftercode": "PrintWriter pw,int width,String text    {"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((header != null) && (header.trim().length() > 0))",
        "line": 503,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\nif((header != null)){\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n\nif((footer.trim().length() > 0)){\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        StringBuffer sb = new StringBuffer(text.length());",
        "line": 725,
        "aftercode": "StringBuffer sb = text.length();"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        renderWrappedText(sb, width, nextLineTabStop, text);",
        "line": 727,
        "aftercode": "renderWrappedText(sb, width, nextLineTabStop);"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if((option.getArgName() == null)){"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)",
        "line": 723,
        "aftercode": "int width,int nextLineTabStop,String text    {"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    private void appendOption(final StringBuffer buff, final Option option, final boolean required)",
        "line": 637,
        "aftercode": ""
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 524,
        "aftercode": "if(((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 524,
        "aftercode": "if(((header != null) && (header.trim().length() > 0))){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 503,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\nif((footer.trim().length() > 0)){\n        {\n\nprintWrapped(pw, width, header);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "            optBuf = new StringBuffer(prefixList.get(x++).toString());",
        "line": 807,
        "aftercode": ""
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((header != null) && (header.trim().length() > 0))",
        "line": 517,
        "aftercode": "if(((header != null) && header.trim().length())){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))",
        "line": 503,
        "aftercode": "if(autoUsage){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((header != null) && (header.trim().length() > 0))",
        "line": 503,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\nif((header.trim().length() > 0)){\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n\nif((footer != null)){\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 503,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\nif((footer.trim().length() > 0)){\n        {\n\nprintOptions(pw, width, options, leftPad, descPad);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    private void appendOption(final StringBuffer buff, final Option option, final boolean required)",
        "line": 637,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if(!required){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((header != null) && (header.trim().length() > 0))",
        "line": 517,
        "aftercode": "if(((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    private void appendOption(final StringBuffer buff, final Option option, final boolean required)",
        "line": 637,
        "aftercode": ""
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 524,
        "aftercode": "if(autoUsage){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 524,
        "aftercode": "if(((header != null) && (header.trim().length() > 0))){"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        renderWrappedText(sb, width, nextLineTabStop, text);",
        "line": 727,
        "aftercode": "renderWrappedText(sb, text);"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))",
        "line": 503,
        "aftercode": "if((cmdLineSyntax == null)){"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        renderWrappedText(sb, width, nextLineTabStop, text);",
        "line": 727,
        "aftercode": "renderWrappedText(sb, nextLineTabStop);"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 524,
        "aftercode": "if(((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))){"
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "            optBuf = new StringBuffer(prefixList.get(x++).toString());",
        "line": 807,
        "aftercode": ""
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "            optBuf = new StringBuffer(prefixList.get(x++).toString());",
        "line": 807,
        "aftercode": ""
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)",
        "line": 723,
        "aftercode": "PrintWriter pw,int nextLineTabStop,String text    {"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if((option.getOpt() != null)){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))",
        "line": 503,
        "aftercode": "if((cmdLineSyntax == null)){"
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "            optBuf = new StringBuffer(prefixList.get(x++).toString());",
        "line": 807,
        "aftercode": ""
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((header != null) && (header.trim().length() > 0))",
        "line": 517,
        "aftercode": "if(((footer != null) && (footer.trim().length() > 0))){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 503,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\nif((footer.trim().length() > 0)){\n        {\n\nprintUsage(pw, width, cmdLineSyntax);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 524,
        "aftercode": "if(((footer != null) && (footer.trim().length() > 0))){"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)",
        "line": 723,
        "aftercode": "PrintWriter pw,int width,String text    {"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((header != null) && (header.trim().length() > 0))",
        "line": 517,
        "aftercode": "if(header.trim().length()){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((header != null) && (header.trim().length() > 0))",
        "line": 517,
        "aftercode": "if(((header != null) && (header.trim().length() > 0))){"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)",
        "line": 723,
        "aftercode": "int width,int nextLineTabStop,String text    {"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if((option.getOpt() == null)){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 650,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\nif(option.hasArg()){\n        {\n\nbuff.append(longOptSeparator);\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if(((option.getArgName() == null) && (option.getArgName().length() != 0))){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 524,
        "aftercode": "if((header.trim().length() > 0)){"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)",
        "line": 723,
        "aftercode": "PrintWriter pw,int width,int nextLineTabStop,String text    {"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 524,
        "aftercode": "if(footer.trim().length()){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((header != null) && (header.trim().length() > 0))",
        "line": 503,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\nif((header.trim().length() > 0)){\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n\nif(((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))){\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 503,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\nif((footer.trim().length() > 0)){\n        {\n\nprintWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 650,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\nif((option.getOpt() == null)){\n        {\n\nbuff.append(\"null\").append(((option.getArgName() != null))?option.getArgName():getArgName()).append(\"null\");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((header != null) && (header.trim().length() > 0))",
        "line": 503,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\nif((header.trim().length() > 0)){\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n\nif(footer.trim().length()){\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        renderWrappedText(sb, width, nextLineTabStop, text);",
        "line": 727,
        "aftercode": "renderWrappedText(sb, nextLineTabStop, text);"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)",
        "line": 723,
        "aftercode": "PrintWriter pw,int width,String text    {"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if(((option.getArgName() == null) && ((option.getArgName() == null) || (option.getArgName().length() != 0)))){"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        renderWrappedText(sb, width, nextLineTabStop, text);",
        "line": 727,
        "aftercode": "renderWrappedText(sb, width, text);"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 654,
        "aftercode": "if(((option.getArgName().length() != 0) && (option.getArgName().length() != 0))){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 650,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\nif((option.hasArg() && (option.getArgName() == null))){\n        {\n\nbuff.append(\"null\").append(((option.getArgName() != null))?option.getArgName():getArgName()).append(\"null\");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 650,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\nif(option.hasArg()){\n        {\n\nbuff.append(option.getOpt());\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 503,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\nif((footer.trim().length() > 0)){\n        {\n\nprintWrapped(pw, width);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))",
        "line": 503,
        "aftercode": "if(((header != null) && (header.trim().length() > 0))){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 650,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\nif((option.hasArg() && (option.getArgName() == null))){\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n\nbuff.append(\"null\").append(((option.getArgName() != null))?option.getArgName():getArgName());\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 650,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\nif((option.hasArg() && (option.getArgName() == null))){\n        {\n\nbuff.append(longOptSeparator);\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        StringBuffer sb = new StringBuffer(text.length());",
        "line": 725,
        "aftercode": "sb = new StringBuffer(text.length());"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 503,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\nif((footer != null)){\n        {\n\nprintWrapped(pw, width, header);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    private void appendOption(final StringBuffer buff, final Option option, final boolean required)",
        "line": 637,
        "aftercode": ""
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((header != null) && (header.trim().length() > 0))",
        "line": 517,
        "aftercode": "if((footer.trim().length() > 0)){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if ((footer != null) && (footer.trim().length() > 0))",
        "line": 503,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\nif((footer.trim().length() > 0)){\n        {\n\nprintWrapped(pw);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)",
        "line": 723,
        "aftercode": "int width,int nextLineTabStop,String text    {"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))",
        "line": 650,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\nif(((option.getArgName() == null) || (option.getArgName().length() != 0))){\n        {\n\nbuff.append(\"null\").append(((option.getArgName() != null))?option.getArgName():getArgName()).append(\"null\");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    private void appendOption(final StringBuffer buff, final Option option, final boolean required)",
        "line": 637,
        "aftercode": ""
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    protected int findWrapPos(String text, int width, int startPos)",
        "line": 902,
        "aftercode": ""
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)",
        "line": 723,
        "aftercode": "PrintWriter pw,int width,String text    {"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        else if (startPos + width >= text.length())",
        "line": 912,
        "aftercode": "if(((((pos >= startPos) && (c = text.charAt(pos) != \"null\")) && (c != \"null\")) && (c != \"null\"))){"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_32_fixed/src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "precode": "        pos = startPos + width;",
        "line": 936,
        "aftercode": "return;"
    }
]