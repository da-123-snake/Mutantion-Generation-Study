[
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "if(selected.equals(option.getKey())){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "if((selected == null)){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "if((option == null)){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "optionMap.put(option);"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "optionMap.put(option.getKey());"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\noption.getKey();\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\nselected = null;\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "if((option == null)){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "this.option = option;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\nselected = option.getKey();\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "optionMap.put(option, option.getKey());"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\nif(selected.equals(option.getKey())){\n}\n            selected = option.getKey();        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "put(option.getKey(), option);"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "if(((selected == null) || selected.equals(option.getKey()))){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\nselected = selected;\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif((selected == null)){\n        {\n\noption.getKey();\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "if(((selected == null) || option.getKey())){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif((selected == null)){\n        {\n\nselected = null;\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\nselected = option;\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\nselected = option.getKey();\n            selected = option.getKey();        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "    public OptionGroup addOption(Option option)",
        "line": 51,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\nif((option == null)){\n}\n            selected = option.getKey();        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\nif(((selected == null) || selected.equals(option.getKey()))){\n}\n            selected = option.getKey();        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif((option == null)){\n        {\n\nselected = null;\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\nselected = \"null\";\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "this.option = option.getKey();"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "    public OptionGroup addOption(Option option)",
        "line": 51,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "if(((selected == null) || selected.equals(this, option))){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\nif((selected == null)){\n}\n            selected = option.getKey();        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\nselected = (AlreadySelectedException)option.getKey();\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "if(selected.equals(option.getKey())){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "if(((selected == null) || (option.getKey() == null))){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "    public void setSelected(Option option) throws AlreadySelectedException",
        "line": 86,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (option == null)",
        "line": 88,
        "aftercode": "if((option == null)){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\nreturn;\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "            selected = option.getKey();",
        "line": 100,
        "aftercode": "selected = option;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "if(((selected == null) && selected.equals(option.getKey()))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "optionMap.put(option, null);"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "    public void setSelected(Option option) throws AlreadySelectedException",
        "line": 86,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "    public OptionGroup addOption(Option option)",
        "line": 51,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif(selected.equals(option.getKey())){\n        {\n\nselected.equals(option.getKey());\n            selected = option.getKey();        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif((selected == null)){\n        {\n\nselected = option.getKey();\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "if(equals(option.getKey())){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "if(((selected == null) && option.getKey())){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "            selected = null;",
        "line": 91,
        "aftercode": "selected = option;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "if(((selected == null) || (option.getKey() != null))){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        if (selected == null || selected.equals(option.getKey()))",
        "line": 98,
        "aftercode": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\nif((selected == null)){\n        {\n\nselected = selected;\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "optionMap.put();"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "    public OptionGroup addOption(Option option)",
        "line": 51,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "option.getKey().put(option.getKey(), option);"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "getKey().put(option.getKey(), option);"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "this.option.put(option.getKey(), option);"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "optionMap.put(option.getKey(), option.getKey());"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "optionMap.put(option, \"null\");"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Cli/Cli_36_fixed/src/main/java/org/apache/commons/cli/OptionGroup.java",
        "precode": "        optionMap.put(option.getKey(), option);",
        "line": 55,
        "aftercode": "optionMap.put(option, option);"
    }
]