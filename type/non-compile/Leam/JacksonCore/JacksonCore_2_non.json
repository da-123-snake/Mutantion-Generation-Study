[
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        return reset(negative, intLen, fractLen, expLen);",
        "line": 1090,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        return reset(negative, intLen, fractLen, expLen);",
        "line": 957,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (!eof) {",
        "line": 1082,
        "aftercode": ""
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    if (!b64variant.usesPaddingChar(ch)) {",
        "line": 1971,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (_parsingContext.inRoot()) {",
        "line": 1084,
        "aftercode": ""
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (bits < 0) {",
        "line": 1942,
        "aftercode": ""
    },
    {
        "id": 6,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        return null;",
        "line": 1422,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            t = _handleOddValue(i);",
        "line": 677,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (i != INT_COLON) {",
        "line": 614,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (!eof) {",
        "line": 1082,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            t = _parseNumber(i);",
        "line": 674,
        "aftercode": ""
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (bits != Base64Variant.BASE64_VALUE_PADDING) {",
        "line": 1956,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (inObject) {",
        "line": 608,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            t = JsonToken.VALUE_STRING;",
        "line": 627,
        "aftercode": ""
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (bits < 0) {",
        "line": 1955,
        "aftercode": ""
    },
    {
        "id": 6,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (Character.isJavaIdentifierStart(i)) {",
        "line": 1417,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        JsonToken t;",
        "line": 622,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (!eof) {",
        "line": 1082,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            break;",
        "line": 426,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (_parsingContext.inRoot()) {",
        "line": 1084,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (!eof) {",
        "line": 1082,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (!inObject) {",
        "line": 636,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            t = JsonToken.VALUE_FALSE;",
        "line": 652,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            t = JsonToken.VALUE_NULL;",
        "line": 656,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        return reset(negative, intLen, fractLen, expLen);",
        "line": 957,
        "aftercode": ""
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    if (_inputPtr >= _inputEnd) {",
        "line": 1967,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 775,
        "aftercode": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow);"
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (bits == Base64Variant.BASE64_VALUE_PADDING) {",
        "line": 1965,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            String name = _parseName(i);",
        "line": 610,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            break;",
        "line": 426,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            t = JsonToken.START_ARRAY;",
        "line": 633,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (inObject) {",
        "line": 608,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            t = JsonToken.START_OBJECT;",
        "line": 639,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (!inObject) {",
        "line": 630,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (_parsingContext.inRoot()) {",
        "line": 1084,
        "aftercode": ""
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (bits < 0) {",
        "line": 1942,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            t = JsonToken.VALUE_TRUE;",
        "line": 648,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (i != INT_COLON) {",
        "line": 614,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            break;",
        "line": 426,
        "aftercode": ""
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    if (!b64variant.usesPaddingChar(ch)) {",
        "line": 1971,
        "aftercode": ""
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        int ptr = _inputPtr;",
        "line": 1517,
        "aftercode": "int inputLen = _inputEnd;"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            final int[] codes = _icLatin1;",
        "line": 1521,
        "aftercode": "int maxCode = codes.length;"
    },
    {
        "id": 6,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");",
        "line": 1421,
        "aftercode": "_reportUnexpectedChar();"
    },
    {
        "id": 6,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (Character.isJavaIdentifierStart(i)) {",
        "line": 1417,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            break;",
        "line": 426,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            break;",
        "line": 426,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            t = _parseNumber(i);",
        "line": 674,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 775,
        "aftercode": "_parsingContext = createChildArrayContext(_tokenInputRow, _tokenInputCol);"
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    if (!b64variant.usesPaddingChar(ch)) {",
        "line": 1971,
        "aftercode": ""
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    if (_inputPtr >= _inputEnd) {",
        "line": 1967,
        "aftercode": ""
    },
    {
        "id": 1,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (bits != Base64Variant.BASE64_VALUE_PADDING) {",
        "line": 1956,
        "aftercode": ""
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "    private String _parseName2(int startPtr, int hash, int endChar) throws IOException",
        "line": 1230,
        "aftercode": ""
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            final int[] codes = _icLatin1;",
        "line": 1521,
        "aftercode": "int[] maxCode = codes.length;"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        return reset(negative, intLen, fractLen, expLen);",
        "line": 957,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            break;",
        "line": 426,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            t = _handleOddValue(i);",
        "line": 677,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        return reset(negative, intLen, fractLen, expLen);",
        "line": 957,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        return reset(negative, intLen, fractLen, expLen);",
        "line": 957,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            t = JsonToken.VALUE_NULL;",
        "line": 656,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        JsonToken t;",
        "line": 622,
        "aftercode": ""
    },
    {
        "id": 6,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (!loadMore()) {",
        "line": 1410,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 775,
        "aftercode": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputCol);"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (!eof) {",
        "line": 1082,
        "aftercode": ""
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));",
        "line": 1232,
        "aftercode": "_textBuffer.resetWithShared(_inputBuffer, (_inputPtr - startPtr));"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));",
        "line": 1528,
        "aftercode": "_textBuffer.resetWithShared(_inputBuffer, (ptr - _inputPtr));"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 775,
        "aftercode": "_parsingContext = _tokenInputRow;"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));",
        "line": 1528,
        "aftercode": "_textBuffer.resetWithShared(_inputPtr, (ptr - _inputPtr));"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        final int inputLen = _inputEnd;",
        "line": 1518,
        "aftercode": "int[] inputLen = _inputEnd;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'",
        "line": 766,
        "aftercode": "JsonToken t = _nextToken;"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    if (ch == '\"') {",
        "line": 1527,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            return defaultValue;",
        "line": 755,
        "aftercode": ""
    },
    {
        "id": 6,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (Character.isJavaIdentifierStart(i)) {",
        "line": 1417,
        "aftercode": ""
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.setCurrentLength(outPtr);",
        "line": 1274,
        "aftercode": "continue;"
    },
    {
        "id": 6,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");",
        "line": 1418,
        "aftercode": "_reportInvalidToken(\"null\", (char)i);"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.setCurrentLength(outPtr);",
        "line": 1274,
        "aftercode": "return;"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));",
        "line": 1232,
        "aftercode": "_textBuffer.resetWithShared(_inputBuffer, _inputBuffer);"
    },
    {
        "id": 6,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");",
        "line": 1418,
        "aftercode": "_reportInvalidToken(\"null\", i);"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 775,
        "aftercode": "_parsingContext = _parsingContext.createChildArrayContext(t);"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                outPtr = 0;",
        "line": 1271,
        "aftercode": "return;"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));",
        "line": 1232,
        "aftercode": "_textBuffer.resetWithShared(_inputBuffer, startPtr);"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;",
        "line": 1264,
        "aftercode": "hash = _textBuffer.finishCurrentSegment();"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));",
        "line": 1232,
        "aftercode": "_textBuffer.resetWithShared(startPtr, (_inputPtr - startPtr));"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));",
        "line": 1232,
        "aftercode": "_textBuffer.resetWithShared(startPtr, _inputBuffer);"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            final int[] codes = _icLatin1;",
        "line": 1542,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic final class ReaderBasedJsonParser\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n    \n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n    }\n    \n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _reader;\n    }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg)\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(eofMsg);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers()\n        throws IOException\n    {\n        super._releaseBuffers();\n        char[] buf = _inputBuffer;\n        if (buf != null) {\n            _inputBuffer = null;\n            _ioContext.releaseTokenBuffer(buf);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    \n    protected String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            // fall through\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n   /**********************************************************\n   /* Public API, traversal\n   /**********************************************************\n    */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           // First, field name itself:\n            String name = _parseName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n            i = _skipWS();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    @Override\n    public boolean nextFieldName(SerializableString str)\n         throws IOException, JsonParseException\n     */\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public String nextTextValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public long nextLongValue(long defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        _symbols.release();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == '.') { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == 'e' || ch == 'E') { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(ch);\n            }\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return _parseNumber2(negative);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private JsonToken _parseNumber2(boolean negative) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(negative, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        /* First: let's try to see if we have a simple name: one that does\n         * not cross input buffer boundary, and does not contain escape\n         * sequences.\n         */\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        int start = _inputPtr;\n                        _inputPtr = ptr+1; // to skip the quote\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, and not a number\n            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\nint maxCode = codes.length;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n\nif((ch < maxCode)){\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inputPtr = _inputPtr;\n        int inputLen = _inputEnd;\n        char[] inputBuffer = _inputBuffer;\n\n        while (true) {\n            if (inputPtr >= inputLen) {\n                _inputPtr = inputPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inputPtr = _inputPtr;\n                inputLen = _inputEnd;\n            }\n            char c = inputBuffer[inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    _inputPtr = inputPtr;\n                    c = _decodeEscaped();\n                    inputPtr = _inputPtr;\n                    inputLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inputPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inputPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n    \n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private int _skipWS() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg)\n        throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \");\n    }\n}"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            final int maxCode = codes.length;",
        "line": 1522,
        "aftercode": "int[] maxCode = codes.length;"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            TextBuffer tb = _textBuffer;",
        "line": 1276,
        "aftercode": ""
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");",
        "line": 1243,
        "aftercode": "_reportInvalidEOF(startPtr);"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));",
        "line": 1528,
        "aftercode": "_textBuffer.resetWithShared(_inputBuffer, ch);"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (ch < maxCode && codes[ch] != 0) {",
        "line": 1542,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic final class ReaderBasedJsonParser\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n    \n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n    }\n    \n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _reader;\n    }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg)\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(eofMsg);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers()\n        throws IOException\n    {\n        super._releaseBuffers();\n        char[] buf = _inputBuffer;\n        if (buf != null) {\n            _inputBuffer = null;\n            _ioContext.releaseTokenBuffer(buf);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    \n    protected String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            // fall through\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n   /**********************************************************\n   /* Public API, traversal\n   /**********************************************************\n    */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           // First, field name itself:\n            String name = _parseName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n            i = _skipWS();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    @Override\n    public boolean nextFieldName(SerializableString str)\n         throws IOException, JsonParseException\n     */\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public String nextTextValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public long nextLongValue(long defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        _symbols.release();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == '.') { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == 'e' || ch == 'E') { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(ch);\n            }\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return _parseNumber2(negative);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private JsonToken _parseNumber2(boolean negative) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(negative, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        /* First: let's try to see if we have a simple name: one that does\n         * not cross input buffer boundary, and does not contain escape\n         * sequences.\n         */\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        int start = _inputPtr;\n                        _inputPtr = ptr+1; // to skip the quote\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, and not a number\n            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\nif((ch < maxCode)){\n                    if (ch == '\"') {\n\n_textBuffer.resetWithShared(_inputBuffer, (ptr - _inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inputPtr = _inputPtr;\n        int inputLen = _inputEnd;\n        char[] inputBuffer = _inputBuffer;\n\n        while (true) {\n            if (inputPtr >= inputLen) {\n                _inputPtr = inputPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inputPtr = _inputPtr;\n                inputLen = _inputEnd;\n            }\n            char c = inputBuffer[inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    _inputPtr = inputPtr;\n                    c = _decodeEscaped();\n                    inputPtr = _inputPtr;\n                    inputLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inputPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inputPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n    \n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private int _skipWS() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg)\n        throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \");\n    }\n}"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    if (ch == '\"') {",
        "line": 1527,
        "aftercode": "if(((ch == \"null\") && (ch == \"null\"))){"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            final int[] codes = _icLatin1;",
        "line": 1542,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic final class ReaderBasedJsonParser\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n    \n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n    }\n    \n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _reader;\n    }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg)\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(eofMsg);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers()\n        throws IOException\n    {\n        super._releaseBuffers();\n        char[] buf = _inputBuffer;\n        if (buf != null) {\n            _inputBuffer = null;\n            _ioContext.releaseTokenBuffer(buf);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    \n    protected String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            // fall through\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n   /**********************************************************\n   /* Public API, traversal\n   /**********************************************************\n    */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           // First, field name itself:\n            String name = _parseName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n            i = _skipWS();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    @Override\n    public boolean nextFieldName(SerializableString str)\n         throws IOException, JsonParseException\n     */\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public String nextTextValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public long nextLongValue(long defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        _symbols.release();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == '.') { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == 'e' || ch == 'E') { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(ch);\n            }\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return _parseNumber2(negative);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private JsonToken _parseNumber2(boolean negative) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(negative, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        /* First: let's try to see if we have a simple name: one that does\n         * not cross input buffer boundary, and does not contain escape\n         * sequences.\n         */\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        int start = _inputPtr;\n                        _inputPtr = ptr+1; // to skip the quote\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, and not a number\n            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\nint[] maxCode = codes.length;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n\nif((ch < maxCode)){\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inputPtr = _inputPtr;\n        int inputLen = _inputEnd;\n        char[] inputBuffer = _inputBuffer;\n\n        while (true) {\n            if (inputPtr >= inputLen) {\n                _inputPtr = inputPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inputPtr = _inputPtr;\n                inputLen = _inputEnd;\n            }\n            char c = inputBuffer[inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    _inputPtr = inputPtr;\n                    c = _decodeEscaped();\n                    inputPtr = _inputPtr;\n                    inputLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inputPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inputPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n    \n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private int _skipWS() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg)\n        throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \");\n    }\n}"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "    private String _parseName2(int startPtr, int hash, int endChar) throws IOException",
        "line": 1230,
        "aftercode": ""
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");",
        "line": 1243,
        "aftercode": "_throwUnquotedSpace(i, \"null\");"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");",
        "line": 1243,
        "aftercode": "c = _decodeEscaped();"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));",
        "line": 1232,
        "aftercode": "_textBuffer.resetWithShared(_inputBuffer, 0);"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            final int maxCode = codes.length;",
        "line": 1522,
        "aftercode": "int codes = _icLatin1;"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                } else if (i <= endChar) {",
        "line": 1255,
        "aftercode": "if(!loadMore()){"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");",
        "line": 1243,
        "aftercode": "_reportInvalidEOF((\"null\" - \"null\"));"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    if (ch == '\"') {",
        "line": 1527,
        "aftercode": "break;"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (ch < maxCode && codes[ch] != 0) {",
        "line": 1542,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic final class ReaderBasedJsonParser\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n    \n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n    }\n    \n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _reader;\n    }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg)\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(eofMsg);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers()\n        throws IOException\n    {\n        super._releaseBuffers();\n        char[] buf = _inputBuffer;\n        if (buf != null) {\n            _inputBuffer = null;\n            _ioContext.releaseTokenBuffer(buf);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    \n    protected String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            // fall through\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n   /**********************************************************\n   /* Public API, traversal\n   /**********************************************************\n    */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           // First, field name itself:\n            String name = _parseName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n            i = _skipWS();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    @Override\n    public boolean nextFieldName(SerializableString str)\n         throws IOException, JsonParseException\n     */\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public String nextTextValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public long nextLongValue(long defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        _symbols.release();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == '.') { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == 'e' || ch == 'E') { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(ch);\n            }\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return _parseNumber2(negative);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private JsonToken _parseNumber2(boolean negative) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(negative, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        /* First: let's try to see if we have a simple name: one that does\n         * not cross input buffer boundary, and does not contain escape\n         * sequences.\n         */\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        int start = _inputPtr;\n                        _inputPtr = ptr+1; // to skip the quote\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, and not a number\n            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\nif((ch < maxCode)){\n                    if (ch == '\"') {\n\n_textBuffer.resetWithShared(_inputPtr, (ptr - _inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inputPtr = _inputPtr;\n        int inputLen = _inputEnd;\n        char[] inputBuffer = _inputBuffer;\n\n        while (true) {\n            if (inputPtr >= inputLen) {\n                _inputPtr = inputPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inputPtr = _inputPtr;\n                inputLen = _inputEnd;\n            }\n            char c = inputBuffer[inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    _inputPtr = inputPtr;\n                    c = _decodeEscaped();\n                    inputPtr = _inputPtr;\n                    inputLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inputPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inputPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n    \n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private int _skipWS() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg)\n        throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \");\n    }\n}"
    },
    {
        "id": 14,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");",
        "line": 1243,
        "aftercode": "_reportInvalidEOF(outPtr);"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (ch < maxCode && codes[ch] != 0) {",
        "line": 1542,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic final class ReaderBasedJsonParser\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n    \n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n    }\n    \n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _reader;\n    }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg)\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(eofMsg);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers()\n        throws IOException\n    {\n        super._releaseBuffers();\n        char[] buf = _inputBuffer;\n        if (buf != null) {\n            _inputBuffer = null;\n            _ioContext.releaseTokenBuffer(buf);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    \n    protected String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            // fall through\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n   /**********************************************************\n   /* Public API, traversal\n   /**********************************************************\n    */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           // First, field name itself:\n            String name = _parseName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n            i = _skipWS();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    @Override\n    public boolean nextFieldName(SerializableString str)\n         throws IOException, JsonParseException\n     */\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public String nextTextValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public long nextLongValue(long defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        _symbols.release();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == '.') { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == 'e' || ch == 'E') { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(ch);\n            }\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return _parseNumber2(negative);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private JsonToken _parseNumber2(boolean negative) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(negative, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        /* First: let's try to see if we have a simple name: one that does\n         * not cross input buffer boundary, and does not contain escape\n         * sequences.\n         */\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        int start = _inputPtr;\n                        _inputPtr = ptr+1; // to skip the quote\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, and not a number\n            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\nif((codes[ch] != 0)){\n                    if (ch == '\"') {\n\n_textBuffer.resetWithShared(_inputBuffer, (ptr - _inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inputPtr = _inputPtr;\n        int inputLen = _inputEnd;\n        char[] inputBuffer = _inputBuffer;\n\n        while (true) {\n            if (inputPtr >= inputLen) {\n                _inputPtr = inputPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inputPtr = _inputPtr;\n                inputLen = _inputEnd;\n            }\n            char c = inputBuffer[inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    _inputPtr = inputPtr;\n                    c = _decodeEscaped();\n                    inputPtr = _inputPtr;\n                    inputLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inputPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inputPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n    \n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private int _skipWS() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg)\n        throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \");\n    }\n}"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            final int[] codes = _icLatin1;",
        "line": 1542,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic final class ReaderBasedJsonParser\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n    \n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n    }\n    \n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _reader;\n    }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg)\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(eofMsg);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers()\n        throws IOException\n    {\n        super._releaseBuffers();\n        char[] buf = _inputBuffer;\n        if (buf != null) {\n            _inputBuffer = null;\n            _ioContext.releaseTokenBuffer(buf);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    \n    protected String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            // fall through\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n   /**********************************************************\n   /* Public API, traversal\n   /**********************************************************\n    */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           // First, field name itself:\n            String name = _parseName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n            i = _skipWS();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    @Override\n    public boolean nextFieldName(SerializableString str)\n         throws IOException, JsonParseException\n     */\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public String nextTextValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public long nextLongValue(long defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        _symbols.release();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == '.') { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == 'e' || ch == 'E') { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(ch);\n            }\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return _parseNumber2(negative);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private JsonToken _parseNumber2(boolean negative) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(negative, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        /* First: let's try to see if we have a simple name: one that does\n         * not cross input buffer boundary, and does not contain escape\n         * sequences.\n         */\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        int start = _inputPtr;\n                        _inputPtr = ptr+1; // to skip the quote\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, and not a number\n            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\nint maxCode = codes.length;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n\nif((codes[ch] != 0)){\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inputPtr = _inputPtr;\n        int inputLen = _inputEnd;\n        char[] inputBuffer = _inputBuffer;\n\n        while (true) {\n            if (inputPtr >= inputLen) {\n                _inputPtr = inputPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inputPtr = _inputPtr;\n                inputLen = _inputEnd;\n            }\n            char c = inputBuffer[inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    _inputPtr = inputPtr;\n                    c = _decodeEscaped();\n                    inputPtr = _inputPtr;\n                    inputLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inputPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inputPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n    \n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private int _skipWS() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg)\n        throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \");\n    }\n}"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (ch < maxCode && codes[ch] != 0) {",
        "line": 1542,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic final class ReaderBasedJsonParser\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n    \n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n    }\n    \n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _reader;\n    }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg)\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(eofMsg);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers()\n        throws IOException\n    {\n        super._releaseBuffers();\n        char[] buf = _inputBuffer;\n        if (buf != null) {\n            _inputBuffer = null;\n            _ioContext.releaseTokenBuffer(buf);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    \n    protected String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            // fall through\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n   /**********************************************************\n   /* Public API, traversal\n   /**********************************************************\n    */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           // First, field name itself:\n            String name = _parseName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n            i = _skipWS();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    @Override\n    public boolean nextFieldName(SerializableString str)\n         throws IOException, JsonParseException\n     */\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public String nextTextValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public long nextLongValue(long defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        _symbols.release();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == '.') { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == 'e' || ch == 'E') { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(ch);\n            }\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return _parseNumber2(negative);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private JsonToken _parseNumber2(boolean negative) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(negative, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        /* First: let's try to see if we have a simple name: one that does\n         * not cross input buffer boundary, and does not contain escape\n         * sequences.\n         */\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        int start = _inputPtr;\n                        _inputPtr = ptr+1; // to skip the quote\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, and not a number\n            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\nif((ch < maxCode)){\n                    if (ch == '\"') {\n\n_textBuffer.resetWithShared(_inputBuffer, ptr);\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inputPtr = _inputPtr;\n        int inputLen = _inputEnd;\n        char[] inputBuffer = _inputBuffer;\n\n        while (true) {\n            if (inputPtr >= inputLen) {\n                _inputPtr = inputPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inputPtr = _inputPtr;\n                inputLen = _inputEnd;\n            }\n            char c = inputBuffer[inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    _inputPtr = inputPtr;\n                    c = _decodeEscaped();\n                    inputPtr = _inputPtr;\n                    inputLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inputPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inputPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n    \n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private int _skipWS() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg)\n        throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \");\n    }\n}"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        int ptr = _inputPtr;",
        "line": 854,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_2_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        boolean negative = (ch == INT_MINUS);",
        "line": 853,
        "aftercode": ""
    }
]