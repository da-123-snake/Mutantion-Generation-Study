[
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException",
        "line": 643,
        "aftercode": ""
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "    public void writeRaw(String text, int offset, int len) throws IOException",
        "line": 523,
        "aftercode": ""
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        return inputEnd;",
        "line": 1905,
        "aftercode": ""
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException",
        "line": 643,
        "aftercode": ""
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "_writeRawSegment(buf, len2);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "_writeRawSegment(buf);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException",
        "line": 643,
        "aftercode": ""
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "    public void writeRaw(String text, int offset, int len) throws IOException",
        "line": 523,
        "aftercode": ""
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "_writeRawSegment(buf, 0);"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "                break;",
        "line": 1897,
        "aftercode": "return;"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            if ((_outputTail + 3) >= _outputEnd) {",
        "line": 666,
        "aftercode": "if((ch >= 0x80)){"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        maxRead = Math.min(maxRead, readBuffer.length);",
        "line": 1892,
        "aftercode": "maxRead = readBuffer;"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        final int end = _outputEnd;",
        "line": 645,
        "aftercode": "byte[] bbuf = _outputBuffer;"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            if (ch < 0x800) { // 2-byte?",
        "line": 670,
        "aftercode": ""
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        final int end = _outputEnd;",
        "line": 645,
        "aftercode": "int bbuf = _outputBuffer;"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        maxRead = Math.min(maxRead, readBuffer.length);",
        "line": 1892,
        "aftercode": "maxRead = ;"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException",
        "line": 643,
        "aftercode": ""
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            if ((_outputTail + 3) >= _outputEnd) {",
        "line": 666,
        "aftercode": "if((ch < 0x800)){"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        maxRead = Math.min(maxRead, readBuffer.length);",
        "line": 1892,
        "aftercode": "maxRead = Math.min(readBuffer, inputEnd, length);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "                    break inner_loop;",
        "line": 655,
        "aftercode": "continue;"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "_writeRawSegment(maxChunk);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            return;",
        "line": 531,
        "aftercode": "break;"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);",
        "line": 674,
        "aftercode": "offset = _outputRawMultiByteChar(cbuf);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "                bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));",
        "line": 671,
        "aftercode": "(byte)(0xc0 | (ch >> 6));"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        maxRead = Math.min(maxRead, readBuffer.length);",
        "line": 1892,
        "aftercode": "maxRead = min(maxRead, readBuffer.length);"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        maxRead = Math.min(maxRead, readBuffer.length);",
        "line": 1892,
        "aftercode": "maxRead = in;"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "    public void writeRaw(String text, int offset, int len) throws IOException",
        "line": 523,
        "aftercode": ""
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);",
        "line": 674,
        "aftercode": "offset = _outputRawMultiByteChar(cbuf, offset);"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        maxRead = Math.min(maxRead, readBuffer.length);",
        "line": 1892,
        "aftercode": "inputEnd += count;"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);",
        "line": 674,
        "aftercode": "offset = _outputRawMultiByteChar(cbuf, offset, inputEnd);"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        inputPtr = 0;",
        "line": 1890,
        "aftercode": "continue;"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "return;"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "_writeRawSegment();"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        inputEnd = i;",
        "line": 1891,
        "aftercode": "continue;"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "_writeRawSegment(maxChunk, len);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "_writeRawSegment(len2);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        final byte[] bbuf = _outputBuffer;",
        "line": 646,
        "aftercode": "byte[] end = _outputEnd;"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "_writeRawSegment(len2, buf);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "                bbuf[_outputTail++] = (byte) ch;",
        "line": 661,
        "aftercode": "cbuf[offset];"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException",
        "line": 643,
        "aftercode": ""
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            return;",
        "line": 531,
        "aftercode": "continue;"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        inputEnd = i;",
        "line": 1891,
        "aftercode": "int length = (maxRead - inputEnd);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            if ((_outputTail + 3) >= _outputEnd) {",
        "line": 625,
        "aftercode": "            }"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            int length = maxRead - inputEnd;",
        "line": 1895,
        "aftercode": "break;"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException",
        "line": 643,
        "aftercode": "char[] cbuf,int offset    {"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);",
        "line": 674,
        "aftercode": "offset = _outputRawMultiByteChar(cbuf, inputEnd);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "                bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));",
        "line": 672,
        "aftercode": "(byte)(0x80 | (ch & 0x3f));"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException",
        "line": 643,
        "aftercode": ""
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            if ((_outputTail + 3) >= _outputEnd) {",
        "line": 625,
        "aftercode": "            }"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "_writeRawSegment(0, buf);"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        int i = 0;",
        "line": 1886,
        "aftercode": "int i = ;"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "                bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));",
        "line": 672,
        "aftercode": "bbuf[_outputTail++] = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        final int end = _outputEnd;",
        "line": 645,
        "aftercode": "byte[] end = _outputEnd;"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            if (length == 0) {",
        "line": 1896,
        "aftercode": "break;"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        if (len <= buf.length) {",
        "line": 528,
        "aftercode": "if(_charBuffer){"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            offset += len2;",
        "line": 555,
        "aftercode": "continue;"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "_writeRawSegment(maxBytes);"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        inputPtr = 0;",
        "line": 1890,
        "aftercode": "break;"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "        maxRead = Math.min(maxRead, readBuffer.length);",
        "line": 1892,
        "aftercode": "maxRead = Math.min(in);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "_writeRawSegment(buf, maxBytes);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "_writeRawSegment(maxChunk, buf);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "                if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {",
        "line": 525,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\npublic class UTF8JsonGenerator\n    extends JsonGeneratorImpl\n{\n    private final static byte BYTE_u = (byte) 'u';\n\n    private final static byte BYTE_0 = (byte) '0';\n\n    private final static byte BYTE_LBRACKET = (byte) '[';\n    private final static byte BYTE_RBRACKET = (byte) ']';\n    private final static byte BYTE_LCURLY = (byte) '{';\n    private final static byte BYTE_RCURLY = (byte) '}';\n\n    private final static byte BYTE_BACKSLASH = (byte) '\\\\';\n    private final static byte BYTE_COMMA = (byte) ',';\n    private final static byte BYTE_COLON = (byte) ':';\n    private final static byte BYTE_QUOTE = (byte) '\"';\n\n    // intermediate copies only made up to certain length...\n    private final static int MAX_BYTES_TO_BUFFER = 512;\n\n    private final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n\n    private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n    private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' };\n    private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' };\n\n    /*\n    /**********************************************************\n    /* Output buffering\n    /**********************************************************\n     */\n\n    /**\n     * Underlying output stream used for writing JSON content.\n     */\n    final protected OutputStream _outputStream;\n\n    /**\n     * Intermediate buffer in which contents are buffered before\n     * being written using {@link #_outputStream}.\n     */\n    protected byte[] _outputBuffer;\n\n    /**\n     * Pointer to the position right beyond the last character to output\n     * (end marker; may be past the buffer)\n     */\n    protected int _outputTail;\n\n    /**\n     * End marker of the output buffer; one past the last valid position\n     * within the buffer.\n     */\n    protected final int _outputEnd;\n\n    /**\n     * Maximum number of <code>char</code>s that we know will always fit\n     * in the output buffer after escaping\n     */\n    protected final int _outputMaxContiguous;\n\n    /**\n     * Intermediate buffer in which characters of a String are copied\n     * before being encoded.\n     */\n    protected char[] _charBuffer;\n\n    /**\n     * Length of <code>_charBuffer</code>\n     */\n    protected final int _charBufferLength;\n\n    /**\n     * 6 character temporary buffer allocated if needed, for constructing\n     * escape sequences\n     */\n    protected byte[] _entityBuffer;\n\n    /**\n     * Flag that indicates whether the output buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n            OutputStream out)\n    {\n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = true;\n        _outputBuffer = ctxt.allocWriteEncodingBuffer();\n        _outputEnd = _outputBuffer.length;\n\n        /* To be exact, each char can take up to 6 bytes when escaped (Unicode\n         * escape with backslash, 'u' and 4 hex digits); but to avoid fluctuation,\n         * we will actually round down to only do up to 1/8 number of chars\n         */\n        _outputMaxContiguous = _outputEnd >> 3;\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n\n        // By default we use this feature to determine additional quoting\n        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n            setHighestNonEscapedChar(127);\n        }\n    }\n    \n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n            OutputStream out,\n            byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)\n    {\n        \n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = bufferRecyclable;\n        _outputTail = outputOffset;\n        _outputBuffer = outputBuffer;\n        _outputEnd = _outputBuffer.length;\n        // up to 6 bytes per char (see above), rounded up to 1/8\n        _outputMaxContiguous = (_outputEnd >> 3);\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden configuration methods\n    /**********************************************************\n     */\n    \n    @Override\n    public Object getOutputTarget() {\n        return _outputStream;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        // Assuming tail is always valid, set to 0 on close\n        return _outputTail;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden methods\n    /**********************************************************\n     */\n\n    @Override\n    public void writeFieldName(String name)  throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        /* To support [JACKSON-46], we'll do this:\n         * (Question: should quoting of spaces (etc) still be enabled?)\n         */\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        // Does it fit in buffer?\n        if (len > _charBufferLength) { // no, offline\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(name, 0, len);\n        } else {\n            _writeStringSegments(name, 0, len);\n        }\n        // and closing quotes; need room for one more char:\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        if (_cfgUnqNames) {\n            _writeUnq(name);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) { // couldn't append, bit longer processing\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    private final void _writeUnq(SerializableString name) throws IOException {\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n        }\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    /**\n     * Specialized version of <code>_writeFieldName</code>, off-lined\n     * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n     */\n    protected final void _writePPFieldName(String name) throws IOException\n    {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        if (len > _charBufferLength) {\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        name.getChars(0, len, _charBuffer, 0);\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(_charBuffer, 0, len);\n        } else {\n            _writeStringSegments(_charBuffer, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    protected final void _writePPFieldName(SerializableString name) throws IOException\n    {\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        final boolean addQuotes = !_cfgUnqNames; // standard\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n        _writeBytes(name.asQuotedUTF8());\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        // First: if we can't guarantee it all fits, quoted, within output, offline\n        final int len = text.length();\n        if (len > _outputMaxContiguous) { // nope: off-line handling\n            _writeStringSegments(text, true);\n            return;\n        }\n        if ((_outputTail + len) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeStringSegment(text, 0, len); // we checked space already above\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n        } else {\n            _writeStringSegments(text, offset, len);\n        }\n        // And finally, closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public final void writeString(SerializableString text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = text.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(text.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBytes(text, offset, length);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            _writeUTF8Segment(text, offset, len);\n        } else {\n            _writeUTF8Segments(text, offset, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, unprocessed (\"raw\")\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        writeRaw(text, 0, text.length());\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException\n    {\n        final char[] buf = _charBuffer;\n\n        // minor optimization: see if we can just get and copy\n        if (len <= buf.length) {\n            text.getChars(offset, offset+len, buf, 0);\n            _writeRawSegment(buf, 0, len);\n            return;\n        }\n\n        // If not, need segmented approach. For speed, let's also use input buffer\n        // size that is guaranteed to fit in output buffer; each char can expand to\n        // at most 3 bytes, so at most 1/3 of buffer size.\n        final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); // == (1/4 + 1/16) == 5/16\n        final int maxBytes = maxChunk * 3;\n\n        while (len > 0) {\n            int len2 = Math.min(maxChunk, len);\n            text.getChars(offset, offset+len2, buf, 0);\n            if ((_outputTail + maxBytes) > _outputEnd) {\n                _flushBuffer();\n            }\n            // If this is NOT the last segment and if the last character looks like\n            // split surrogate second half, drop it\n            if (len > 0) {\n                char ch = buf[len2-1];\nif((ch >= SURR1_FIRST)){\n                    --len2;\n                }\n            }\n\n_writeRawSegment(buf);\n            offset += len2;\n            len -= len2;\n        }\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException\n    {\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    // since 2.5\n    @Override\n    public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_RAW);\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    // @TODO: rewrite for speed...\n    @Override\n    public final void writeRaw(char[] cbuf, int offset, int len) throws IOException\n    {\n        // First: if we have 3 x charCount spaces, we know it'll fit just fine\n        {\n            int len3 = len+len+len;\n            if ((_outputTail + len3) > _outputEnd) {\n                // maybe we could flush?\n                if (_outputEnd < len3) { // wouldn't be enough...\n                    _writeSegmentedRaw(cbuf, offset, len);\n                    return;\n                }\n                // yes, flushing brings enough space\n                _flushBuffer();\n            }\n        }\n        len += offset; // now marks the end\n\n        // Note: here we know there is enough room, hence no output boundary checks\n        main_loop:\n        while (offset < len) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= len) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, len);\n            }\n        }\n    }\n\n    @Override\n    public void writeRaw(char ch) throws IOException\n    {\n        if ((_outputTail + 3) >= _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        if (ch <= 0x7F) {\n            bbuf[_outputTail++] = (byte) ch;\n        } else  if (ch < 0x800) { // 2-byte?\n            bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n            bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        } else {\n            /*offset =*/ _outputRawMultiByteChar(ch, null, 0, 0);\n        }\n    }\n\n    /**\n     * Helper method called when it is possible that output of raw section\n     * to output may cross buffer boundary\n     */\n    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException\n    {\n        final int end = _outputEnd;\n        final byte[] bbuf = _outputBuffer;\n        final int inputEnd = offset + len;\n        \n        main_loop:\n        while (offset < inputEnd) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch >= 0x80) {\n                    break inner_loop;\n                }\n                // !!! TODO: fast(er) writes (roll input, output checks in one)\n                if (_outputTail >= end) {\n                    _flushBuffer();\n                }\n                bbuf[_outputTail++] = (byte) ch;\n                if (++offset >= inputEnd) {\n                    break main_loop;\n                }\n            }\n            if ((_outputTail + 3) >= _outputEnd) {\n                _flushBuffer();\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);\n            }\n        }\n    }\n\n    /**\n     * Helper method that is called for segmented write of raw content\n     * when explicitly outputting a segment of longer thing.\n     * Caller has to take care of ensuring there's no split surrogate\n     * pair at the end (that is, last char can not be first part of a\n     * surrogate char pair).\n     *\n     * @since 2.8.2\n     */\n    private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException\n    {\n        main_loop:\n        while (offset < end) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= end) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, end);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, base64-encoded binary\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant,\n            byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBinary(b64variant, data, offset, offset+len);\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant,\n            InputStream data, int dataLength)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { // length unknown\n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        return bytes;\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, primitive\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short s) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        // up to 5 digits and possible minus sign\n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n    \n    private final void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    } \n    \n    @Override\n    public void writeNumber(int i) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        // up to 10 digits and possible minus sign\n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedInt(int i) throws IOException\n    {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            // up to 20 digits, minus sign\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedLong(long l) throws IOException\n    {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            (((Double.isNaN(d) || Double.isInfinite(d))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        // What is the max length for doubles? 40 chars?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            // [JACKSON-139]\n            (((Float.isNaN(f) || Float.isInfinite(f))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        // What is the max length for floats?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)\n                    ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);            \n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private final void _writeQuotedRaw(String value) throws IOException\n    {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException\n    {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;\n        int len = keyword.length;\n        System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    @Override\n    public void writeNull() throws IOException\n    {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    /*\n    /**********************************************************\n    /* Implementations for other methods\n    /**********************************************************\n     */\n\n    @Override\n    protected final void _verifyValueWrite(String typeMsg) throws IOException\n    {\n        int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        if (_cfgPrettyPrinter == null) {\n            byte b;\n            switch (status) {\n            case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n                b = BYTE_COMMA;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_COLON:\n                b = BYTE_COLON;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator\n                if (_rootValueSeparator != null) {\n                    byte[] raw = _rootValueSeparator.asUnquotedUTF8();\n                    if (raw.length > 0) {\n                        _writeBytes(raw);\n                    }\n                }\n                return;\n            case JsonWriteContext.STATUS_OK_AS_IS:\n            default:\n                return;\n            }\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail] = b;\n            ++_outputTail;\n            return;\n        }\n        // Otherwise, pretty printer knows what to do...\n        _verifyPrettyValueWrite(typeMsg, status);\n    }\n\n    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException\n    {\n        // If we have a pretty printer, it knows what to do:\n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array\n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            // First entry, but of which context?\n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException\n    {\n        _flushBuffer();\n        if (_outputStream != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _outputStream.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n\n        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n         *   scopes.\n         */\n        // First: let's see that we still have buffers...\n        if ((_outputBuffer != null)\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputTail = 0; // just to ensure we don't think there's anything buffered\n\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside: when using UTF8Writer, underlying buffer(s)\n         *   may not be properly recycled if we don't close the writer.\n         */\n        if (_outputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _outputStream.close();\n            } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                // If we can't close it, we should at least flush\n                _outputStream.flush();\n            }\n        }\n        // Internal buffer(s) generator has can now be released as well\n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers()\n    {\n        byte[] buf = _outputBuffer;\n        if (buf != null && _bufferRecyclable) {\n            _outputBuffer = null;\n            _ioContext.releaseWriteEncodingBuffer(buf);\n        }\n        char[] cbuf = _charBuffer;\n        if (cbuf != null) {\n            _charBuffer = null;\n            _ioContext.releaseConcatBuffer(cbuf);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, raw bytes\n    /**********************************************************\n     */\n\n    private final void _writeBytes(byte[] bytes) throws IOException\n    {\n        final int len = bytes.length;\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            // still not enough?\n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, 0, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException\n    {\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            // still not enough?\n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, offset, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, mid-level writing, String segments\n    /**********************************************************\n     */\n    \n    /**\n     * Method called when String to write is long enough not to fit\n     * completely in temporary copy buffer. If so, we will actually\n     * copy it in small enough chunks so it can be directly fed\n     * to single-segment writes (instead of maximum slices that\n     * would fit in copy buffer)\n     */\n    private final void _writeStringSegments(String text, boolean addQuotes) throws IOException\n    {\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;        \n        }\n\n        int left = text.length();\n        int offset = 0;\n\n        while (left > 0) {\n            int len = Math.min(_outputMaxContiguous, left);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            left -= len;\n        }\n\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n\n    /**\n     * Method called when character sequence to write is long enough that\n     * its maximum encoded and escaped form is not guaranteed to fit in\n     * the output buffer. If so, we will need to choose smaller output\n     * chunks to write at a time.\n     */\n    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(cbuf, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segments\n    /**********************************************************\n     */\n\n    /**\n     * This method called when the string content is already in\n     * a char buffer, and its maximum total encoded and escaped length\n     * can not exceed size of the output buffer.\n     * Caller must ensure that there is enough space in output buffer,\n     * assuming case of all non-escaped ASCII characters, as well as\n     * potentially enough space for other cases (but not necessarily flushed)\n     */\n    private final void _writeStringSegment(char[] cbuf, int offset, int len)\n        throws IOException\n    {\n        // note: caller MUST ensure (via flushing) there's room for ASCII only\n        \n        // Fast+tight loop for ASCII-only, no-escaping-needed output\n        len += offset; // becomes end marker, then\n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = cbuf[offset];\n            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            // [JACKSON-106]\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(cbuf, offset, len);\n            // [JACKSON-102]\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(cbuf, offset, len);\n            } else {\n                _writeStringSegmentASCII2(cbuf, offset, len);\n            }\n\n        }\n    }\n\n    private final void _writeStringSegment(String text, int offset, int len) throws IOException\n    {\n        // note: caller MUST ensure (via flushing) there's room for ASCII only\n        // Fast+tight loop for ASCII-only, no-escaping-needed output\n        len += offset; // becomes end marker, then\n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = text.charAt(offset);\n            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(text, offset, len);\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(text, offset, len);\n            } else {\n                _writeStringSegmentASCII2(text, offset, len);\n            }\n        }\n    }\n\n    /**\n     * Secondary method called when content contains characters to escape,\n     * and/or multi-byte UTF-8 characters.\n     */\n    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException\n    {\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with additional escaping (ASCII or such)\n    /**********************************************************\n     */\n\n    /**\n     * Same as <code>_writeStringSegment2(char[], ...)</code., but with\n     * additional escaping for high-range code points\n     */\n    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with fully custom escaping (and possibly escaping of non-ASCII\n    /**********************************************************\n     */\n\n    /**\n     * Same as <code>_writeStringSegmentASCII2(char[], ...)</code., but with\n     * additional checking for completely custom escapes\n     */\n    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        // may or may not have this limit\n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        // may or may not have this limit\n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars)\n        throws IOException, JsonGenerationException\n    {\n        byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote\n        int len = raw.length;\n        if (len > 6) { // may violate constraints we have, do offline\n            return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars);\n        }\n        // otherwise will fit without issues, so:\n        System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n        return (outputPtr + len);\n    }\n    \n    private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw,\n            int remainingChars)\n        throws IOException, JsonGenerationException\n    {\n        int len = raw.length;\n        if ((outputPtr + len) > outputEnd) {\n            _outputTail = outputPtr;\n            _flushBuffer();\n            outputPtr = _outputTail;\n            if (len > outputBuffer.length) { // very unlikely, but possible...\n                _outputStream.write(raw, 0, len);\n                return outputPtr;\n            }\n            System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n            outputPtr += len;\n        }\n        // but is the invariant still obeyed? If not, flush once more\n        if ((outputPtr +  6 * remainingChars) > outputEnd) {\n            _flushBuffer();\n            return _outputTail;\n        }\n        return outputPtr;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, \"raw UTF-8\" segments\n    /**********************************************************\n     */\n    \n    /**\n     * Method called when UTF-8 encoded (but NOT yet escaped!) content is not guaranteed\n     * to fit in the output buffer after escaping; as such, we just need to\n     * chunk writes.\n     */\n    private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen)\n        throws IOException, JsonGenerationException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            _writeUTF8Segment(utf8, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n    \n    private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len)\n        throws IOException, JsonGenerationException\n    {\n        // fast loop to see if escaping is needed; don't copy, just look\n        final int[] escCodes = _outputEscapes;\n\n        for (int ptr = offset, end = offset + len; ptr < end; ) {\n            // 28-Feb-2011, tatu: escape codes just cover 7-bit range, so:\n            int ch = utf8[ptr++];\n            if ((ch >= 0) && escCodes[ch] != 0) {\n                _writeUTF8Segment2(utf8, offset, len);\n                return;\n            }\n        }\n        \n        // yes, fine, just copy the sucker\n        if ((_outputTail + len) > _outputEnd) { // enough room or need to flush?\n            _flushBuffer(); // but yes once we flush (caller guarantees length restriction)\n        }\n        System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        int outputPtr = _outputTail;\n\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((outputPtr + (len * 6)) > _outputEnd) {\n            _flushBuffer();\n            outputPtr = _outputTail;\n        }\n        \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        len += offset; // so 'len' becomes 'end'\n        \n        while (offset < len) {\n            byte b = utf8[offset++];\n            int ch = b;\n            if (ch < 0 || escCodes[ch] == 0) {\n                outputBuffer[outputPtr++] = b;\n                continue;\n            }\n            int escape = escCodes[ch];\n            if (escape > 0) { // 2-char escape, fine\n                outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                outputBuffer[outputPtr++] = (byte) escape;\n            } else {\n                // ctrl-char, 6-byte escape...\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, base64 encoded\n    /**********************************************************\n     */\n    \n    protected final void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    // write-method called when length is definitely known\n    protected final int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n\n    // write method when length is unknown\n    protected final int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (true) {\n            if (inputPtr > lastFullOffset) { // need to load more\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        if (inputPtr < inputEnd) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private final int _readMore(InputStream in,\n            byte[] readBuffer, int inputPtr, int inputEnd,\n            int maxRead) throws IOException\n    {\n        // anything to shift to front?\n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, character escapes/encoding\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to output a character that is beyond range of\n     * 1- and 2-byte UTF-8 encodings, when outputting \"raw\" \n     * text (meaning it is not to be escaped or quoted)\n     */\n    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd)\n        throws IOException\n    {\n        // Let's handle surrogates gracefully (as 4 byte output):\n        if (ch >= SURR1_FIRST) {\n            if (ch <= SURR2_LAST) { // yes, outside of BMP\n                // Do we have second part?\n                if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down\n                    _reportError(String.format(\n\"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));\n                }\n                _outputSurrogates(ch, cbuf[inputOffset]);\n                return inputOffset+1;\n            }\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        return inputOffset;\n    }\n\n    protected final void _outputSurrogates(int surr1, int surr2) throws IOException\n    {\n        int c = _decodeSurrogate(surr1, surr2);\n        if ((_outputTail + 4) > _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f));\n    }\n    \n    /**\n     * \n     * @param ch\n     * @param outputPtr Position within output buffer to append multi-byte in\n     * \n     * @return New output position after appending\n     * \n     * @throws IOException\n     */\n    private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException\n    {\n        byte[] bbuf = _outputBuffer;\n        if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape\n            // 23-Nov-2015, tatu: As per [core#223], may or may not want escapes;\n            //   it would be added here... but as things are, we do not have proper\n            //   access yet...\n//            if (Feature.ESCAPE_UTF8_SURROGATES.enabledIn(_features)) {\n                bbuf[outputPtr++] = BYTE_BACKSLASH;\n                bbuf[outputPtr++] = BYTE_u;\n                \n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n//            } else { ... }\n        } else {\n            bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n            bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n            bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n        }\n        return outputPtr;\n    }\n\n    private final void _writeNull() throws IOException\n    {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\n        _outputTail += 4;\n    }\n        \n    /**\n     * Method called to write a generic Unicode escape for given character.\n     * \n     * @param charToEscape Character to escape using escape sequence (\\\\uXXXX)\n     */\n    private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException\n    {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[outputPtr++] = BYTE_BACKSLASH;\n        bbuf[outputPtr++] = BYTE_u;\n        if (charToEscape > 0xFF) {\n            int hi = (charToEscape >> 8) & 0xFF;\n            bbuf[outputPtr++] = HEX_CHARS[hi >> 4];\n            bbuf[outputPtr++] = HEX_CHARS[hi & 0xF];\n            charToEscape &= 0xFF;\n        } else {\n            bbuf[outputPtr++] = BYTE_0;\n            bbuf[outputPtr++] = BYTE_0;\n        }\n        // We know it's a control char, so only the last 2 chars are non-0\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4];\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF];\n        return outputPtr;\n    }\n\n    protected final void _flushBuffer() throws IOException\n    {\n        int len = _outputTail;\n        if (len > 0) {\n            _outputTail = 0;\n            _outputStream.write(_outputBuffer, 0, len);\n        }\n    }\n}"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len2);",
        "line": 554,
        "aftercode": "_writeRawSegment(maxChunk, 0);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "                if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {",
        "line": 525,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\npublic class UTF8JsonGenerator\n    extends JsonGeneratorImpl\n{\n    private final static byte BYTE_u = (byte) 'u';\n\n    private final static byte BYTE_0 = (byte) '0';\n\n    private final static byte BYTE_LBRACKET = (byte) '[';\n    private final static byte BYTE_RBRACKET = (byte) ']';\n    private final static byte BYTE_LCURLY = (byte) '{';\n    private final static byte BYTE_RCURLY = (byte) '}';\n\n    private final static byte BYTE_BACKSLASH = (byte) '\\\\';\n    private final static byte BYTE_COMMA = (byte) ',';\n    private final static byte BYTE_COLON = (byte) ':';\n    private final static byte BYTE_QUOTE = (byte) '\"';\n\n    // intermediate copies only made up to certain length...\n    private final static int MAX_BYTES_TO_BUFFER = 512;\n\n    private final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n\n    private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n    private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' };\n    private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' };\n\n    /*\n    /**********************************************************\n    /* Output buffering\n    /**********************************************************\n     */\n\n    /**\n     * Underlying output stream used for writing JSON content.\n     */\n    final protected OutputStream _outputStream;\n\n    /**\n     * Intermediate buffer in which contents are buffered before\n     * being written using {@link #_outputStream}.\n     */\n    protected byte[] _outputBuffer;\n\n    /**\n     * Pointer to the position right beyond the last character to output\n     * (end marker; may be past the buffer)\n     */\n    protected int _outputTail;\n\n    /**\n     * End marker of the output buffer; one past the last valid position\n     * within the buffer.\n     */\n    protected final int _outputEnd;\n\n    /**\n     * Maximum number of <code>char</code>s that we know will always fit\n     * in the output buffer after escaping\n     */\n    protected final int _outputMaxContiguous;\n\n    /**\n     * Intermediate buffer in which characters of a String are copied\n     * before being encoded.\n     */\n    protected char[] _charBuffer;\n\n    /**\n     * Length of <code>_charBuffer</code>\n     */\n    protected final int _charBufferLength;\n\n    /**\n     * 6 character temporary buffer allocated if needed, for constructing\n     * escape sequences\n     */\n    protected byte[] _entityBuffer;\n\n    /**\n     * Flag that indicates whether the output buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n            OutputStream out)\n    {\n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = true;\n        _outputBuffer = ctxt.allocWriteEncodingBuffer();\n        _outputEnd = _outputBuffer.length;\n\n        /* To be exact, each char can take up to 6 bytes when escaped (Unicode\n         * escape with backslash, 'u' and 4 hex digits); but to avoid fluctuation,\n         * we will actually round down to only do up to 1/8 number of chars\n         */\n        _outputMaxContiguous = _outputEnd >> 3;\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n\n        // By default we use this feature to determine additional quoting\n        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n            setHighestNonEscapedChar(127);\n        }\n    }\n    \n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n            OutputStream out,\n            byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)\n    {\n        \n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = bufferRecyclable;\n        _outputTail = outputOffset;\n        _outputBuffer = outputBuffer;\n        _outputEnd = _outputBuffer.length;\n        // up to 6 bytes per char (see above), rounded up to 1/8\n        _outputMaxContiguous = (_outputEnd >> 3);\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden configuration methods\n    /**********************************************************\n     */\n    \n    @Override\n    public Object getOutputTarget() {\n        return _outputStream;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        // Assuming tail is always valid, set to 0 on close\n        return _outputTail;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden methods\n    /**********************************************************\n     */\n\n    @Override\n    public void writeFieldName(String name)  throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        /* To support [JACKSON-46], we'll do this:\n         * (Question: should quoting of spaces (etc) still be enabled?)\n         */\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        // Does it fit in buffer?\n        if (len > _charBufferLength) { // no, offline\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(name, 0, len);\n        } else {\n            _writeStringSegments(name, 0, len);\n        }\n        // and closing quotes; need room for one more char:\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        if (_cfgUnqNames) {\n            _writeUnq(name);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) { // couldn't append, bit longer processing\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    private final void _writeUnq(SerializableString name) throws IOException {\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n        }\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    /**\n     * Specialized version of <code>_writeFieldName</code>, off-lined\n     * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n     */\n    protected final void _writePPFieldName(String name) throws IOException\n    {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        if (len > _charBufferLength) {\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        name.getChars(0, len, _charBuffer, 0);\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(_charBuffer, 0, len);\n        } else {\n            _writeStringSegments(_charBuffer, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    protected final void _writePPFieldName(SerializableString name) throws IOException\n    {\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        final boolean addQuotes = !_cfgUnqNames; // standard\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n        _writeBytes(name.asQuotedUTF8());\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        // First: if we can't guarantee it all fits, quoted, within output, offline\n        final int len = text.length();\n        if (len > _outputMaxContiguous) { // nope: off-line handling\n            _writeStringSegments(text, true);\n            return;\n        }\n        if ((_outputTail + len) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeStringSegment(text, 0, len); // we checked space already above\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n        } else {\n            _writeStringSegments(text, offset, len);\n        }\n        // And finally, closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public final void writeString(SerializableString text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = text.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(text.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBytes(text, offset, length);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            _writeUTF8Segment(text, offset, len);\n        } else {\n            _writeUTF8Segments(text, offset, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, unprocessed (\"raw\")\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        writeRaw(text, 0, text.length());\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException\n    {\n        final char[] buf = _charBuffer;\n\n        // minor optimization: see if we can just get and copy\n        if (len <= buf.length) {\n            text.getChars(offset, offset+len, buf, 0);\n            _writeRawSegment(buf, 0, len);\n            return;\n        }\n\n        // If not, need segmented approach. For speed, let's also use input buffer\n        // size that is guaranteed to fit in output buffer; each char can expand to\n        // at most 3 bytes, so at most 1/3 of buffer size.\n        final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); // == (1/4 + 1/16) == 5/16\n        final int maxBytes = maxChunk * 3;\n\n        while (len > 0) {\n            int len2 = Math.min(maxChunk, len);\n            text.getChars(offset, offset+len2, buf, 0);\n            if ((_outputTail + maxBytes) > _outputEnd) {\n                _flushBuffer();\n            }\n            // If this is NOT the last segment and if the last character looks like\n            // split surrogate second half, drop it\n            if (len > 0) {\n                char ch = buf[len2-1];\nif((ch >= SURR1_FIRST)){\n                    --len2;\n                }\n            }\n\n_writeRawSegment(buf, len2);\n            offset += len2;\n            len -= len2;\n        }\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException\n    {\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    // since 2.5\n    @Override\n    public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_RAW);\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    // @TODO: rewrite for speed...\n    @Override\n    public final void writeRaw(char[] cbuf, int offset, int len) throws IOException\n    {\n        // First: if we have 3 x charCount spaces, we know it'll fit just fine\n        {\n            int len3 = len+len+len;\n            if ((_outputTail + len3) > _outputEnd) {\n                // maybe we could flush?\n                if (_outputEnd < len3) { // wouldn't be enough...\n                    _writeSegmentedRaw(cbuf, offset, len);\n                    return;\n                }\n                // yes, flushing brings enough space\n                _flushBuffer();\n            }\n        }\n        len += offset; // now marks the end\n\n        // Note: here we know there is enough room, hence no output boundary checks\n        main_loop:\n        while (offset < len) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= len) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, len);\n            }\n        }\n    }\n\n    @Override\n    public void writeRaw(char ch) throws IOException\n    {\n        if ((_outputTail + 3) >= _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        if (ch <= 0x7F) {\n            bbuf[_outputTail++] = (byte) ch;\n        } else  if (ch < 0x800) { // 2-byte?\n            bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n            bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        } else {\n            /*offset =*/ _outputRawMultiByteChar(ch, null, 0, 0);\n        }\n    }\n\n    /**\n     * Helper method called when it is possible that output of raw section\n     * to output may cross buffer boundary\n     */\n    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException\n    {\n        final int end = _outputEnd;\n        final byte[] bbuf = _outputBuffer;\n        final int inputEnd = offset + len;\n        \n        main_loop:\n        while (offset < inputEnd) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch >= 0x80) {\n                    break inner_loop;\n                }\n                // !!! TODO: fast(er) writes (roll input, output checks in one)\n                if (_outputTail >= end) {\n                    _flushBuffer();\n                }\n                bbuf[_outputTail++] = (byte) ch;\n                if (++offset >= inputEnd) {\n                    break main_loop;\n                }\n            }\n            if ((_outputTail + 3) >= _outputEnd) {\n                _flushBuffer();\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);\n            }\n        }\n    }\n\n    /**\n     * Helper method that is called for segmented write of raw content\n     * when explicitly outputting a segment of longer thing.\n     * Caller has to take care of ensuring there's no split surrogate\n     * pair at the end (that is, last char can not be first part of a\n     * surrogate char pair).\n     *\n     * @since 2.8.2\n     */\n    private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException\n    {\n        main_loop:\n        while (offset < end) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= end) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, end);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, base64-encoded binary\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant,\n            byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBinary(b64variant, data, offset, offset+len);\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant,\n            InputStream data, int dataLength)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { // length unknown\n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        return bytes;\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, primitive\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short s) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        // up to 5 digits and possible minus sign\n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n    \n    private final void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    } \n    \n    @Override\n    public void writeNumber(int i) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        // up to 10 digits and possible minus sign\n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedInt(int i) throws IOException\n    {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            // up to 20 digits, minus sign\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedLong(long l) throws IOException\n    {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            (((Double.isNaN(d) || Double.isInfinite(d))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        // What is the max length for doubles? 40 chars?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            // [JACKSON-139]\n            (((Float.isNaN(f) || Float.isInfinite(f))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        // What is the max length for floats?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)\n                    ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);            \n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private final void _writeQuotedRaw(String value) throws IOException\n    {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException\n    {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;\n        int len = keyword.length;\n        System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    @Override\n    public void writeNull() throws IOException\n    {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    /*\n    /**********************************************************\n    /* Implementations for other methods\n    /**********************************************************\n     */\n\n    @Override\n    protected final void _verifyValueWrite(String typeMsg) throws IOException\n    {\n        int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        if (_cfgPrettyPrinter == null) {\n            byte b;\n            switch (status) {\n            case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n                b = BYTE_COMMA;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_COLON:\n                b = BYTE_COLON;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator\n                if (_rootValueSeparator != null) {\n                    byte[] raw = _rootValueSeparator.asUnquotedUTF8();\n                    if (raw.length > 0) {\n                        _writeBytes(raw);\n                    }\n                }\n                return;\n            case JsonWriteContext.STATUS_OK_AS_IS:\n            default:\n                return;\n            }\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail] = b;\n            ++_outputTail;\n            return;\n        }\n        // Otherwise, pretty printer knows what to do...\n        _verifyPrettyValueWrite(typeMsg, status);\n    }\n\n    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException\n    {\n        // If we have a pretty printer, it knows what to do:\n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array\n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            // First entry, but of which context?\n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException\n    {\n        _flushBuffer();\n        if (_outputStream != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _outputStream.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n\n        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n         *   scopes.\n         */\n        // First: let's see that we still have buffers...\n        if ((_outputBuffer != null)\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputTail = 0; // just to ensure we don't think there's anything buffered\n\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside: when using UTF8Writer, underlying buffer(s)\n         *   may not be properly recycled if we don't close the writer.\n         */\n        if (_outputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _outputStream.close();\n            } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                // If we can't close it, we should at least flush\n                _outputStream.flush();\n            }\n        }\n        // Internal buffer(s) generator has can now be released as well\n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers()\n    {\n        byte[] buf = _outputBuffer;\n        if (buf != null && _bufferRecyclable) {\n            _outputBuffer = null;\n            _ioContext.releaseWriteEncodingBuffer(buf);\n        }\n        char[] cbuf = _charBuffer;\n        if (cbuf != null) {\n            _charBuffer = null;\n            _ioContext.releaseConcatBuffer(cbuf);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, raw bytes\n    /**********************************************************\n     */\n\n    private final void _writeBytes(byte[] bytes) throws IOException\n    {\n        final int len = bytes.length;\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            // still not enough?\n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, 0, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException\n    {\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            // still not enough?\n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, offset, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, mid-level writing, String segments\n    /**********************************************************\n     */\n    \n    /**\n     * Method called when String to write is long enough not to fit\n     * completely in temporary copy buffer. If so, we will actually\n     * copy it in small enough chunks so it can be directly fed\n     * to single-segment writes (instead of maximum slices that\n     * would fit in copy buffer)\n     */\n    private final void _writeStringSegments(String text, boolean addQuotes) throws IOException\n    {\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;        \n        }\n\n        int left = text.length();\n        int offset = 0;\n\n        while (left > 0) {\n            int len = Math.min(_outputMaxContiguous, left);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            left -= len;\n        }\n\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n\n    /**\n     * Method called when character sequence to write is long enough that\n     * its maximum encoded and escaped form is not guaranteed to fit in\n     * the output buffer. If so, we will need to choose smaller output\n     * chunks to write at a time.\n     */\n    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(cbuf, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segments\n    /**********************************************************\n     */\n\n    /**\n     * This method called when the string content is already in\n     * a char buffer, and its maximum total encoded and escaped length\n     * can not exceed size of the output buffer.\n     * Caller must ensure that there is enough space in output buffer,\n     * assuming case of all non-escaped ASCII characters, as well as\n     * potentially enough space for other cases (but not necessarily flushed)\n     */\n    private final void _writeStringSegment(char[] cbuf, int offset, int len)\n        throws IOException\n    {\n        // note: caller MUST ensure (via flushing) there's room for ASCII only\n        \n        // Fast+tight loop for ASCII-only, no-escaping-needed output\n        len += offset; // becomes end marker, then\n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = cbuf[offset];\n            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            // [JACKSON-106]\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(cbuf, offset, len);\n            // [JACKSON-102]\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(cbuf, offset, len);\n            } else {\n                _writeStringSegmentASCII2(cbuf, offset, len);\n            }\n\n        }\n    }\n\n    private final void _writeStringSegment(String text, int offset, int len) throws IOException\n    {\n        // note: caller MUST ensure (via flushing) there's room for ASCII only\n        // Fast+tight loop for ASCII-only, no-escaping-needed output\n        len += offset; // becomes end marker, then\n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = text.charAt(offset);\n            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(text, offset, len);\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(text, offset, len);\n            } else {\n                _writeStringSegmentASCII2(text, offset, len);\n            }\n        }\n    }\n\n    /**\n     * Secondary method called when content contains characters to escape,\n     * and/or multi-byte UTF-8 characters.\n     */\n    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException\n    {\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with additional escaping (ASCII or such)\n    /**********************************************************\n     */\n\n    /**\n     * Same as <code>_writeStringSegment2(char[], ...)</code., but with\n     * additional escaping for high-range code points\n     */\n    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with fully custom escaping (and possibly escaping of non-ASCII\n    /**********************************************************\n     */\n\n    /**\n     * Same as <code>_writeStringSegmentASCII2(char[], ...)</code., but with\n     * additional checking for completely custom escapes\n     */\n    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        // may or may not have this limit\n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        // may or may not have this limit\n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars)\n        throws IOException, JsonGenerationException\n    {\n        byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote\n        int len = raw.length;\n        if (len > 6) { // may violate constraints we have, do offline\n            return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars);\n        }\n        // otherwise will fit without issues, so:\n        System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n        return (outputPtr + len);\n    }\n    \n    private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw,\n            int remainingChars)\n        throws IOException, JsonGenerationException\n    {\n        int len = raw.length;\n        if ((outputPtr + len) > outputEnd) {\n            _outputTail = outputPtr;\n            _flushBuffer();\n            outputPtr = _outputTail;\n            if (len > outputBuffer.length) { // very unlikely, but possible...\n                _outputStream.write(raw, 0, len);\n                return outputPtr;\n            }\n            System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n            outputPtr += len;\n        }\n        // but is the invariant still obeyed? If not, flush once more\n        if ((outputPtr +  6 * remainingChars) > outputEnd) {\n            _flushBuffer();\n            return _outputTail;\n        }\n        return outputPtr;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, \"raw UTF-8\" segments\n    /**********************************************************\n     */\n    \n    /**\n     * Method called when UTF-8 encoded (but NOT yet escaped!) content is not guaranteed\n     * to fit in the output buffer after escaping; as such, we just need to\n     * chunk writes.\n     */\n    private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen)\n        throws IOException, JsonGenerationException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            _writeUTF8Segment(utf8, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n    \n    private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len)\n        throws IOException, JsonGenerationException\n    {\n        // fast loop to see if escaping is needed; don't copy, just look\n        final int[] escCodes = _outputEscapes;\n\n        for (int ptr = offset, end = offset + len; ptr < end; ) {\n            // 28-Feb-2011, tatu: escape codes just cover 7-bit range, so:\n            int ch = utf8[ptr++];\n            if ((ch >= 0) && escCodes[ch] != 0) {\n                _writeUTF8Segment2(utf8, offset, len);\n                return;\n            }\n        }\n        \n        // yes, fine, just copy the sucker\n        if ((_outputTail + len) > _outputEnd) { // enough room or need to flush?\n            _flushBuffer(); // but yes once we flush (caller guarantees length restriction)\n        }\n        System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        int outputPtr = _outputTail;\n\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((outputPtr + (len * 6)) > _outputEnd) {\n            _flushBuffer();\n            outputPtr = _outputTail;\n        }\n        \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        len += offset; // so 'len' becomes 'end'\n        \n        while (offset < len) {\n            byte b = utf8[offset++];\n            int ch = b;\n            if (ch < 0 || escCodes[ch] == 0) {\n                outputBuffer[outputPtr++] = b;\n                continue;\n            }\n            int escape = escCodes[ch];\n            if (escape > 0) { // 2-char escape, fine\n                outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                outputBuffer[outputPtr++] = (byte) escape;\n            } else {\n                // ctrl-char, 6-byte escape...\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, base64 encoded\n    /**********************************************************\n     */\n    \n    protected final void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    // write-method called when length is definitely known\n    protected final int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n\n    // write method when length is unknown\n    protected final int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (true) {\n            if (inputPtr > lastFullOffset) { // need to load more\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        if (inputPtr < inputEnd) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private final int _readMore(InputStream in,\n            byte[] readBuffer, int inputPtr, int inputEnd,\n            int maxRead) throws IOException\n    {\n        // anything to shift to front?\n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, character escapes/encoding\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to output a character that is beyond range of\n     * 1- and 2-byte UTF-8 encodings, when outputting \"raw\" \n     * text (meaning it is not to be escaped or quoted)\n     */\n    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd)\n        throws IOException\n    {\n        // Let's handle surrogates gracefully (as 4 byte output):\n        if (ch >= SURR1_FIRST) {\n            if (ch <= SURR2_LAST) { // yes, outside of BMP\n                // Do we have second part?\n                if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down\n                    _reportError(String.format(\n\"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));\n                }\n                _outputSurrogates(ch, cbuf[inputOffset]);\n                return inputOffset+1;\n            }\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        return inputOffset;\n    }\n\n    protected final void _outputSurrogates(int surr1, int surr2) throws IOException\n    {\n        int c = _decodeSurrogate(surr1, surr2);\n        if ((_outputTail + 4) > _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f));\n    }\n    \n    /**\n     * \n     * @param ch\n     * @param outputPtr Position within output buffer to append multi-byte in\n     * \n     * @return New output position after appending\n     * \n     * @throws IOException\n     */\n    private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException\n    {\n        byte[] bbuf = _outputBuffer;\n        if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape\n            // 23-Nov-2015, tatu: As per [core#223], may or may not want escapes;\n            //   it would be added here... but as things are, we do not have proper\n            //   access yet...\n//            if (Feature.ESCAPE_UTF8_SURROGATES.enabledIn(_features)) {\n                bbuf[outputPtr++] = BYTE_BACKSLASH;\n                bbuf[outputPtr++] = BYTE_u;\n                \n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n//            } else { ... }\n        } else {\n            bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n            bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n            bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n        }\n        return outputPtr;\n    }\n\n    private final void _writeNull() throws IOException\n    {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\n        _outputTail += 4;\n    }\n        \n    /**\n     * Method called to write a generic Unicode escape for given character.\n     * \n     * @param charToEscape Character to escape using escape sequence (\\\\uXXXX)\n     */\n    private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException\n    {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[outputPtr++] = BYTE_BACKSLASH;\n        bbuf[outputPtr++] = BYTE_u;\n        if (charToEscape > 0xFF) {\n            int hi = (charToEscape >> 8) & 0xFF;\n            bbuf[outputPtr++] = HEX_CHARS[hi >> 4];\n            bbuf[outputPtr++] = HEX_CHARS[hi & 0xF];\n            charToEscape &= 0xFF;\n        } else {\n            bbuf[outputPtr++] = BYTE_0;\n            bbuf[outputPtr++] = BYTE_0;\n        }\n        // We know it's a control char, so only the last 2 chars are non-0\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4];\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF];\n        return outputPtr;\n    }\n\n    protected final void _flushBuffer() throws IOException\n    {\n        int len = _outputTail;\n        if (len > 0) {\n            _outputTail = 0;\n            _outputStream.write(_outputBuffer, 0, len);\n        }\n    }\n}"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_17_fixed/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "precode": "            _writeRawSegment(buf, 0, len);",
        "line": 530,
        "aftercode": "_writeRawSegment(buf, offset);"
    }
]