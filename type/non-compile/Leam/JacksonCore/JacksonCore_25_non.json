[
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {",
        "line": 2571,
        "aftercode": "if((((b[ptr] == \"null\") && (b[++ptr] == \"null\")) && (b[++ptr] == \"null\"))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (_inputPtr >= _inputEnd && !_loadMore()) {",
        "line": 1537,
        "aftercode": ""
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (_inputPtr >= _inputEnd) {",
        "line": 2701,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2573,
        "aftercode": "if(((c < \"null\") || (c == \"null\"))){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {",
        "line": 2572,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\nif((((b[ptr] == \"null\") && (b[++ptr] == \"null\")) && (b[++ptr] == \"null\"))){\n                char c = b[++ptr];\n\nif(((c < \"null\") || (c == \"null\"))){\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (expLen == 0) {",
        "line": 1544,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (outPtr >= outBuf.length) {",
        "line": 1532,
        "aftercode": ""
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (_inputPtr >= _inputEnd) {",
        "line": 2669,
        "aftercode": "\n\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (bits < 0) {",
        "line": 2695,
        "aftercode": ""
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 779,
        "aftercode": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {",
        "line": 2571,
        "aftercode": "if(((b[ptr] == \"null\") && (b[++ptr] == \"null\"))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (_inputPtr >= _inputEnd && !_loadMore()) {",
        "line": 1537,
        "aftercode": ""
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    int ptr = _inputPtr;",
        "line": 858,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (outPtr >= outBuf.length) {",
        "line": 1519,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (_inputPtr >= _inputEnd && !_loadMore()) {",
        "line": 1537,
        "aftercode": ""
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (i == INT_QUOTE) {",
        "line": 847,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            while (c <= INT_9 && c >= INT_0) {",
        "line": 1530,
        "aftercode": ""
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                ch = _inputBuffer[_inputPtr++];",
        "line": 2674,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _matchToken(\"false\", 1);",
        "line": 2580,
        "aftercode": "_matchToken(\"null\");"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            } else if (!Character.isJavaIdentifierPart(c)) {",
        "line": 1967,
        "aftercode": "if(Character.isJavaIdentifierPart(c)){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {",
        "line": 2571,
        "aftercode": "if((b[ptr] == \"null\")){"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 1153,
        "aftercode": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow);"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        int expLen = 0;",
        "line": 1507,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (outPtr >= outBuf.length) {",
        "line": 1509,
        "aftercode": ""
    },
    {
        "id": 9,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (!_parsingContext.inObject()) {",
        "line": 910,
        "aftercode": ""
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    int offset = 0;",
        "line": 857,
        "aftercode": ""
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 779,
        "aftercode": "_parsingContext = createChildArrayContext(_tokenInputRow, _tokenInputCol);"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (_inputPtr >= _inputEnd && !_loadMore()) {",
        "line": 1537,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (_inputPtr >= _inputEnd && !_loadMore()) {",
        "line": 1537,
        "aftercode": ""
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        return _isNextTokenNameMaybe(i, sstr.getValue());",
        "line": 874,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _matchToken(\"false\", 1);",
        "line": 2580,
        "aftercode": "_matchToken(0);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2573,
        "aftercode": "if((c < \"null\")){"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (bits < 0) {",
        "line": 2695,
        "aftercode": ""
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (_inputPtr >= _inputEnd) {",
        "line": 2669,
        "aftercode": "\n\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 779,
        "aftercode": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputCol);"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    while (true) {",
        "line": 859,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            outBuf[outPtr++] = c;",
        "line": 1461,
        "aftercode": ""
    },
    {
        "id": 9,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _updateNameLocation();",
        "line": 691,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            while (c <= INT_9 && c >= INT_0) {",
        "line": 1530,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (outPtr >= outBuf.length) {",
        "line": 1519,
        "aftercode": ""
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                        if (nameChars[offset] != _inputBuffer[ptr]) {",
        "line": 865,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {",
        "line": 2572,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\nif(((b[ptr] == \"null\") && (b[++ptr] == \"null\"))){\n                char c = b[++ptr];\n\nif(((c < \"null\") || (c == \"null\"))){\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _matchToken(\"false\", 1);",
        "line": 2580,
        "aftercode": "_matchToken(false);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _matchToken(\"false\", 1);",
        "line": 2580,
        "aftercode": "_matchToken();"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if ((ptr + 4) < _inputEnd) {",
        "line": 2569,
        "aftercode": "if((ptr + 4)){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2573,
        "aftercode": "if(((c < \"null\") && (c == \"null\"))){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            final char[] b = _inputBuffer;",
        "line": 2570,
        "aftercode": "final char[] b = ((b[ptr] == \"null\") && (b[++ptr] == \"null\"));"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        int expLen = 0;",
        "line": 1507,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (outPtr >= outBuf.length) {",
        "line": 1532,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {",
        "line": 2572,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\nif((b[ptr] == \"null\")){\n                char c = b[++ptr];\n\nif(((c < \"null\") || (c == \"null\"))){\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 1153,
        "aftercode": "_parsingContext = _tokenInputRow;"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);",
        "line": 1310,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _matchToken(\"false\", 1);",
        "line": 2580,
        "aftercode": "_matchToken(true);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {",
        "line": 2572,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\nif((((b[ptr] == \"null\") && (b[++ptr] == \"null\")) && (b[++ptr] == \"null\"))){\n                char c = b[++ptr];\n\nif((c < \"null\")){\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2572,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\nif(((c < \"null\") || (c == \"null\"))){\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n\n_matchToken(\"null\");\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        int expLen = 0;",
        "line": 1507,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2572,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\nif(((c < \"null\") || (c == \"null\"))){\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n\n_matchToken(0);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 1153,
        "aftercode": "_parsingContext = createChildArrayContext(_tokenInputRow, _tokenInputCol);"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 771,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow);\n        } else if (t == JsonToken.START_OBJECT) {\n\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                break int_loop;",
        "line": 1407,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            } else if (!Character.isJavaIdentifierPart(c)) {",
        "line": 1967,
        "aftercode": "if(!Character.isJavaIdentifierPart(c)){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (_inputPtr >= _inputEnd && !_loadMore()) {",
        "line": 1462,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2573,
        "aftercode": "if((c == \"null\")){"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException",
        "line": 1948,
        "aftercode": ""
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (t == JsonToken.START_ARRAY) {",
        "line": 1152,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _matchToken(\"false\", 1);",
        "line": 2580,
        "aftercode": "_matchToken(\"null\", \"null\");"
    },
    {
        "id": 9,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _updateNameLocation();",
        "line": 691,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2572,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\nif(((c < \"null\") || (c == \"null\"))){\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n\n_matchToken(1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    int offset = 0;",
        "line": 857,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (outPtr >= outBuf.length) {",
        "line": 1532,
        "aftercode": ""
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 779,
        "aftercode": "_parsingContext = _parsingContext.createChildArrayContext(t);"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            int decodedData = bits;",
        "line": 2686,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.setCurrentLength(outPtr);",
        "line": 1981,
        "aftercode": "continue;"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (outPtr >= outBuf.length) {",
        "line": 1532,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _matchToken(\"false\", 1);",
        "line": 2580,
        "aftercode": "_matchToken(2);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {",
        "line": 2571,
        "aftercode": "if(((((b[ptr] == \"null\") && (b[++ptr] == \"null\")) && (b[++ptr] == \"null\")) && (b[++ptr] == \"null\"))){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _matchToken(\"false\", 1);",
        "line": 2580,
        "aftercode": "_matchToken(1, 1);"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            } else if (!Character.isJavaIdentifierPart(c)) {",
        "line": 1967,
        "aftercode": "if(isJavaIdentifierPart(c)){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {",
        "line": 2572,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\nif((((b[ptr] == \"null\") && (b[++ptr] == \"null\")) && (b[++ptr] == \"null\"))){\n                char c = b[++ptr];\n\nif(((c < \"null\") && (c == \"null\"))){\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);",
        "line": 781,
        "aftercode": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _matchToken(\"false\", 1);",
        "line": 2580,
        "aftercode": "_matchToken(0, 1);"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);",
        "line": 781,
        "aftercode": "_parsingContext = (JsonToken)_parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2573,
        "aftercode": "if((((c < \"null\") && (c == \"null\")) || (c == \"null\"))){"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    int ptr = _inputPtr;",
        "line": 858,
        "aftercode": ""
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 771,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow);\n        } else if (t == JsonToken.START_OBJECT) {\n\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);",
        "line": 781,
        "aftercode": "_parsingContext = _parsingContext.createChildObjectContext();"
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (bits < 0) {",
        "line": 2695,
        "aftercode": ""
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    int ptr = _inputPtr;",
        "line": 858,
        "aftercode": ""
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 771,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n_parsingContext = createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _matchToken(\"false\", 1);",
        "line": 2580,
        "aftercode": "_matchToken(null);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if ((ptr + 4) < _inputEnd) {",
        "line": 2569,
        "aftercode": "if((((b[ptr] == \"null\") && (b[++ptr] == \"null\")) && (b[++ptr] == \"null\"))){"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            } else if (!Character.isJavaIdentifierPart(c)) {",
        "line": 1967,
        "aftercode": "if(Character.isJavaIdentifierPart()){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _matchToken(\"false\", 1);",
        "line": 2580,
        "aftercode": "_matchToken(1, 0);"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    int ptr = _inputPtr;",
        "line": 858,
        "aftercode": ""
    },
    {
        "id": 10,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                ch = _inputBuffer[_inputPtr++];",
        "line": 2674,
        "aftercode": ""
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (_parsingContext.inRoot()) {",
        "line": 1418,
        "aftercode": ""
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (_inputBuffer[end] == '\"') {",
        "line": 856,
        "aftercode": ""
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 1153,
        "aftercode": "_parsingContext = (String)_parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2573,
        "aftercode": "if((((b[ptr] == \"null\") && (b[++ptr] == \"null\")) || (c == \"null\"))){"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _verifyRootSpace(ch);",
        "line": 1419,
        "aftercode": "return;"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {",
        "line": 2571,
        "aftercode": "if((b[++ptr] == \"null\")){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2572,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\nif(((c < \"null\") || (c == \"null\"))){\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n\n_matchToken(false);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            final char[] b = _inputBuffer;",
        "line": 2572,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\nchar[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n\nif(((c < \"null\") || (c == \"null\"))){\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                    while (true) {",
        "line": 859,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.setCurrentLength(outPtr);",
        "line": 1981,
        "aftercode": "return;"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2573,
        "aftercode": "if((b[++ptr] == \"null\")){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2572,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\nif(((c < \"null\") || (c == \"null\"))){\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n\n_matchToken();\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 12,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            return _parseFloat(ch, startPtr, ptr, true, intLen);",
        "line": 1414,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));",
        "line": 1950,
        "aftercode": "_textBuffer.resetWithShared(startPtr, _inputBuffer);"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));",
        "line": 1950,
        "aftercode": "_textBuffer.resetWithShared(_inputBuffer, startPtr);"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 1153,
        "aftercode": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputCol);"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);",
        "line": 781,
        "aftercode": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputCol);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        int ptr = _inputPtr;",
        "line": 2568,
        "aftercode": "int ptr = ;"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {",
        "line": 2571,
        "aftercode": "if((((b[ptr] == \"null\") && (b[++ptr] == \"null\")) && (b[++ptr] == \"null\"))){"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        } else if (t == JsonToken.START_OBJECT) {",
        "line": 780,
        "aftercode": "if((t == JsonToken.START_ARRAY)){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        int ptr = _inputPtr;",
        "line": 2568,
        "aftercode": "final int ptr = 0;"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                        if (ptr == end) { // yes, match!",
        "line": 860,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _matchToken(\"false\", 1);",
        "line": 2580,
        "aftercode": "_matchToken(0, 0);"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 771,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n_parsingContext = createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n\n_parsingContext = createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2572,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\nif(((c < \"null\") || (c == \"null\"))){\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n\n_matchToken(true);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            final char[] b = _inputBuffer;",
        "line": 2570,
        "aftercode": "final char[] b = (((b[ptr] == \"null\") && (b[++ptr] == \"null\")) && (b[++ptr] == \"null\"));"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 779,
        "aftercode": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, null);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2573,
        "aftercode": "if((((c < \"null\") && (b[++ptr] == \"null\")) || (c == \"null\"))){"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;",
        "line": 1160,
        "aftercode": "            }"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _nameCopied = false; // need to invalidate if it was copied",
        "line": 771,
        "aftercode": "_nameCopied = null;"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 771,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars",
        "line": 2572,
        "aftercode": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\nif(((c < \"null\") || (c == \"null\"))){\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n\n_matchToken(\"null\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));",
        "line": 1950,
        "aftercode": "_textBuffer.resetWithShared(startPtr, (_inputPtr - startPtr));"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'",
        "line": 1140,
        "aftercode": "JsonToken t = _nextToken;"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);",
        "line": 781,
        "aftercode": "_parsingContext = _tokenInputRow;"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 1153,
        "aftercode": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow);"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 779,
        "aftercode": "_parsingContext = (JsonToken)_parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));",
        "line": 1950,
        "aftercode": "_textBuffer.resetWithShared(_inputBuffer, (_inputPtr - startPtr));"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            } else if (t == JsonToken.START_OBJECT) {",
        "line": 1154,
        "aftercode": "if(_tokenIncomplete){"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (_tokenIncomplete) {",
        "line": 1146,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            return _symbols.findSymbol(buf, start, len, hash);",
        "line": 1988,
        "aftercode": "_symbols.findSymbol(buf, start, len, hash);"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 1153,
        "aftercode": "_parsingContext = _parsingContext.createChildArrayContext(t);"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                outBuf = _textBuffer.finishCurrentSegment();",
        "line": 1977,
        "aftercode": "continue;"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));",
        "line": 1950,
        "aftercode": "_textBuffer.resetWithShared(_inputBuffer, _inputBuffer);"
    },
    {
        "id": 7,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);",
        "line": 779,
        "aftercode": "_parsingContext = _parsingContext.createChildArrayContext(null);"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                outPtr = 0;",
        "line": 1978,
        "aftercode": "return;"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));",
        "line": 1950,
        "aftercode": "_textBuffer.resetWithShared(startPtr);"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            } else if (!Character.isJavaIdentifierPart(c)) {",
        "line": 1967,
        "aftercode": "if(!Character.isJavaIdentifierPart()){"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            } else if (!Character.isJavaIdentifierPart(c)) {",
        "line": 1967,
        "aftercode": "if(!isJavaIdentifierPart(c)){"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));",
        "line": 1950,
        "aftercode": "_textBuffer.resetWithShared(startPtr, _inputBuffer, _inputBuffer);"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "                if (codes[i] != 0) {",
        "line": 1964,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_25_fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "precode": "            outBuf[outPtr++] = c;",
        "line": 1973,
        "aftercode": "continue;"
    }
]