[
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "            if (c > '9' || c < '0') {",
        "line": 194,
        "aftercode": "if((c > \"null\")){"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "            if (c > '9' || c < '0') {",
        "line": 194,
        "aftercode": "if((c < \"null\")){"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "        if (len == 0 || len > 10) {",
        "line": 189,
        "aftercode": "if((i < len)){"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "        if (len == 0 || len > 10) {",
        "line": 189,
        "aftercode": "final int len = str.length();"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "    private final static int _parseIndex(String str) {",
        "line": 185,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "        if (len == 10) {",
        "line": 198,
        "aftercode": "long l = NumberInput.parseLong(str);"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "        if (len == 0 || len > 10) {",
        "line": 190,
        "aftercode": "package com.fasterxml.jackson.core;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Marker instance used to represent segment that matches current\n     * node or position.\n     */\n    protected final static JsonPointer EMPTY = new JsonPointer();\n    \n    /**\n     * Reference to rest of the pointer beyond currently matching\n     * segment (if any); null if this pointer refers to a matching\n     * segment.\n     */\n    protected final JsonPointer _nextSegment;\n    \n    /**\n     * We will retain representation of the pointer, as a String,\n     * so that {@link #toString} should be as efficient as possible.\n     */\n    protected final String _asString;\n    \n    protected final String _matchingPropertyName;\n\n    protected final int _matchingElementIndex;\n\n    /*\n    /**********************************************************\n    /* Cosntruction\n    /**********************************************************\n     */\n    \n    /**\n     * Constructor used for creating \"empty\" instance, used to represent\n     * state that matches current node.\n     */\n    protected JsonPointer() {\n        _nextSegment = null;\n        _matchingPropertyName = \"\";\n        _matchingElementIndex = -1;\n        _asString = \"\";\n    }\n\n    /**\n     * Constructor used for creating non-empty Segments\n     */\n    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        // Ok; may always be a property\n        _matchingPropertyName = segment;\n        _matchingElementIndex = _parseIndex(segment);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException\n    {\n        // First quick checks for well-known 'empty' pointer\n        if ((input == null) || input.length() == 0) {\n            return EMPTY;\n        }\n        // And then quick validity check:\n        if (input.charAt(0) != '/') {\n            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n        }\n        return _parseTail(input);\n    }\n\n    /**\n     * Alias for {@link #compile}; added to make instances automatically\n     * deserializable by Jackson databind.\n     */\n    public static JsonPointer valueOf(String input) { return compile(input); }\n\n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    public JsonPointer matchProperty(String name) {\n        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    public JsonPointer matchElement (int index) {\n        if ((index != _matchingElementIndex) || (index < 0)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a \"sub-pointer\", instance where current segment\n     * has been removed and pointer includes rest of segments;\n     */\n    public JsonPointer tail() {\n        return _nextSegment;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard method overrides\n    /**********************************************************\n     */\n\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\nif((len == 0)){\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n\nif((c > \"null\")){\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n            if (c == '~' && i < end) { // possibly, quote\n                return _parseQuotedTail(input, i);\n            }\n            // otherwise, loop on\n        }\n        // end of the road, no escapes\n        return new JsonPointer(input, input.substring(1), EMPTY);\n    }\n\n    /**\n     * Method called to parse tail of pointer path, when a potentially\n     * escaped character has been seen.\n     * \n     * @param input Full input for the tail being parsed\n     * @param i Offset to character after tilde\n     */\n    protected static JsonPointer _parseQuotedTail(String input, int i) {\n        final int end = input.length();\n        StringBuilder sb = new StringBuilder(Math.max(16, end));\n        if (i > 2) {\n            sb.append(input, 1, i-1);\n        }\n        _appendEscape(sb, input.charAt(i++));\n        while (i < end) {\n            char c = input.charAt(i);\n            if (c == '/') { // end is nigh!\n                return new JsonPointer(input, sb.toString(),\n                        _parseTail(input.substring(i))); // need to push back slash\n            }\n            ++i;\n            if (c == '~' && i < end) {\n                _appendEscape(sb, input.charAt(i++));\n                continue;\n            }\n            sb.append(c);\n        }\n        // end of the road, last segment\n        return new JsonPointer(input, sb.toString(), EMPTY);\n    }\n    \n    private static void _appendEscape(StringBuilder sb, char c) {\n        if (c == '0') {\n            c = '~';\n        } else if (c == '1') {\n            c = '/';\n        } else {\n            sb.append('~');\n        }\n        sb.append(c);\n    }\n}"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "            if (l > Integer.MAX_VALUE) {",
        "line": 200,
        "aftercode": "long l = NumberInput.parseLong(str);"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "        return NumberInput.parseInt(str);",
        "line": 204,
        "aftercode": "return;"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "        if (len == 0 || len > 10) {",
        "line": 189,
        "aftercode": "if((l > Integer.MAX_VALUE)){"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "    private final static int _parseIndex(String str) {",
        "line": 185,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "        return NumberInput.parseInt(str);",
        "line": 204,
        "aftercode": "NumberInput.parseInt(str);"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "        if (len == 0 || len > 10) {",
        "line": 190,
        "aftercode": "package com.fasterxml.jackson.core;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Marker instance used to represent segment that matches current\n     * node or position.\n     */\n    protected final static JsonPointer EMPTY = new JsonPointer();\n    \n    /**\n     * Reference to rest of the pointer beyond currently matching\n     * segment (if any); null if this pointer refers to a matching\n     * segment.\n     */\n    protected final JsonPointer _nextSegment;\n    \n    /**\n     * We will retain representation of the pointer, as a String,\n     * so that {@link #toString} should be as efficient as possible.\n     */\n    protected final String _asString;\n    \n    protected final String _matchingPropertyName;\n\n    protected final int _matchingElementIndex;\n\n    /*\n    /**********************************************************\n    /* Cosntruction\n    /**********************************************************\n     */\n    \n    /**\n     * Constructor used for creating \"empty\" instance, used to represent\n     * state that matches current node.\n     */\n    protected JsonPointer() {\n        _nextSegment = null;\n        _matchingPropertyName = \"\";\n        _matchingElementIndex = -1;\n        _asString = \"\";\n    }\n\n    /**\n     * Constructor used for creating non-empty Segments\n     */\n    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        // Ok; may always be a property\n        _matchingPropertyName = segment;\n        _matchingElementIndex = _parseIndex(segment);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException\n    {\n        // First quick checks for well-known 'empty' pointer\n        if ((input == null) || input.length() == 0) {\n            return EMPTY;\n        }\n        // And then quick validity check:\n        if (input.charAt(0) != '/') {\n            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n        }\n        return _parseTail(input);\n    }\n\n    /**\n     * Alias for {@link #compile}; added to make instances automatically\n     * deserializable by Jackson databind.\n     */\n    public static JsonPointer valueOf(String input) { return compile(input); }\n\n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    public JsonPointer matchProperty(String name) {\n        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    public JsonPointer matchElement (int index) {\n        if ((index != _matchingElementIndex) || (index < 0)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a \"sub-pointer\", instance where current segment\n     * has been removed and pointer includes rest of segments;\n     */\n    public JsonPointer tail() {\n        return _nextSegment;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard method overrides\n    /**********************************************************\n     */\n\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\nif((len == 0)){\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n\nif((c < \"null\")){\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n            if (c == '~' && i < end) { // possibly, quote\n                return _parseQuotedTail(input, i);\n            }\n            // otherwise, loop on\n        }\n        // end of the road, no escapes\n        return new JsonPointer(input, input.substring(1), EMPTY);\n    }\n\n    /**\n     * Method called to parse tail of pointer path, when a potentially\n     * escaped character has been seen.\n     * \n     * @param input Full input for the tail being parsed\n     * @param i Offset to character after tilde\n     */\n    protected static JsonPointer _parseQuotedTail(String input, int i) {\n        final int end = input.length();\n        StringBuilder sb = new StringBuilder(Math.max(16, end));\n        if (i > 2) {\n            sb.append(input, 1, i-1);\n        }\n        _appendEscape(sb, input.charAt(i++));\n        while (i < end) {\n            char c = input.charAt(i);\n            if (c == '/') { // end is nigh!\n                return new JsonPointer(input, sb.toString(),\n                        _parseTail(input.substring(i))); // need to push back slash\n            }\n            ++i;\n            if (c == '~' && i < end) {\n                _appendEscape(sb, input.charAt(i++));\n                continue;\n            }\n            sb.append(c);\n        }\n        // end of the road, last segment\n        return new JsonPointer(input, sb.toString(), EMPTY);\n    }\n    \n    private static void _appendEscape(StringBuilder sb, char c) {\n        if (c == '0') {\n            c = '~';\n        } else if (c == '1') {\n            c = '/';\n        } else {\n            sb.append('~');\n        }\n        sb.append(c);\n    }\n}"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "            if (c > '9' || c < '0') {",
        "line": 194,
        "aftercode": "if((l > Integer.MAX_VALUE)){"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "        if (len == 0 || len > 10) {",
        "line": 190,
        "aftercode": "package com.fasterxml.jackson.core;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Marker instance used to represent segment that matches current\n     * node or position.\n     */\n    protected final static JsonPointer EMPTY = new JsonPointer();\n    \n    /**\n     * Reference to rest of the pointer beyond currently matching\n     * segment (if any); null if this pointer refers to a matching\n     * segment.\n     */\n    protected final JsonPointer _nextSegment;\n    \n    /**\n     * We will retain representation of the pointer, as a String,\n     * so that {@link #toString} should be as efficient as possible.\n     */\n    protected final String _asString;\n    \n    protected final String _matchingPropertyName;\n\n    protected final int _matchingElementIndex;\n\n    /*\n    /**********************************************************\n    /* Cosntruction\n    /**********************************************************\n     */\n    \n    /**\n     * Constructor used for creating \"empty\" instance, used to represent\n     * state that matches current node.\n     */\n    protected JsonPointer() {\n        _nextSegment = null;\n        _matchingPropertyName = \"\";\n        _matchingElementIndex = -1;\n        _asString = \"\";\n    }\n\n    /**\n     * Constructor used for creating non-empty Segments\n     */\n    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        // Ok; may always be a property\n        _matchingPropertyName = segment;\n        _matchingElementIndex = _parseIndex(segment);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException\n    {\n        // First quick checks for well-known 'empty' pointer\n        if ((input == null) || input.length() == 0) {\n            return EMPTY;\n        }\n        // And then quick validity check:\n        if (input.charAt(0) != '/') {\n            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n        }\n        return _parseTail(input);\n    }\n\n    /**\n     * Alias for {@link #compile}; added to make instances automatically\n     * deserializable by Jackson databind.\n     */\n    public static JsonPointer valueOf(String input) { return compile(input); }\n\n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    public JsonPointer matchProperty(String name) {\n        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    public JsonPointer matchElement (int index) {\n        if ((index != _matchingElementIndex) || (index < 0)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a \"sub-pointer\", instance where current segment\n     * has been removed and pointer includes rest of segments;\n     */\n    public JsonPointer tail() {\n        return _nextSegment;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard method overrides\n    /**********************************************************\n     */\n\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\nif((len > 10)){\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n\nif((c > \"null\")){\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n            if (c == '~' && i < end) { // possibly, quote\n                return _parseQuotedTail(input, i);\n            }\n            // otherwise, loop on\n        }\n        // end of the road, no escapes\n        return new JsonPointer(input, input.substring(1), EMPTY);\n    }\n\n    /**\n     * Method called to parse tail of pointer path, when a potentially\n     * escaped character has been seen.\n     * \n     * @param input Full input for the tail being parsed\n     * @param i Offset to character after tilde\n     */\n    protected static JsonPointer _parseQuotedTail(String input, int i) {\n        final int end = input.length();\n        StringBuilder sb = new StringBuilder(Math.max(16, end));\n        if (i > 2) {\n            sb.append(input, 1, i-1);\n        }\n        _appendEscape(sb, input.charAt(i++));\n        while (i < end) {\n            char c = input.charAt(i);\n            if (c == '/') { // end is nigh!\n                return new JsonPointer(input, sb.toString(),\n                        _parseTail(input.substring(i))); // need to push back slash\n            }\n            ++i;\n            if (c == '~' && i < end) {\n                _appendEscape(sb, input.charAt(i++));\n                continue;\n            }\n            sb.append(c);\n        }\n        // end of the road, last segment\n        return new JsonPointer(input, sb.toString(), EMPTY);\n    }\n    \n    private static void _appendEscape(StringBuilder sb, char c) {\n        if (c == '0') {\n            c = '~';\n        } else if (c == '1') {\n            c = '/';\n        } else {\n            sb.append('~');\n        }\n        sb.append(c);\n    }\n}"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "        if (len == 0 || len > 10) {",
        "line": 190,
        "aftercode": "package com.fasterxml.jackson.core;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Marker instance used to represent segment that matches current\n     * node or position.\n     */\n    protected final static JsonPointer EMPTY = new JsonPointer();\n    \n    /**\n     * Reference to rest of the pointer beyond currently matching\n     * segment (if any); null if this pointer refers to a matching\n     * segment.\n     */\n    protected final JsonPointer _nextSegment;\n    \n    /**\n     * We will retain representation of the pointer, as a String,\n     * so that {@link #toString} should be as efficient as possible.\n     */\n    protected final String _asString;\n    \n    protected final String _matchingPropertyName;\n\n    protected final int _matchingElementIndex;\n\n    /*\n    /**********************************************************\n    /* Cosntruction\n    /**********************************************************\n     */\n    \n    /**\n     * Constructor used for creating \"empty\" instance, used to represent\n     * state that matches current node.\n     */\n    protected JsonPointer() {\n        _nextSegment = null;\n        _matchingPropertyName = \"\";\n        _matchingElementIndex = -1;\n        _asString = \"\";\n    }\n\n    /**\n     * Constructor used for creating non-empty Segments\n     */\n    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        // Ok; may always be a property\n        _matchingPropertyName = segment;\n        _matchingElementIndex = _parseIndex(segment);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException\n    {\n        // First quick checks for well-known 'empty' pointer\n        if ((input == null) || input.length() == 0) {\n            return EMPTY;\n        }\n        // And then quick validity check:\n        if (input.charAt(0) != '/') {\n            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n        }\n        return _parseTail(input);\n    }\n\n    /**\n     * Alias for {@link #compile}; added to make instances automatically\n     * deserializable by Jackson databind.\n     */\n    public static JsonPointer valueOf(String input) { return compile(input); }\n\n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    public JsonPointer matchProperty(String name) {\n        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    public JsonPointer matchElement (int index) {\n        if ((index != _matchingElementIndex) || (index < 0)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a \"sub-pointer\", instance where current segment\n     * has been removed and pointer includes rest of segments;\n     */\n    public JsonPointer tail() {\n        return _nextSegment;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard method overrides\n    /**********************************************************\n     */\n\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\nif((len > 10)){\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n\nif((c < \"null\")){\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n            if (c == '~' && i < end) { // possibly, quote\n                return _parseQuotedTail(input, i);\n            }\n            // otherwise, loop on\n        }\n        // end of the road, no escapes\n        return new JsonPointer(input, input.substring(1), EMPTY);\n    }\n\n    /**\n     * Method called to parse tail of pointer path, when a potentially\n     * escaped character has been seen.\n     * \n     * @param input Full input for the tail being parsed\n     * @param i Offset to character after tilde\n     */\n    protected static JsonPointer _parseQuotedTail(String input, int i) {\n        final int end = input.length();\n        StringBuilder sb = new StringBuilder(Math.max(16, end));\n        if (i > 2) {\n            sb.append(input, 1, i-1);\n        }\n        _appendEscape(sb, input.charAt(i++));\n        while (i < end) {\n            char c = input.charAt(i);\n            if (c == '/') { // end is nigh!\n                return new JsonPointer(input, sb.toString(),\n                        _parseTail(input.substring(i))); // need to push back slash\n            }\n            ++i;\n            if (c == '~' && i < end) {\n                _appendEscape(sb, input.charAt(i++));\n                continue;\n            }\n            sb.append(c);\n        }\n        // end of the road, last segment\n        return new JsonPointer(input, sb.toString(), EMPTY);\n    }\n    \n    private static void _appendEscape(StringBuilder sb, char c) {\n        if (c == '0') {\n            c = '~';\n        } else if (c == '1') {\n            c = '/';\n        } else {\n            sb.append('~');\n        }\n        sb.append(c);\n    }\n}"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "        if (len == 0 || len > 10) {",
        "line": 189,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/JacksonCore/JacksonCore_5_fixed/src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
        "precode": "        if (len == 10) {",
        "line": 198,
        "aftercode": "if((l > Integer.MAX_VALUE)){"
    }
]