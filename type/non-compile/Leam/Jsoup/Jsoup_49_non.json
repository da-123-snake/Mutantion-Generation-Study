[
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": "int index        Validate.noNullElements(children);"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": "Node children        Validate.noNullElements(children);"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.noNullElements(children);",
        "line": 439,
        "aftercode": "Validate.noNullElements();"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "            reindexChildren(index);",
        "line": 445,
        "aftercode": "reindexChildren();"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.noNullElements(children);",
        "line": 439,
        "aftercode": "noNullElements();"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": "int index        Validate.noNullElements(children);"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": "int index        Validate.noNullElements(children);"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": ""
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.noNullElements(children);",
        "line": 439,
        "aftercode": "Validate.noNullElements(0);"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": "int index,Node children        Validate.noNullElements(children);"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.noNullElements(children);",
        "line": 439,
        "aftercode": "noNullElements(children);"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "            childNodes.add(index, in);",
        "line": 444,
        "aftercode": "childNodes.add(index);"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.noNullElements(children);",
        "line": 442,
        "aftercode": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n The base, abstract Node model. Elements, Documents, Comments etc are all Node instances.\n\n @author Jonathan Hedley, jonathan@hedley.net */\npublic abstract class Node implements Cloneable {\n    private static final List<Node> EMPTY_NODES = Collections.emptyList();\n    Node parentNode;\n    List<Node> childNodes;\n    Attributes attributes;\n    String baseUri;\n    int siblingIndex;\n\n    /**\n     Create a new Node.\n     @param baseUri base URI\n     @param attributes attributes (not null, but may be empty)\n     */\n    protected Node(String baseUri, Attributes attributes) {\n        Validate.notNull(baseUri);\n        Validate.notNull(attributes);\n        \n        childNodes = EMPTY_NODES;\n        this.baseUri = baseUri.trim();\n        this.attributes = attributes;\n    }\n\n    protected Node(String baseUri) {\n        this(baseUri, new Attributes());\n    }\n\n    /**\n     * Default constructor. Doesn't setup base uri, children, or attributes; use with caution.\n     */\n    protected Node() {\n        childNodes = EMPTY_NODES;\n        attributes = null;\n    }\n\n    /**\n     Get the node name of this node. Use for debugging purposes and not logic switching (for that, use instanceof).\n     @return node name\n     */\n    public abstract String nodeName();\n\n    /**\n     * Get an attribute's value by its key.\n     * <p>\n     * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,\n     * which is a shortcut to the {@link #absUrl} method.\n     * </p>\n     * E.g.:\n     * <blockquote><code>String url = a.attr(\"abs:href\");</code></blockquote>\n     * \n     * @param attributeKey The attribute key.\n     * @return The attribute, or empty string if not present (to avoid nulls).\n     * @see #attributes()\n     * @see #hasAttr(String)\n     * @see #absUrl(String)\n     */\n    public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributes.hasKey(attributeKey))\n            return attributes.get(attributeKey);\n        else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }\n\n    /**\n     * Get all of the element's attributes.\n     * @return attributes (which implements iterable, in same order as presented in original HTML).\n     */\n    public Attributes attributes() {\n        return attributes;\n    }\n\n    /**\n     * Set an attribute (key=value). If the attribute already exists, it is replaced.\n     * @param attributeKey The attribute key.\n     * @param attributeValue The attribute value.\n     * @return this (for chaining)\n     */\n    public Node attr(String attributeKey, String attributeValue) {\n        attributes.put(attributeKey, attributeValue);\n        return this;\n    }\n\n    /**\n     * Test if this element has an attribute.\n     * @param attributeKey The attribute key to check.\n     * @return true if the attribute exists, false if not.\n     */\n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributeKey.startsWith(\"abs:\")) {\n            String key = attributeKey.substring(\"abs:\".length());\n            if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n                return true;\n        }\n        return attributes.hasKey(attributeKey);\n    }\n\n    /**\n     * Remove an attribute from this element.\n     * @param attributeKey The attribute to remove.\n     * @return this (for chaining)\n     */\n    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        attributes.remove(attributeKey);\n        return this;\n    }\n\n    /**\n     Get the base URI of this node.\n     @return base URI\n     */\n    public String baseUri() {\n        return baseUri;\n    }\n\n    /**\n     Update the base URI of this node and all of its descendants.\n     @param baseUri base URI to set\n     */\n    public void setBaseUri(final String baseUri) {\n        Validate.notNull(baseUri);\n\n        traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                node.baseUri = baseUri;\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        });\n    }\n\n    /**\n     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href&gt;</code> or\n     * <code>&lt;img src&gt;</code>).\n     * <p>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * </p>\n     * <p>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n     * absolute using that.\n     * </p>\n     * <p>\n     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n     * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n     * </p>\n     * \n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     */\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        } else {\n            return StringUtil.resolve(baseUri, attr(attributeKey));\n        }\n    }\n\n    /**\n     Get a child node by its 0-based index.\n     @param index index of child node\n     @return the child node at this index. Throws a {@code IndexOutOfBoundsException} if the index is out of bounds.\n     */\n    public Node childNode(int index) {\n        return childNodes.get(index);\n    }\n\n    /**\n     Get this node's children. Presented as an unmodifiable list: new children can not be added, but the child nodes\n     themselves can be manipulated.\n     @return list of children. If no children, returns an empty list.\n     */\n    public List<Node> childNodes() {\n        return Collections.unmodifiableList(childNodes);\n    }\n\n    /**\n     * Returns a deep copy of this node's children. Changes made to these nodes will not be reflected in the original\n     * nodes\n     * @return a deep copy of this node's children\n     */\n    public List<Node> childNodesCopy() {\n        List<Node> children = new ArrayList<Node>(childNodes.size());\n        for (Node node : childNodes) {\n            children.add(node.clone());\n        }\n        return children;\n    }\n\n    /**\n     * Get the number of child nodes that this node holds.\n     * @return the number of child nodes that this node holds.\n     */\n    public final int childNodeSize() {\n        return childNodes.size();\n    }\n    \n    protected Node[] childNodesAsArray() {\n        return childNodes.toArray(new Node[childNodeSize()]);\n    }\n\n    /**\n     Gets this node's parent node.\n     @return parent node; or null if no parent.\n     */\n    public Node parent() {\n        return parentNode;\n    }\n\n    /**\n     Gets this node's parent node. Node overridable by extending classes, so useful if you really just need the Node type.\n     @return parent node; or null if no parent.\n     */\n    public final Node parentNode() {\n        return parentNode;\n    }\n    \n    /**\n     * Gets the Document associated with this Node. \n     * @return the Document associated with this Node, or null if there is no such Document.\n     */\n    public Document ownerDocument() {\n        if (this instanceof Document)\n            return (Document) this;\n        else if (parentNode == null)\n            return null;\n        else\n            return parentNode.ownerDocument();\n    }\n    \n    /**\n     * Remove (delete) this node from the DOM tree. If this node has children, they are also removed.\n     */\n    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }\n\n    /**\n     * Insert the specified HTML into the DOM before this node (i.e. as a preceding sibling).\n     * @param html HTML to add before this node\n     * @return this node, for chaining\n     * @see #after(String)\n     */\n    public Node before(String html) {\n        addSiblingHtml(siblingIndex, html);\n        return this;\n    }\n\n    /**\n     * Insert the specified node into the DOM before this node (i.e. as a preceding sibling).\n     * @param node to add before this node\n     * @return this node, for chaining\n     * @see #after(Node)\n     */\n    public Node before(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex, node);\n        return this;\n    }\n\n    /**\n     * Insert the specified HTML into the DOM after this node (i.e. as a following sibling).\n     * @param html HTML to add after this node\n     * @return this node, for chaining\n     * @see #before(String)\n     */\n    public Node after(String html) {\n        addSiblingHtml(siblingIndex + 1, html);\n        return this;\n    }\n\n    /**\n     * Insert the specified node into the DOM after this node (i.e. as a following sibling).\n     * @param node to add after this node\n     * @return this node, for chaining\n     * @see #before(Node)\n     */\n    public Node after(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex + 1, node);\n        return this;\n    }\n\n    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;        \n        List<Node> nodes = Parser.parseFragment(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n    }\n\n    /**\n     Wrap the supplied HTML around this node.\n     @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n     @return this node, for chaining.\n     */\n    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;\n        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());\n        Node wrapNode = wrapChildren.get(0);\n        if (wrapNode == null || !(wrapNode instanceof Element)) // nothing to wrap with; noop\n            return null;\n\n        Element wrap = (Element) wrapNode;\n        Element deepest = getDeepChild(wrap);\n        parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this);\n\n        // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder\n        if (wrapChildren.size() > 0) {\n            for (int i = 0; i < wrapChildren.size(); i++) {\n                Node remainder = wrapChildren.get(i);\n                remainder.parentNode.removeChild(remainder);\n                wrap.appendChild(remainder);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Removes this node from the DOM, and moves its children up into the node's parent. This has the effect of dropping\n     * the node but keeping its children.\n     * <p>\n     * For example, with the input html:\n     * </p>\n     * <p>{@code <div>One <span>Two <b>Three</b></span></div>}</p>\n     * Calling {@code element.unwrap()} on the {@code span} element will result in the html:\n     * <p>{@code <div>One Two <b>Three</b></div>}</p>\n     * and the {@code \"Two \"} {@link TextNode} being returned.\n     * \n     * @return the first child of this node, after the node has been unwrapped. Null if the node had no children.\n     * @see #remove()\n     * @see #wrap(String)\n     */\n    public Node unwrap() {\n        Validate.notNull(parentNode);\n\n        Node firstChild = childNodes.size() > 0 ? childNodes.get(0) : null;\n        parentNode.addChildren(siblingIndex, this.childNodesAsArray());\n        this.remove();\n\n        return firstChild;\n    }\n\n    private Element getDeepChild(Element el) {\n        List<Element> children = el.children();\n        if (children.size() > 0)\n            return getDeepChild(children.get(0));\n        else\n            return el;\n    }\n    \n    /**\n     * Replace this node in the DOM with the supplied node.\n     * @param in the node that will will replace the existing node.\n     */\n    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }\n\n    protected void setParentNode(Node parentNode) {\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }\n\n    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n        \n        final int index = out.siblingIndex;\n        childNodes.set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }\n\n    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        final int index = out.siblingIndex;\n        childNodes.remove(index);\n        reindexChildren(index);\n        out.parentNode = null;\n    }\n\n    protected void addChildren(Node... children) {\n        //most used. short circuit addChildren(int), which hits reindex children and array copy\n        for (Node child: children) {\n            reparentChild(child);\n            ensureChildNodes();\n            childNodes.add(child);\n            child.setSiblingIndex(childNodes.size()-1);\n        }\n    }\n\n    protected void addChildren(int index, Node... children) {\nValidate.noNullElements();\n        ensureChildNodes();\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n\nchildNodes.reindexChildren();\n        }\n    }\n\n    protected void ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new ArrayList<Node>(4);\n        }\n    }\n\n    protected void reparentChild(Node child) {\n        if (child.parentNode != null)\n            child.parentNode.removeChild(child);\n        child.setParentNode(this);\n    }\n    \n    private void reindexChildren(int start) {\n        for (int i = start; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }\n    \n    /**\n     Retrieves this node's sibling nodes. Similar to {@link #childNodes()  node.parent.childNodes()}, but does not\n     include this node (a node is not a sibling of itself).\n     @return node siblings. If the node has no parent, returns an empty list.\n     */\n    public List<Node> siblingNodes() {\n        if (parentNode == null)\n            return Collections.emptyList();\n\n        List<Node> nodes = parentNode.childNodes;\n        List<Node> siblings = new ArrayList<Node>(nodes.size() - 1);\n        for (Node node: nodes)\n            if (node != this)\n                siblings.add(node);\n        return siblings;\n    }\n\n    /**\n     Get this node's next sibling.\n     @return next sibling, or null if this is the last sibling\n     */\n    public Node nextSibling() {\n        if (parentNode == null)\n            return null; // root\n        \n        final List<Node> siblings = parentNode.childNodes;\n        final int index = siblingIndex+1;\n        if (siblings.size() > index)\n            return siblings.get(index);\n        else\n            return null;\n    }\n\n    /**\n     Get this node's previous sibling.\n     @return the previous sibling, or null if this is the first sibling\n     */\n    public Node previousSibling() {\n        if (parentNode == null)\n            return null; // root\n\n        if (siblingIndex > 0)\n            return parentNode.childNodes.get(siblingIndex-1);\n        else\n            return null;\n    }\n\n    /**\n     * Get the list index of this node in its node sibling list. I.e. if this is the first node\n     * sibling, returns 0.\n     * @return position in node sibling list\n     * @see org.jsoup.nodes.Element#elementSiblingIndex()\n     */\n    public int siblingIndex() {\n        return siblingIndex;\n    }\n    \n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }\n\n    /**\n     * Perform a depth-first traversal through this node and its descendants.\n     * @param nodeVisitor the visitor callbacks to perform on each node\n     * @return this node, for chaining\n     */\n    public Node traverse(NodeVisitor nodeVisitor) {\n        Validate.notNull(nodeVisitor);\n        NodeTraversor traversor = new NodeTraversor(nodeVisitor);\n        traversor.traverse(this);\n        return this;\n    }\n\n    /**\n     Get the outer HTML of this node.\n     @return HTML\n     */\n    public String outerHtml() {\n        StringBuilder accum = new StringBuilder(128);\n        outerHtml(accum);\n        return accum.toString();\n    }\n\n    protected void outerHtml(StringBuilder accum) {\n        new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this);\n    }\n\n    // if this node has no document (or parent), retrieve the default output settings\n    Document.OutputSettings getOutputSettings() {\n        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n    }\n\n    /**\n     Get the outer HTML of this node.\n     @param accum accumulator to place HTML into\n     */\n    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    @Override\n    public String toString() {\n        return outerHtml();\n    }\n\n    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n    }\n\n    /**\n     * Check if this node is equal to another node. A node is considered equal if its attributes and content equal the\n     * other node; particularly its position in the tree does not influence its equality.\n     * @param o other object to compare to\n     * @return true if the content of this node is the same as the other\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Node node = (Node) o;\n\n        if (childNodes != null ? !childNodes.equals(node.childNodes) : node.childNodes != null) return false;\n        return !(attributes != null ? !attributes.equals(node.attributes) : node.attributes != null);\n    }\n\n    /**\n     * Calculates a hash code for this node, which includes iterating all its attributes, and recursing into any child\n     * nodes. This means that a node's hashcode is based on it and its child content, and not its parent or place in the\n     * tree. So two nodes with the same content, regardless of their position in the tree, will have the same hashcode.\n     * @return the calculated hashcode\n     * @see Node#equals(Object)\n     */\n    @Override\n    public int hashCode() {\n        int result = childNodes != null ? childNodes.hashCode() : 0;\n        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n        return result;\n    }\n\n    /**\n     * Create a stand-alone, deep copy of this node, and all of its children. The cloned node will have no siblings or\n     * parent node. As a stand-alone object, any changes made to the clone or any of its children will not impact the\n     * original node.\n     * <p>\n     * The cloned node may be adopted into another Document or node structure using {@link Element#appendChild(Node)}.\n     * @return stand-alone cloned node\n     */\n    @Override\n    public Node clone() {\n        Node thisClone = doClone(null); // splits for orphan\n\n        // Queue up nodes that need their children cloned (BFS).\n        LinkedList<Node> nodesToProcess = new LinkedList<Node>();\n        nodesToProcess.add(thisClone);\n\n        while (!nodesToProcess.isEmpty()) {\n            Node currParent = nodesToProcess.remove();\n\n            for (int i = 0; i < currParent.childNodes.size(); i++) {\n                Node childClone = currParent.childNodes.get(i).doClone(currParent);\n                currParent.childNodes.set(i, childClone);\n                nodesToProcess.add(childClone);\n            }\n        }\n\n        return thisClone;\n    }\n\n    /*\n     * Return a clone of the node using the given parent (which can be null).\n     * Not a deep copy of children.\n     */\n    protected Node doClone(Node parent) {\n        Node clone;\n\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; // can be null, to create an orphan split\n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new ArrayList<Node>(childNodes.size());\n\n        for (Node child: childNodes)\n            clone.childNodes.add(child);\n\n        return clone;\n    }\n\n    private static class OuterHtmlVisitor implements NodeVisitor {\n        private StringBuilder accum;\n        private Document.OutputSettings out;\n\n        OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out) {\n            this.accum = accum;\n            this.out = out;\n        }\n\n        public void head(Node node, int depth) {\n            node.outerHtmlHead(accum, depth, out);\n        }\n\n        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) // saves a void hit.\n                node.outerHtmlTail(accum, depth, out);\n        }\n    }\n}"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "            childNodes.add(index, in);",
        "line": 444,
        "aftercode": "reindexChildren();"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void addChildren(int index, Node... children) {",
        "line": 438,
        "aftercode": "Node children        Validate.noNullElements(children);"
    },
    {
        "id": 38,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_49_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "            reparentChild(in);",
        "line": 443,
        "aftercode": "reparentChild();"
    }
]