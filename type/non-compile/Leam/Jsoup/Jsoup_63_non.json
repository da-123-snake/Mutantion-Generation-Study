[
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": "if(StringUtil.in(elName, extraTypes)){"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        return false;",
        "line": 470,
        "aftercode": ""
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": "if(StringUtil.in(elName, extraTypes)){"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Element el = new Element(tag, baseUri, startTag.attributes);",
        "line": 223,
        "aftercode": "Element el = new Element(tag);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": "if((extraTypes != null)){"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    void insertOnStackAfter(Element after, Element in) {",
        "line": 388,
        "aftercode": ""
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {",
        "line": 461,
        "aftercode": ""
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": "if(StringUtil.in(elName, baseTypes)){"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": "if(StringUtil.in(elName, targetNames)){"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 465,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * HTML Tree Builder; creates a DOM from Tokens.\n */\npublic class HtmlTreeBuilder extends TreeBuilder {\n    // tag searches\n    private static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n    private static final String[] TagSearchList = new String[]{\"ol\", \"ul\"};\n    private static final String[] TagSearchButton = new String[]{\"button\"};\n    private static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"};\n    private static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"};\n    private static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"};\n    private static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n            \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n            \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n            \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n            \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n            \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n            \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n            \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"};\n\n    private HtmlTreeBuilderState state; // the current state\n    private HtmlTreeBuilderState originalState; // original / marked state\n\n    private boolean baseUriSetFromDoc;\n    private Element headElement; // the current head element\n    private FormElement formElement; // the current form element\n    private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n    private ArrayList<Element> formattingElements; // active (open) formatting elements\n    private List<String> pendingTableCharacters; // chars in table to be shifted out\n    private Token.EndTag emptyEnd; // reused empty end tag\n\n    private boolean framesetOk; // if ok to go into frameset\n    private boolean fosterInserts; // if next inserts should be fostered\n    private boolean fragmentParsing; // if parsing a fragment of html\n\n    HtmlTreeBuilder() {}\n\n    ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n\n        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); // default\n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node;\n        // characters in script and style go in as datanodes, not text nodes\n        String tagName = currentElement().tagName();\n        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n    }\n\n    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }\n\n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (StringUtil.in(next.nodeName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }\n\n    // todo: tidy up in specific scope methods\n    private String[] specificScopeTarget = {null};\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (StringUtil.in(elName, targetNames))\n                return true;\n            if (StringUtil.in(elName, baseTypes))\n                return false;\nif(StringUtil.in(elName, extraTypes)){\n                return false;\n        }\n\nValidate.fail();\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n        // todo: in svg namespace: forignOjbect, desc, title\n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }\n\n    /**\n     11.2.5.2 Closing elements that have implied end tags<p/>\n     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n     the UA must pop the current node off the stack of open elements.\n\n     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n     process, then the UA must perform the above steps as if that element was not in the above list.\n     */\n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.nodeName();\n        return StringUtil.in(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    // active formatting elements\n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        emptyEnd = new Token.EndTag();",
        "line": 73,
        "aftercode": "emptyEnd = new Token();"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");",
        "line": 228,
        "aftercode": "tokeniser.error();"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Element el = new Element(tag, baseUri, startTag.attributes);",
        "line": 223,
        "aftercode": "Element el = new Element(baseUri, tag);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": "if(StringUtil.in(elName, baseTypes)){"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "                if (!tag.isEmpty())",
        "line": 227,
        "aftercode": "if(tag.isEmpty()){"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 465,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * HTML Tree Builder; creates a DOM from Tokens.\n */\npublic class HtmlTreeBuilder extends TreeBuilder {\n    // tag searches\n    private static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n    private static final String[] TagSearchList = new String[]{\"ol\", \"ul\"};\n    private static final String[] TagSearchButton = new String[]{\"button\"};\n    private static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"};\n    private static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"};\n    private static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"};\n    private static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n            \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n            \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n            \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n            \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n            \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n            \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n            \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"};\n\n    private HtmlTreeBuilderState state; // the current state\n    private HtmlTreeBuilderState originalState; // original / marked state\n\n    private boolean baseUriSetFromDoc;\n    private Element headElement; // the current head element\n    private FormElement formElement; // the current form element\n    private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n    private ArrayList<Element> formattingElements; // active (open) formatting elements\n    private List<String> pendingTableCharacters; // chars in table to be shifted out\n    private Token.EndTag emptyEnd; // reused empty end tag\n\n    private boolean framesetOk; // if ok to go into frameset\n    private boolean fosterInserts; // if next inserts should be fostered\n    private boolean fragmentParsing; // if parsing a fragment of html\n\n    HtmlTreeBuilder() {}\n\n    ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n\n        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); // default\n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node;\n        // characters in script and style go in as datanodes, not text nodes\n        String tagName = currentElement().tagName();\n        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n    }\n\n    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }\n\n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (StringUtil.in(next.nodeName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }\n\n    // todo: tidy up in specific scope methods\n    private String[] specificScopeTarget = {null};\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (StringUtil.in(elName, targetNames))\n                return true;\n            if (StringUtil.in(elName, baseTypes))\n                return false;\nif(StringUtil.in(elName, extraTypes)){\n                return false;\n        }\n\nValidate.fail(\"null\");\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n        // todo: in svg namespace: forignOjbect, desc, title\n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }\n\n    /**\n     11.2.5.2 Closing elements that have implied end tags<p/>\n     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n     the UA must pop the current node off the stack of open elements.\n\n     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n     process, then the UA must perform the above steps as if that element was not in the above list.\n     */\n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.nodeName();\n        return StringUtil.in(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    // active formatting elements\n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    void insertOnStackAfter(Element after, Element in) {",
        "line": 388,
        "aftercode": ""
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": "if(StringUtil.in(elName, targetNames)){"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "                tag.setSelfClosing();",
        "line": 231,
        "aftercode": ""
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": "if((extraTypes != null)){"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");",
        "line": 228,
        "aftercode": "tag.error();"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Element el = new Element(tag, baseUri, startTag.attributes);",
        "line": 223,
        "aftercode": "Element el = new Element(tag, baseUri, baseUri);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");",
        "line": 228,
        "aftercode": ""
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Element el = new Element(tag, baseUri, startTag.attributes);",
        "line": 223,
        "aftercode": "Element el = new Element(tag, startTag.attributes);"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        stack.add(i+1, in);",
        "line": 391,
        "aftercode": "stack.add(i);"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        super.initialiseParse(input, baseUri, errors, settings);",
        "line": 62,
        "aftercode": "super.initialiseParse(input, baseUri);"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {",
        "line": 61,
        "aftercode": ""
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Element el = new Element(tag, baseUri, startTag.attributes);",
        "line": 223,
        "aftercode": "Element el = new Element(el);"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        int i = stack.lastIndexOf(after);",
        "line": 389,
        "aftercode": "int i = stack.lastIndexOf();"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "                if (!tag.isEmpty())",
        "line": 227,
        "aftercode": "if(!tag.isEmpty()){"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {",
        "line": 461,
        "aftercode": ""
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");",
        "line": 228,
        "aftercode": "error();"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (StringUtil.in(elName, baseTypes))",
        "line": 467,
        "aftercode": "if(StringUtil.in(elName, targetNames)){"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        int i = stack.lastIndexOf(after);",
        "line": 389,
        "aftercode": "stack.lastIndexOf(after);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (StringUtil.in(elName, baseTypes))",
        "line": 467,
        "aftercode": "if(((extraTypes != null) && StringUtil.in(elName, extraTypes))){"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Validate.fail(\"Should not be reachable\");",
        "line": 472,
        "aftercode": "Validate.fail();"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": "String elName = el.nodeName();"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Element el = new Element(tag, baseUri, startTag.attributes);",
        "line": 224,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * HTML Tree Builder; creates a DOM from Tokens.\n */\npublic class HtmlTreeBuilder extends TreeBuilder {\n    // tag searches\n    private static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n    private static final String[] TagSearchList = new String[]{\"ol\", \"ul\"};\n    private static final String[] TagSearchButton = new String[]{\"button\"};\n    private static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"};\n    private static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"};\n    private static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"};\n    private static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n            \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n            \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n            \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n            \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n            \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n            \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n            \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"};\n\n    private HtmlTreeBuilderState state; // the current state\n    private HtmlTreeBuilderState originalState; // original / marked state\n\n    private boolean baseUriSetFromDoc;\n    private Element headElement; // the current head element\n    private FormElement formElement; // the current form element\n    private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n    private ArrayList<Element> formattingElements; // active (open) formatting elements\n    private List<String> pendingTableCharacters; // chars in table to be shifted out\n    private Token.EndTag emptyEnd; // reused empty end tag\n\n    private boolean framesetOk; // if ok to go into frameset\n    private boolean fosterInserts; // if next inserts should be fostered\n    private boolean fragmentParsing; // if parsing a fragment of html\n\n    HtmlTreeBuilder() {}\n\n    ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n\n        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); // default\n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\nElement el = new Element(tag);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n\ntokeniser.error();\n            }\n            else // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node;\n        // characters in script and style go in as datanodes, not text nodes\n        String tagName = currentElement().tagName();\n        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n    }\n\n    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }\n\n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (StringUtil.in(next.nodeName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }\n\n    // todo: tidy up in specific scope methods\n    private String[] specificScopeTarget = {null};\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (StringUtil.in(elName, targetNames))\n                return true;\n            if (StringUtil.in(elName, baseTypes))\n                return false;\n            if (extraTypes != null && StringUtil.in(elName, extraTypes))\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n        // todo: in svg namespace: forignOjbect, desc, title\n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }\n\n    /**\n     11.2.5.2 Closing elements that have implied end tags<p/>\n     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n     the UA must pop the current node off the stack of open elements.\n\n     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n     process, then the UA must perform the above steps as if that element was not in the above list.\n     */\n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.nodeName();\n        return StringUtil.in(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    // active formatting elements\n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Element el = new Element(tag, baseUri, startTag.attributes);",
        "line": 223,
        "aftercode": "el = new Element(tag, baseUri, startTag.attributes);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": "if(((extraTypes != null) && StringUtil.in(\"null\"))){"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        stack.add(i+1, in);",
        "line": 391,
        "aftercode": "stack.add((i + 1));"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        int i = stack.lastIndexOf(after);",
        "line": 389,
        "aftercode": "int i = lastIndexOf(after);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {",
        "line": 461,
        "aftercode": "String [] targetNames,String [] baseTypes        for (int pos = stack.size() -1; pos >= 0; pos--) {"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Element el = new Element(tag, baseUri, startTag.attributes);",
        "line": 223,
        "aftercode": "Element el = new Element(tag, tag);"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        stack.add(i+1, in);",
        "line": 391,
        "aftercode": "stack.add((i != -1));"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": "if((pos >= 0)){"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (StringUtil.in(elName, baseTypes))",
        "line": 467,
        "aftercode": "if(StringUtil.in(elName, baseTypes)){"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {",
        "line": 461,
        "aftercode": ""
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 465,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * HTML Tree Builder; creates a DOM from Tokens.\n */\npublic class HtmlTreeBuilder extends TreeBuilder {\n    // tag searches\n    private static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n    private static final String[] TagSearchList = new String[]{\"ol\", \"ul\"};\n    private static final String[] TagSearchButton = new String[]{\"button\"};\n    private static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"};\n    private static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"};\n    private static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"};\n    private static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n            \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n            \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n            \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n            \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n            \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n            \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n            \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"};\n\n    private HtmlTreeBuilderState state; // the current state\n    private HtmlTreeBuilderState originalState; // original / marked state\n\n    private boolean baseUriSetFromDoc;\n    private Element headElement; // the current head element\n    private FormElement formElement; // the current form element\n    private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n    private ArrayList<Element> formattingElements; // active (open) formatting elements\n    private List<String> pendingTableCharacters; // chars in table to be shifted out\n    private Token.EndTag emptyEnd; // reused empty end tag\n\n    private boolean framesetOk; // if ok to go into frameset\n    private boolean fosterInserts; // if next inserts should be fostered\n    private boolean fragmentParsing; // if parsing a fragment of html\n\n    HtmlTreeBuilder() {}\n\n    ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n\n        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); // default\n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node;\n        // characters in script and style go in as datanodes, not text nodes\n        String tagName = currentElement().tagName();\n        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n    }\n\n    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }\n\n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (StringUtil.in(next.nodeName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }\n\n    // todo: tidy up in specific scope methods\n    private String[] specificScopeTarget = {null};\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (StringUtil.in(elName, targetNames))\n                return true;\n            if (StringUtil.in(elName, baseTypes))\n                return false;\nif((extraTypes != null)){\n                return false;\n        }\n\nValidate.fail();\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n        // todo: in svg namespace: forignOjbect, desc, title\n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }\n\n    /**\n     11.2.5.2 Closing elements that have implied end tags<p/>\n     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n     the UA must pop the current node off the stack of open elements.\n\n     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n     process, then the UA must perform the above steps as if that element was not in the above list.\n     */\n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.nodeName();\n        return StringUtil.in(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    // active formatting elements\n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": "if(((extraTypes != null) && StringUtil.in(elName))){"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Element el = new Element(tag, baseUri, startTag.attributes);",
        "line": 224,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * HTML Tree Builder; creates a DOM from Tokens.\n */\npublic class HtmlTreeBuilder extends TreeBuilder {\n    // tag searches\n    private static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n    private static final String[] TagSearchList = new String[]{\"ol\", \"ul\"};\n    private static final String[] TagSearchButton = new String[]{\"button\"};\n    private static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"};\n    private static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"};\n    private static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"};\n    private static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n            \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n            \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n            \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n            \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n            \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n            \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n            \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"};\n\n    private HtmlTreeBuilderState state; // the current state\n    private HtmlTreeBuilderState originalState; // original / marked state\n\n    private boolean baseUriSetFromDoc;\n    private Element headElement; // the current head element\n    private FormElement formElement; // the current form element\n    private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n    private ArrayList<Element> formattingElements; // active (open) formatting elements\n    private List<String> pendingTableCharacters; // chars in table to be shifted out\n    private Token.EndTag emptyEnd; // reused empty end tag\n\n    private boolean framesetOk; // if ok to go into frameset\n    private boolean fosterInserts; // if next inserts should be fostered\n    private boolean fragmentParsing; // if parsing a fragment of html\n\n    HtmlTreeBuilder() {}\n\n    ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n\n        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); // default\n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\nElement el = new Element(tag, baseUri);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n\ntokeniser.error();\n            }\n            else // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node;\n        // characters in script and style go in as datanodes, not text nodes\n        String tagName = currentElement().tagName();\n        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n    }\n\n    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }\n\n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (StringUtil.in(next.nodeName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }\n\n    // todo: tidy up in specific scope methods\n    private String[] specificScopeTarget = {null};\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (StringUtil.in(elName, targetNames))\n                return true;\n            if (StringUtil.in(elName, baseTypes))\n                return false;\n            if (extraTypes != null && StringUtil.in(elName, extraTypes))\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n        // todo: in svg namespace: forignOjbect, desc, title\n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }\n\n    /**\n     11.2.5.2 Closing elements that have implied end tags<p/>\n     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n     the UA must pop the current node off the stack of open elements.\n\n     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n     process, then the UA must perform the above steps as if that element was not in the above list.\n     */\n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.nodeName();\n        return StringUtil.in(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    // active formatting elements\n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        super.initialiseParse(input, baseUri, errors, settings);",
        "line": 62,
        "aftercode": "super.initialiseParse(input, baseUri, errors);"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        stack.add(i+1, in);",
        "line": 391,
        "aftercode": "stack.add(i, 1);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "                if (!tag.isEmpty())",
        "line": 227,
        "aftercode": "if(startTag.isSelfClosing()){"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 465,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * HTML Tree Builder; creates a DOM from Tokens.\n */\npublic class HtmlTreeBuilder extends TreeBuilder {\n    // tag searches\n    private static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n    private static final String[] TagSearchList = new String[]{\"ol\", \"ul\"};\n    private static final String[] TagSearchButton = new String[]{\"button\"};\n    private static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"};\n    private static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"};\n    private static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"};\n    private static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n            \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n            \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n            \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n            \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n            \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n            \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n            \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"};\n\n    private HtmlTreeBuilderState state; // the current state\n    private HtmlTreeBuilderState originalState; // original / marked state\n\n    private boolean baseUriSetFromDoc;\n    private Element headElement; // the current head element\n    private FormElement formElement; // the current form element\n    private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n    private ArrayList<Element> formattingElements; // active (open) formatting elements\n    private List<String> pendingTableCharacters; // chars in table to be shifted out\n    private Token.EndTag emptyEnd; // reused empty end tag\n\n    private boolean framesetOk; // if ok to go into frameset\n    private boolean fosterInserts; // if next inserts should be fostered\n    private boolean fragmentParsing; // if parsing a fragment of html\n\n    HtmlTreeBuilder() {}\n\n    ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n\n        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); // default\n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node;\n        // characters in script and style go in as datanodes, not text nodes\n        String tagName = currentElement().tagName();\n        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n    }\n\n    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }\n\n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (StringUtil.in(next.nodeName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }\n\n    // todo: tidy up in specific scope methods\n    private String[] specificScopeTarget = {null};\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (StringUtil.in(elName, targetNames))\n                return true;\n            if (StringUtil.in(elName, baseTypes))\n                return false;\nif(StringUtil.in(elName, extraTypes)){\n                return false;\n        }\n\nStringUtil.in(elName, extraTypes);\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n        // todo: in svg namespace: forignOjbect, desc, title\n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }\n\n    /**\n     11.2.5.2 Closing elements that have implied end tags<p/>\n     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n     the UA must pop the current node off the stack of open elements.\n\n     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n     process, then the UA must perform the above steps as if that element was not in the above list.\n     */\n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.nodeName();\n        return StringUtil.in(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    // active formatting elements\n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": ""
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {",
        "line": 461,
        "aftercode": ""
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    void insertOnStackAfter(Element after, Element in) {",
        "line": 388,
        "aftercode": "Element after        int i = stack.lastIndexOf(after);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Element el = new Element(tag, baseUri, startTag.attributes);",
        "line": 223,
        "aftercode": "Element el = new Element(baseUri, baseUri);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Element el = new Element(tag, baseUri, startTag.attributes);",
        "line": 224,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * HTML Tree Builder; creates a DOM from Tokens.\n */\npublic class HtmlTreeBuilder extends TreeBuilder {\n    // tag searches\n    private static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n    private static final String[] TagSearchList = new String[]{\"ol\", \"ul\"};\n    private static final String[] TagSearchButton = new String[]{\"button\"};\n    private static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"};\n    private static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"};\n    private static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"};\n    private static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n            \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n            \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n            \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n            \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n            \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n            \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n            \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"};\n\n    private HtmlTreeBuilderState state; // the current state\n    private HtmlTreeBuilderState originalState; // original / marked state\n\n    private boolean baseUriSetFromDoc;\n    private Element headElement; // the current head element\n    private FormElement formElement; // the current form element\n    private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n    private ArrayList<Element> formattingElements; // active (open) formatting elements\n    private List<String> pendingTableCharacters; // chars in table to be shifted out\n    private Token.EndTag emptyEnd; // reused empty end tag\n\n    private boolean framesetOk; // if ok to go into frameset\n    private boolean fosterInserts; // if next inserts should be fostered\n    private boolean fragmentParsing; // if parsing a fragment of html\n\n    HtmlTreeBuilder() {}\n\n    ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n\n        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); // default\n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\nElement el = new Element(tag);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n\ntag.error();\n            }\n            else // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node;\n        // characters in script and style go in as datanodes, not text nodes\n        String tagName = currentElement().tagName();\n        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n    }\n\n    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }\n\n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (StringUtil.in(next.nodeName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }\n\n    // todo: tidy up in specific scope methods\n    private String[] specificScopeTarget = {null};\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (StringUtil.in(elName, targetNames))\n                return true;\n            if (StringUtil.in(elName, baseTypes))\n                return false;\n            if (extraTypes != null && StringUtil.in(elName, extraTypes))\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n        // todo: in svg namespace: forignOjbect, desc, title\n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }\n\n    /**\n     11.2.5.2 Closing elements that have implied end tags<p/>\n     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n     the UA must pop the current node off the stack of open elements.\n\n     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n     process, then the UA must perform the above steps as if that element was not in the above list.\n     */\n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.nodeName();\n        return StringUtil.in(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    // active formatting elements\n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": ""
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        stack.add(i+1, in);",
        "line": 391,
        "aftercode": "stack.add(i, -1);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (StringUtil.in(elName, targetNames))",
        "line": 465,
        "aftercode": "if(StringUtil.in(elName, baseTypes)){"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        emptyEnd = new Token.EndTag();",
        "line": 73,
        "aftercode": "emptyEnd = new Token();"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Tag tag = Tag.valueOf(startTag.name(), settings);",
        "line": 222,
        "aftercode": "Tag tag = Tag.valueOf();"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        emptyEnd = new Token.EndTag();",
        "line": 73,
        "aftercode": "new Token();"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");",
        "line": 228,
        "aftercode": "return;"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {",
        "line": 461,
        "aftercode": ""
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": "if(StringUtil.in(elName, baseTypes)){"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "                if (!tag.isEmpty())",
        "line": 227,
        "aftercode": "if(tag.isKnownTag()){"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Element el = new Element(tag, baseUri, startTag.attributes);",
        "line": 223,
        "aftercode": "Element el = new Element(baseUri, tag, baseUri);"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 465,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * HTML Tree Builder; creates a DOM from Tokens.\n */\npublic class HtmlTreeBuilder extends TreeBuilder {\n    // tag searches\n    private static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n    private static final String[] TagSearchList = new String[]{\"ol\", \"ul\"};\n    private static final String[] TagSearchButton = new String[]{\"button\"};\n    private static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"};\n    private static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"};\n    private static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"};\n    private static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n            \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n            \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n            \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n            \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n            \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n            \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n            \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"};\n\n    private HtmlTreeBuilderState state; // the current state\n    private HtmlTreeBuilderState originalState; // original / marked state\n\n    private boolean baseUriSetFromDoc;\n    private Element headElement; // the current head element\n    private FormElement formElement; // the current form element\n    private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n    private ArrayList<Element> formattingElements; // active (open) formatting elements\n    private List<String> pendingTableCharacters; // chars in table to be shifted out\n    private Token.EndTag emptyEnd; // reused empty end tag\n\n    private boolean framesetOk; // if ok to go into frameset\n    private boolean fosterInserts; // if next inserts should be fostered\n    private boolean fragmentParsing; // if parsing a fragment of html\n\n    HtmlTreeBuilder() {}\n\n    ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n\n        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); // default\n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node;\n        // characters in script and style go in as datanodes, not text nodes\n        String tagName = currentElement().tagName();\n        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n    }\n\n    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }\n\n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (StringUtil.in(next.nodeName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }\n\n    // todo: tidy up in specific scope methods\n    private String[] specificScopeTarget = {null};\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (StringUtil.in(elName, targetNames))\n                return true;\n            if (StringUtil.in(elName, baseTypes))\n                return false;\nif(StringUtil.in(elName, extraTypes)){\n                return false;\n        }\n\nValidate.fail(elName, extraTypes);\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n        // todo: in svg namespace: forignOjbect, desc, title\n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }\n\n    /**\n     11.2.5.2 Closing elements that have implied end tags<p/>\n     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n     the UA must pop the current node off the stack of open elements.\n\n     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n     process, then the UA must perform the above steps as if that element was not in the above list.\n     */\n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.nodeName();\n        return StringUtil.in(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    // active formatting elements\n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        insertNode(el);",
        "line": 224,
        "aftercode": "insertNode();"
    },
    {
        "id": 15,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "            if (extraTypes != null && StringUtil.in(elName, extraTypes))",
        "line": 469,
        "aftercode": ""
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    void insertOnStackAfter(Element after, Element in) {",
        "line": 388,
        "aftercode": "Element after        int i = stack.lastIndexOf(after);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Element el = new Element(tag, baseUri, startTag.attributes);",
        "line": 223,
        "aftercode": "Element el = new Element(tag, startTag);"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        state = HtmlTreeBuilderState.Initial;",
        "line": 65,
        "aftercode": "super.initialiseParse(input, baseUri);"
    },
    {
        "id": 16,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        Tag tag = Tag.valueOf(startTag.name(), settings);",
        "line": 222,
        "aftercode": "Tag tag = startTag.name();"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        int i = stack.lastIndexOf(after);",
        "line": 389,
        "aftercode": "int i = (int)after;"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        stack.add(i+1, in);",
        "line": 391,
        "aftercode": "stack.add(i, 0);"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    void insertOnStackAfter(Element after, Element in) {",
        "line": 388,
        "aftercode": ""
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        int i = stack.lastIndexOf(after);",
        "line": 389,
        "aftercode": "int i = new int();"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        int i = stack.lastIndexOf(after);",
        "line": 389,
        "aftercode": "int i = new int(after);"
    },
    {
        "id": 17,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        emptyEnd = new Token.EndTag();",
        "line": 73,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * HTML Tree Builder; creates a DOM from Tokens.\n */\npublic class HtmlTreeBuilder extends TreeBuilder {\n    // tag searches\n    private static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n    private static final String[] TagSearchList = new String[]{\"ol\", \"ul\"};\n    private static final String[] TagSearchButton = new String[]{\"button\"};\n    private static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"};\n    private static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"};\n    private static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"};\n    private static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n            \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n            \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n            \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n            \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n            \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n            \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n            \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"};\n\n    private HtmlTreeBuilderState state; // the current state\n    private HtmlTreeBuilderState originalState; // original / marked state\n\n    private boolean baseUriSetFromDoc;\n    private Element headElement; // the current head element\n    private FormElement formElement; // the current form element\n    private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n    private ArrayList<Element> formattingElements; // active (open) formatting elements\n    private List<String> pendingTableCharacters; // chars in table to be shifted out\n    private Token.EndTag emptyEnd; // reused empty end tag\n\n    private boolean framesetOk; // if ok to go into frameset\n    private boolean fosterInserts; // if next inserts should be fostered\n    private boolean fragmentParsing; // if parsing a fragment of html\n\n    HtmlTreeBuilder() {}\n\n    ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n\n        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\nemptyEnd = new Token();\n        framesetOk = true;\n        fosterInserts = false;\n\nemptyEnd = new Token();\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); // default\n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node;\n        // characters in script and style go in as datanodes, not text nodes\n        String tagName = currentElement().tagName();\n        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n    }\n\n    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }\n\n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (StringUtil.in(next.nodeName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }\n\n    // todo: tidy up in specific scope methods\n    private String[] specificScopeTarget = {null};\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (StringUtil.in(elName, targetNames))\n                return true;\n            if (StringUtil.in(elName, baseTypes))\n                return false;\n            if (extraTypes != null && StringUtil.in(elName, extraTypes))\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n        // todo: in svg namespace: forignOjbect, desc, title\n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }\n\n    /**\n     11.2.5.2 Closing elements that have implied end tags<p/>\n     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n     the UA must pop the current node off the stack of open elements.\n\n     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n     process, then the UA must perform the above steps as if that element was not in the above list.\n     */\n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.nodeName();\n        return StringUtil.in(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    // active formatting elements\n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        stack.add(i+1, in);",
        "line": 391,
        "aftercode": "stack.add(after, in);"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        stack.add(i+1, in);",
        "line": 391,
        "aftercode": "stack.add(i, (i + 1));"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    void insertOnStackAfter(Element after, Element in) {",
        "line": 388,
        "aftercode": ""
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    void insertOnStackAfter(Element after, Element in) {",
        "line": 388,
        "aftercode": ""
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "    void insertOnStackAfter(Element after, Element in) {",
        "line": 388,
        "aftercode": ""
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_63_fixed/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "precode": "        int i = stack.lastIndexOf(after);",
        "line": 389,
        "aftercode": "i = stack.lastIndexOf(after);"
    }
]