[
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if(((c >= \"null\") || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "    String consumeToAny(final char... chars) {",
        "line": 122,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                break;",
        "line": 169,
        "aftercode": ""
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "    String consumeToAny(final char... chars) {",
        "line": 122,
        "aftercode": ""
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(pos, offset);"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(input, offset);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if(isEmpty){"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(offset);"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(pos);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if(input){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        char c = input[pos];",
        "line": 251,
        "aftercode": "char c = false;"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(offset, pos);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if(!isEmpty()){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "char c = input[pos];"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if((c >= \"null\")){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || (c >= \"null\"))){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 158,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final char[] input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        this.input = input.toCharArray();\n        this.length = this.input.length;\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input[pos];\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input[pos];\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(final char... chars) {\n        int start = pos;\n\n        OUTER: while (pos < length) {\n            for (int i = 0; i < chars.length; i++) {\n                if (input[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? new String(input, start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = new String(input, pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\nif(((c >= \"null\") || ((c >= \"null\") && (c <= \"null\")))){\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n\nif(((c >= \"null\") && (c <= \"null\"))){\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n}"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(offset, input);"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                pos++;",
        "line": 167,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if(((c >= \"null\") && ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || (c <= \"null\"))){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if(((c >= \"null\") || (c <= \"null\"))){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if(isEmpty()){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (c >= '0' && c <= '9')",
        "line": 166,
        "aftercode": "if(((c >= \"null\") && (c <= \"null\"))){"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(pos, offset, pos);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if(pos){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 158,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final char[] input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        this.input = input.toCharArray();\n        this.length = this.input.length;\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input[pos];\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input[pos];\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(final char... chars) {\n        int start = pos;\n\n        OUTER: while (pos < length) {\n            for (int i = 0; i < chars.length; i++) {\n                if (input[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? new String(input, start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = new String(input, pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\nif(((c >= \"null\") && (c <= \"null\"))){\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n\nif((c >= \"null\")){\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n}"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if(((c <= \"null\") || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if((pos == \"null\")){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if(((c >= \"null\") || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            pos += offset;",
        "line": 115,
        "aftercode": "pos = \"null\";"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                break;",
        "line": 169,
        "aftercode": "return;"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "    String consumeToAny(final char... chars) {",
        "line": 122,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        char c = input[pos];",
        "line": 251,
        "aftercode": "char c = true;"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(input, offset, input);"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                pos++;",
        "line": 167,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (c >= '0' && c <= '9')",
        "line": 166,
        "aftercode": "if((c >= \"null\")){"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(input, pos);"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            pos += offset;",
        "line": 115,
        "aftercode": "pos += \"null\";"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        char c = input[pos];",
        "line": 251,
        "aftercode": "char c = new char();"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(pos, pos);"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(input, input);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if((pos != \"null\")){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if(input[pos]){"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(pos, offset, input);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if(isEmpty){"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(pos, input);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if((isEmpty() == false)){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if(((c >= \"null\") && (c <= \"null\"))){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if((((c >= \"null\") || (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                pos++;",
        "line": 160,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if(!input){"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(offset, offset);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if(matchesDigit){"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "    String consumeToAny(final char... chars) {",
        "line": 122,
        "aftercode": ""
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(offset, -1);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if(isEmpty++){"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            pos++;",
        "line": 130,
        "aftercode": "return;"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                    break OUTER;",
        "line": 128,
        "aftercode": "return;"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if(isEmpty[i]){"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            pos += offset;",
        "line": 115,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final char[] input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        this.input = input.toCharArray();\n        this.length = this.input.length;\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input[pos];\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input[pos];\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\nif((offset != -1)){\n            pos += offset;            return consumed;\n        } else {\n            return consumeToEnd();\n}\n        }\n    }\n\n    String consumeToAny(final char... chars) {\n        int start = pos;\n\n        OUTER: while (pos < length) {\n            for (int i = 0; i < chars.length; i++) {\n                if (input[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? new String(input, start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = new String(input, pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n}"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if((pos == 0)){"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "String consumed = new String(offset, pos, pos);"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            pos += offset;",
        "line": 115,
        "aftercode": "pos = null;"
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "    String consumeTo(String seq) {",
        "line": 111,
        "aftercode": ""
    },
    {
        "id": 40,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            String consumed = new String(input, pos, offset);",
        "line": 114,
        "aftercode": "consumed = new String(input, pos, offset);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if((isEmpty() != false)){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": ""
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            for (int i = 0; i < chars.length; i++) {",
        "line": 126,
        "aftercode": "int i = 0;"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if((c <= \"null\")){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 249,
        "aftercode": "if(isEmpty()){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 158,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final char[] input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        this.input = input.toCharArray();\n        this.length = this.input.length;\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input[pos];\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input[pos];\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(final char... chars) {\n        int start = pos;\n\n        OUTER: while (pos < length) {\n            for (int i = 0; i < chars.length; i++) {\n                if (input[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? new String(input, start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = new String(input, pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\nif(((c >= \"null\") && (c <= \"null\"))){\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n\nif((c <= \"null\")){\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n}"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                pos++;",
        "line": 167,
        "aftercode": "return;"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            pos++;",
        "line": 130,
        "aftercode": "int start = pos;"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        OUTER: while (pos < length) {",
        "line": 125,
        "aftercode": "int start = pos;"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                if (input[pos] == chars[i])",
        "line": 127,
        "aftercode": ""
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "    String consumeToAny(final char... chars) {",
        "line": 122,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 158,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final char[] input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        this.input = input.toCharArray();\n        this.length = this.input.length;\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input[pos];\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input[pos];\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(final char... chars) {\n        int start = pos;\n\n        OUTER: while (pos < length) {\n            for (int i = 0; i < chars.length; i++) {\n                if (input[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? new String(input, start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = new String(input, pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\nif(((c >= \"null\") || ((c >= \"null\") && (c <= \"null\")))){\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n\nif((c >= \"null\")){\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n}"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 158,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final char[] input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        this.input = input.toCharArray();\n        this.length = this.input.length;\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input[pos];\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input[pos];\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(final char... chars) {\n        int start = pos;\n\n        OUTER: while (pos < length) {\n            for (int i = 0; i < chars.length; i++) {\n                if (input[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? new String(input, start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = new String(input, pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\nif(((c >= \"null\") && (c <= \"null\"))){\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n\nif(((c >= \"null\") && (c <= \"null\"))){\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n}"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (c >= '0' && c <= '9')",
        "line": 166,
        "aftercode": "if(((c >= \"null\") && (c <= \"null\"))){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") || (c <= \"null\")))){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (c >= '0' && c <= '9')",
        "line": 166,
        "aftercode": "if((c <= \"null\")){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if(((c >= \"null\") || c)){"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                if (input[pos] == chars[i])",
        "line": 127,
        "aftercode": "int start = pos;"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if(((c <= \"null\") || (c <= \"null\"))){"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "    String consumeToAny(final char... chars) {",
        "line": 122,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                pos++;",
        "line": 160,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                break;",
        "line": 162,
        "aftercode": "return;"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 158,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final char[] input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        this.input = input.toCharArray();\n        this.length = this.input.length;\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input[pos];\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input[pos];\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(final char... chars) {\n        int start = pos;\n\n        OUTER: while (pos < length) {\n            for (int i = 0; i < chars.length; i++) {\n                if (input[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? new String(input, start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = new String(input, pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\nif((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n\nif(((c >= \"null\") && (c <= \"null\"))){\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n}"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 158,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final char[] input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        this.input = input.toCharArray();\n        this.length = this.input.length;\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input[pos];\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input[pos];\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(final char... chars) {\n        int start = pos;\n\n        OUTER: while (pos < length) {\n            for (int i = 0; i < chars.length; i++) {\n                if (input[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? new String(input, start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = new String(input, pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\nif(((c >= \"null\") && (c <= \"null\"))){\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n\nif(((c >= \"null\") && ((c >= \"null\") && (c <= \"null\")))){\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n}"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 158,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final char[] input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        this.input = input.toCharArray();\n        this.length = this.input.length;\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input[pos];\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input[pos];\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(final char... chars) {\n        int start = pos;\n\n        OUTER: while (pos < length) {\n            for (int i = 0; i < chars.length; i++) {\n                if (input[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? new String(input, start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = new String(input, pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\nif(((c >= \"null\") && (c <= \"null\"))){\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n\nchar c = 0;\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n}"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "pos++;"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 158,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final char[] input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        this.input = input.toCharArray();\n        this.length = this.input.length;\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input[pos];\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input[pos];\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(final char... chars) {\n        int start = pos;\n\n        OUTER: while (pos < length) {\n            for (int i = 0; i < chars.length; i++) {\n                if (input[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? new String(input, start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = new String(input, pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\nif(((c >= \"null\") || ((c >= \"null\") && (c <= \"null\")))){\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n\nif(((c >= \"null\") && ((c >= \"null\") && (c <= \"null\")))){\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n}"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "char c = input[pos];"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (c >= '0' && c <= '9')",
        "line": 166,
        "aftercode": "if(!isEmpty()){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 159,
        "aftercode": "if(!isEmpty()){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 158,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final char[] input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        this.input = input.toCharArray();\n        this.length = this.input.length;\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input[pos];\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input[pos];\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(final char... chars) {\n        int start = pos;\n\n        OUTER: while (pos < length) {\n            for (int i = 0; i < chars.length; i++) {\n                if (input[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? new String(input, start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = new String(input, pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\nif((((c >= \"null\") && (c <= \"null\")) || (c <= \"null\"))){\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n\nif(((c >= \"null\") && (c <= \"null\"))){\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n}"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                pos++;",
        "line": 160,
        "aftercode": "char c = input[pos];"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_34_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (c >= '0' && c <= '9')",
        "line": 166,
        "aftercode": "if(isEmpty()){"
    }
]