[
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {",
        "line": 395,
        "aftercode": ""
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            return matches(false);",
        "line": 180,
        "aftercode": ""
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matches(\":not(\")) {",
        "line": 183,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {",
        "line": 395,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                    children.add(c);",
        "line": 400,
        "aftercode": "children.add();"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matches(\":matchesOwn(\")) {",
        "line": 181,
        "aftercode": ""
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            return matches(false);",
        "line": 180,
        "aftercode": ""
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matches(\":matches(\")) {",
        "line": 179,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        Elements children = new Elements();",
        "line": 396,
        "aftercode": "Elements children = new Elements<Element>();"
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                intersectElements(filterForSelf(elements, candidates));",
        "line": 131,
        "aftercode": "intersectElements(elements, candidates);"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matches(\":containsOwn(\")) {",
        "line": 177,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        Elements children = new Elements();",
        "line": 396,
        "aftercode": "Elements children = new Collection<Element>();"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        tq.consume(own? \":matchesOwn\" : \":matches\");",
        "line": 301,
        "aftercode": "Validate.notEmpty(regex, \"null\");"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            return has();",
        "line": 174,
        "aftercode": ""
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            return matches(false);",
        "line": 180,
        "aftercode": ""
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        return new Elements(elements);",
        "line": 101,
        "aftercode": ""
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                Elements candidates = findElements(); // take next el, #. etc off queue",
        "line": 130,
        "aftercode": ""
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            return contains(false);",
        "line": 176,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                    children.add(c);",
        "line": 400,
        "aftercode": "children.add(\"null\");"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matches(\":contains(\")) {",
        "line": 175,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        Elements children = new Elements();",
        "line": 396,
        "aftercode": "Elements children = new Collection();"
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                intersectElements(filterForSelf(elements, candidates));",
        "line": 131,
        "aftercode": "elements.addAll(select(subQuery, root));"
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                intersectElements(filterForSelf(elements, candidates));",
        "line": 131,
        "aftercode": "intersectElements(elements, candidates);"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            return indexEquals();",
        "line": 172,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        Elements children = new Elements();",
        "line": 396,
        "aftercode": "Elements children = new Element<Element>();"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matches(\":matchesOwn(\")) {",
        "line": 181,
        "aftercode": ""
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matches(\":matches(\")) {",
        "line": 179,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                    continue CHILD;",
        "line": 401,
        "aftercode": "return;"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matches(\":containsOwn(\")) {",
        "line": 177,
        "aftercode": ""
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matches(\":matches(\")) {",
        "line": 179,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            for (Element p : parents) {",
        "line": 398,
        "aftercode": "Element p = ;"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        tq.consume(own? \":matchesOwn\" : \":matches\");",
        "line": 301,
        "aftercode": "tq.consume(own);"
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                intersectElements(filterForSelf(elements, candidates));",
        "line": 131,
        "aftercode": "elements.addAll(select(subQuery, root));"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            return has();",
        "line": 174,
        "aftercode": ""
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                Elements candidates = findElements(); // take next el, #. etc off queue",
        "line": 130,
        "aftercode": ""
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matches(\":has(\")) {",
        "line": 173,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {",
        "line": 395,
        "aftercode": "Collection<Element> parents        Elements children = new Elements();"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            return has();",
        "line": 174,
        "aftercode": ""
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                intersectElements(filterForSelf(elements, candidates));",
        "line": 131,
        "aftercode": "intersectElements(filterForSelf(elements));"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matches(\":containsOwn(\")) {",
        "line": 177,
        "aftercode": ""
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            return indexGreaterThan();",
        "line": 170,
        "aftercode": ""
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                intersectElements(filterForSelf(elements, candidates));",
        "line": 131,
        "aftercode": "intersectElements(filterForSelf(candidates));"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        CHILD: for (Element c : candidates) {",
        "line": 397,
        "aftercode": "(Element c = ;"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                    children.add(c);",
        "line": 400,
        "aftercode": "children.add(true);"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matchChomp(\":eq(\")) {",
        "line": 171,
        "aftercode": "if(tq.matches(\"null\")){"
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                intersectElements(filterForSelf(elements, candidates));",
        "line": 131,
        "aftercode": "intersectElements(filterForSelf(\"null\"));"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            for (Element p : parents) {",
        "line": 398,
        "aftercode": "(Element p = ;"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {",
        "line": 395,
        "aftercode": "Collection<Element> parents        Elements children = new Elements();"
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                intersectElements(filterForSelf(elements, candidates));",
        "line": 131,
        "aftercode": "intersectElements();"
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            } else if (tq.matchesAny(combinators)) {",
        "line": 125,
        "aftercode": "if(tq.matchesAny(combinators)){"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matchChomp(\":gt(\")) {",
        "line": 169,
        "aftercode": "if(tq.matches(\"null\")){"
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                intersectElements(filterForSelf(elements, candidates));",
        "line": 131,
        "aftercode": "intersectElements(\"null\");"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                    children.add(c);",
        "line": 400,
        "aftercode": "children.add(false);"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matchChomp(\".\")) {",
        "line": 159,
        "aftercode": "if(tq.matchesWord()){"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            return has();",
        "line": 174,
        "aftercode": ""
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        tq.consume(own? \":matchesOwn\" : \":matches\");",
        "line": 301,
        "aftercode": "Validate.notEmpty(regex, \"null\");"
    },
    {
        "id": 22,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            } else if (tq.matchesAny(combinators)) {",
        "line": 125,
        "aftercode": "if(tq.matchChomp(\"null\")){"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matchChomp(\":gt(\")) {",
        "line": 169,
        "aftercode": "if(tq.matchChomp(\"null\")){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                    children.add(c);",
        "line": 400,
        "aftercode": "children.add(0);"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            return indexLessThan();",
        "line": 168,
        "aftercode": ""
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                if (c.equals(p)) {",
        "line": 399,
        "aftercode": "if(c.equals()){"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped",
        "line": 302,
        "aftercode": "Validate.notEmpty(regex, \"null\");"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matchChomp(\".\")) {",
        "line": 159,
        "aftercode": "if(tq.matches(\"null\")){"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "            return contains(false);",
        "line": 176,
        "aftercode": ""
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matchChomp(\":lt(\")) {",
        "line": 167,
        "aftercode": "if(tq.matches(\"null\")){"
    },
    {
        "id": 23,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        } else if (tq.matches(\":has(\")) {",
        "line": 173,
        "aftercode": "if(tq.matchChomp(\"null\")){"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        Elements children = new Elements();",
        "line": 396,
        "aftercode": "Elements children = new ArrayList<Element>();"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        CHILD: for (Element c : candidates) {",
        "line": 397,
        "aftercode": "(Collection<Element> c = ;"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {",
        "line": 395,
        "aftercode": "Collection<Element> candidates        Elements children = new Elements();"
    },
    {
        "id": 25,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "                    children.add(c);",
        "line": 400,
        "aftercode": "children.add(parents);"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped",
        "line": 302,
        "aftercode": "String regex = tq.chompBalanced();"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped",
        "line": 302,
        "aftercode": "package org.jsoup.select;\n\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.TokenQueue;\n\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\n\n/**\n CSS-like element selector, that finds elements matching a query.\n\n <h2>Selector syntax</h2>\n A selector is a chain of simple selectors, seperated by combinators. Selectors are case insensitive (including against\n elements, attributes, and attribute values).\n <p/>\n The universal selector (*) is implicit when no element selector is supplied (i.e. {@code *.header} and {@code .header}\n is equivalent).\n\n <table>\n  <tr><th>Pattern</th><th>Matches</th><th>Example</th></tr>\n  <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>\n  <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>\n  <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name></code> elements</td></tr>\n  <tr><td><code>#id</code></td><td>elements with attribute ID of \"id\"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>\n  <tr><td><code>.class</code></td><td>elements with a class name of \"class\"</td><td><code>div.left</code>, <code>.result</code></td></tr>\n  <tr><td><code>[attr]</code></td><td>elements with an attribute named \"attr\" (with any value)</td><td><code>a[href]</code>, <code>[title]</code></td></tr>\n  <tr><td><code>[^attrPrefix]</code></td><td>elements with an attribute name starting with \"attrPrefix\". Use to find elements with HTML5 datasets</td><td><code>[^data-]</code>, <code>div[^data-]</code></td></tr>\n  <tr><td><code>[attr=val]</code></td><td>elements with an attribute named \"attr\", and value equal to \"val\"</td><td><code>img[width=500]</code>, <code>a[rel=nofollow]</code></td></tr>\n  <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named \"attr\", and value starting with \"valPrefix\"</td><td><code>a[href^=http:]</code></code></td></tr>\n  <tr><td><code>[attr$=valSuffix]</code></td><td>elements with an attribute named \"attr\", and value ending with \"valSuffix\"</td><td><code>img[src$=.png]</code></td></tr>\n  <tr><td><code>[attr*=valContaining]</code></td><td>elements with an attribute named \"attr\", and value containing \"valContaining\"</td><td><code>a[href*=/search/]</code></td></tr>\n  <tr><td><code>[attr~=<em>regex</em>]</code></td><td>elements with an attribute named \"attr\", and value matching the regular expression</td><td><code>img[src~=(?i)\\\\.(png|jpe?g)]</code></td></tr>\n  <tr><td></td><td>The above may be combined in any order</td><td><code>div.header[title]</code></td></tr>\n  <tr><td><td colspan=\"3\"><h3>Combinators</h3></td></tr>\n  <tr><td><code>E F</code></td><td>an F element descended from an E element</td><td><code>div a</code>, <code>.logo h1</code></td></tr>\n  <tr><td><code>E > F</code></td><td>an F direct child of E</td><td><code>ol > li</code></td></tr>\n  <tr><td><code>E + F</code></td><td>an F element immediately preceded by sibling E</td><td><code>li + li</code>, <code>div.head + div</code></td></tr>\n  <tr><td><code>E ~ F</code></td><td>an F element preceded by sibling E</td><td><code>h1 ~ p</code></td></tr>\n  <tr><td><code>E, F, G</code></td><td>all matching elements E, F, or G</td><td><code>a[href], div, h3</code></td></tr>\n  <tr><td><td colspan=\"3\"><h3>Pseudo selectors</h3></td></tr>\n  <tr><td><code>:lt(<em>n</em>)</code></td><td>elements whose sibling index is less than <em>n</em></td><td><code>td:lt(3)</code> finds the first 2 cells of each row</td></tr>\n  <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>\n  <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>\n  <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>\n  <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em></td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class</td></tr>\n  <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text \"jsoup\".</td></tr>\n  <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contains the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n  <tr><td><code>:matchesOwn(<em>regex</em>)</code></td><td>elements whose own text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesOwn(\\\\d+)</code> finds table cells directly containing digits. <code>div:matchesOwn((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  <tr><td></td><td>The above may be combined in any order and with other selectors</td><td><code>.light:contains(name):eq(0)</code></td></tr>\n  </table>\n\n @see Element#select(String)\n @author Jonathan Hedley, jonathan@hedley.net */\npublic class Selector {\n    private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\n    private final Element root;\n    private final LinkedHashSet<Element> elements; // LHS for unique and ordered elements\n    private final String query;\n    private final TokenQueue tq;\n\n    private Selector(String query, Element root) {\n        Validate.notNull(query);\n        query = query.trim();\n        Validate.notEmpty(query);\n        Validate.notNull(root);\n\n        this.elements = new LinkedHashSet<Element>();\n        this.query = query;\n        this.root = root;\n        this.tq = new TokenQueue(query);\n    }\n\n    /**\n     Find elements matching selector.\n     @param query CSS selector\n     @param root root element to descend into\n     @return matching elements, empty if not\n     */\n    public static Elements select(String query, Element root) {\n        return new Selector(query, root).select();\n    }\n\n    /**\n     Find elements matching selector.\n     @param query CSS selector\n     @param roots root elements to descend into\n     @return matching elements, empty if not\n     */\n    public static Elements select(String query, Iterable<Element> roots) {\n        Validate.notEmpty(query);\n        Validate.notNull(roots);\n        LinkedHashSet<Element> elements = new LinkedHashSet<Element>();\n\n        for (Element root : roots) {\n            elements.addAll(select(query, root));\n        }\n        return new Elements(elements);\n    }\n\n    private Elements select() {\n        tq.consumeWhitespace();\n        \n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            elements.add(root);\n            combinator(tq.consume().toString());\n        } else if (tq.matches(\":has(\")) {\n            elements.addAll(root.getAllElements());\n        } else {\n            addElements(findElements()); // chomp first element matcher off queue \n        }            \n               \n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n            \n            if (tq.matchChomp(\",\")) { // group or\n                while (!tq.isEmpty()) {\n                    String subQuery = tq.chompTo(\",\");\n                    elements.addAll(select(subQuery, root));\n                }\n            } else if (tq.matchesAny(combinators)) {\n                combinator(tq.consume().toString());\n            } else if (seenWhite) {\n                combinator(\" \");\n            } else { // E.class, E#id, E[attr] etc. AND\n                Elements candidates = findElements(); // take next el, #. etc off queue\n                intersectElements(filterForSelf(elements, candidates));\n            }\n        }\n        return new Elements(elements);\n    }\n    \n    private void combinator(String combinator) {\n        tq.consumeWhitespace();\n        String subQuery = tq.consumeToAny(combinators); // support multi > childs\n        \n        Elements output;\n        if (combinator.equals(\">\"))\n            output = filterForChildren(elements, select(subQuery, elements));\n        else if (combinator.equals(\" \"))\n            output = filterForDescendants(elements, select(subQuery, elements));\n        else if (combinator.equals(\"+\"))\n            output = filterForAdjacentSiblings(elements, select(subQuery, root));\n        else if (combinator.equals(\"~\"))\n            output = filterForGeneralSiblings(elements, select(subQuery, root));\n        else\n            throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n        \n        elements.clear(); elements.addAll(output);\n    }\n    \n    private Elements findElements() {\n        if (tq.matchChomp(\"#\")) {\n            return byId();\n        } else if (tq.matchChomp(\".\")) {\n            return byClass();\n        } else if (tq.matchesWord()) {\n            return byTag();\n        } else if (tq.matches(\"[\")) {\n            return byAttribute();\n        } else if (tq.matchChomp(\"*\")) {\n            return allElements();\n        } else if (tq.matchChomp(\":lt(\")) {\n            return indexLessThan();\n        } else if (tq.matchChomp(\":gt(\")) {\n            return indexGreaterThan();\n        } else if (tq.matchChomp(\":eq(\")) {\n            return indexEquals();\n        } else if (tq.matches(\":has(\")) {\n            return has();\n        } else if (tq.matches(\":contains(\")) {\n            return contains(false);\n        } else if (tq.matches(\":containsOwn(\")) {\n            return contains(true);\n        } else if (tq.matches(\":matches(\")) {\n            return matches(false);\n        } else if (tq.matches(\":matchesOwn(\")) {\n            return matches(true);\n        } else if (tq.matches(\":not(\")) {\n            return not();\n        } else { // unhandled\n            throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n        }\n    }\n    \n    private void addElements(Collection<Element> add) {\n        elements.addAll(add);\n    }\n    \n    private void intersectElements(Collection<Element> intersect) {\n        elements.retainAll(intersect);\n    }\n\n    private Elements byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n\n        Element found = root.getElementById(id);\n        Elements byId = new Elements();\n        if(found != null)\n            byId.add(found);\n        return byId;\n    }\n\n    private Elements byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n\n        return root.getElementsByClass(className);\n    }\n\n    private Elements byTag() {\n        String tagName = tq.consumeElementSelector();\n        Validate.notEmpty(tagName);\n        \n        // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n        if (tagName.contains(\"|\"))\n            tagName = tagName.replace(\"|\", \":\");\n        return root.getElementsByTag(tagName);\n    }\n\n    private Elements byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n        String key = cq.consumeToAny(\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"); // eq, not, start, end, contain, match, (no val)\n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            return key.startsWith(\"^\") ? root.getElementsByAttributeStarting(key.substring(1)) : root.getElementsByAttribute(key);\n        } else {\n            if (cq.matchChomp(\"=\"))\n                return root.getElementsByAttributeValue(key, cq.remainder());\n\n            else if (cq.matchChomp(\"!=\"))\n                return root.getElementsByAttributeValueNot(key, cq.remainder());\n\n            else if (cq.matchChomp(\"^=\"))\n                return root.getElementsByAttributeValueStarting(key, cq.remainder());\n\n            else if (cq.matchChomp(\"$=\"))\n                return root.getElementsByAttributeValueEnding(key, cq.remainder());\n\n            else if (cq.matchChomp(\"*=\"))\n                return root.getElementsByAttributeValueContaining(key, cq.remainder());\n            \n            else if (cq.matchChomp(\"~=\"))\n                return root.getElementsByAttributeValueMatching(key, cq.remainder());\n            \n            else\n                throw new SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n    private Elements allElements() {\n        return root.getAllElements();\n    }\n    \n    // pseudo selectors :lt, :gt, :eq\n    private Elements indexLessThan() {\n        return root.getElementsByIndexLessThan(consumeIndex());\n    }\n    \n    private Elements indexGreaterThan() {\n        return root.getElementsByIndexGreaterThan(consumeIndex());\n    }\n    \n    private Elements indexEquals() {\n        return root.getElementsByIndexEquals(consumeIndex());\n    }\n\n    private int consumeIndex() {\n        String indexS = tq.chompTo(\")\").trim();\n        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n        return Integer.parseInt(indexS);\n    }\n\n    // pseudo selector :has(el)\n    private Elements has() {\n        tq.consume(\":has\");\n        String subQuery = tq.chompBalanced('(',')');\n        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n\n        return filterForParentsOfDescendants(elements, select(subQuery, elements));\n    }\n    \n    // pseudo selector :contains(text), containsOwn(text)\n    private Elements contains(boolean own) {\n        tq.consume(own ? \":containsOwn\" : \":contains\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(',')'));\n        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n        \n        return own ? root.getElementsContainingOwnText(searchText) : root.getElementsContainingText(searchText);\n    }\n    \n    // :matches(regex), matchesOwn(regex)\n    private Elements matches(boolean own) {\n        tq.consume(own? \":matchesOwn\" : \":matches\");\nif(own){\n        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n        \n        return own ? root.getElementsMatchingOwnText(regex) : root.getElementsMatchingText(regex);\n}\n    }\n\n    // :not(selector)\n    private Elements not() {\n        tq.consume(\":not\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        return filterOut(root.getAllElements(), select(subQuery, root));\n    }\n\n    // direct child descendants\n    private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.parent() != null && c.parent().equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }\n        }\n        return children;\n    }\n    \n    // children or lower descendants. input candidates stemmed from found elements, so are either a descendant \n    // or the original element; so check that parent is not child\n    private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    continue CHILD;\n                }\n            }\n            children.add(c);\n        }\n        return children;\n    }\n\n    // implements :has(el). Finds elements that contain the matched elements\n    private static Elements filterForParentsOfDescendants(Collection<Element> parents, Collection<Element> children) {\n        Elements filteredParents = new Elements();\n        for (Element p : parents) {\n            for (Element c : children) {\n                if (c.parents().contains(p)) {\n                    filteredParents.add(p);\n                }\n            }\n        }\n        return filteredParents;\n    }\n    \n    // adjacent siblings\n    private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements siblings = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                Element previousSib = c.previousElementSibling();\n                if (previousSib != null && previousSib.equals(e)) {\n                    siblings.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return siblings;\n    }\n    \n    // preceeding siblings\n    private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements output = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                int ePos = e.elementSiblingIndex();\n                int cPos = c.elementSiblingIndex();\n                if (cPos > ePos) {\n                    output.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return output;\n    }\n    \n    // union of both sets, for e.class type selectors\n    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }   \n        }\n        return children;\n    }\n\n    // exclude set. package open so that Elements can implement .not() selector.\n    static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {\n        Elements output = new Elements();\n        for (Element el: elements) {\n            boolean found = false;\n            for (Element out: outs) {\n                if (el.equals(out)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found)\n                output.add(el);\n        }\n        return output;\n    }\n\n    public static class SelectorParseException extends IllegalStateException {\n        public SelectorParseException(String msg, Object... params) {\n            super(String.format(msg, params));\n        }\n    }\n}"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        tq.consume(own? \":matchesOwn\" : \":matches\");",
        "line": 301,
        "aftercode": "Validate.notEmpty(regex, \"null\");"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        tq.consume(own? \":matchesOwn\" : \":matches\");",
        "line": 301,
        "aftercode": "Validate.notEmpty(regex, \"null\");"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        tq.consume(own? \":matchesOwn\" : \":matches\");",
        "line": 302,
        "aftercode": "package org.jsoup.select;\n\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.TokenQueue;\n\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\n\n/**\n CSS-like element selector, that finds elements matching a query.\n\n <h2>Selector syntax</h2>\n A selector is a chain of simple selectors, seperated by combinators. Selectors are case insensitive (including against\n elements, attributes, and attribute values).\n <p/>\n The universal selector (*) is implicit when no element selector is supplied (i.e. {@code *.header} and {@code .header}\n is equivalent).\n\n <table>\n  <tr><th>Pattern</th><th>Matches</th><th>Example</th></tr>\n  <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>\n  <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>\n  <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name></code> elements</td></tr>\n  <tr><td><code>#id</code></td><td>elements with attribute ID of \"id\"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>\n  <tr><td><code>.class</code></td><td>elements with a class name of \"class\"</td><td><code>div.left</code>, <code>.result</code></td></tr>\n  <tr><td><code>[attr]</code></td><td>elements with an attribute named \"attr\" (with any value)</td><td><code>a[href]</code>, <code>[title]</code></td></tr>\n  <tr><td><code>[^attrPrefix]</code></td><td>elements with an attribute name starting with \"attrPrefix\". Use to find elements with HTML5 datasets</td><td><code>[^data-]</code>, <code>div[^data-]</code></td></tr>\n  <tr><td><code>[attr=val]</code></td><td>elements with an attribute named \"attr\", and value equal to \"val\"</td><td><code>img[width=500]</code>, <code>a[rel=nofollow]</code></td></tr>\n  <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named \"attr\", and value starting with \"valPrefix\"</td><td><code>a[href^=http:]</code></code></td></tr>\n  <tr><td><code>[attr$=valSuffix]</code></td><td>elements with an attribute named \"attr\", and value ending with \"valSuffix\"</td><td><code>img[src$=.png]</code></td></tr>\n  <tr><td><code>[attr*=valContaining]</code></td><td>elements with an attribute named \"attr\", and value containing \"valContaining\"</td><td><code>a[href*=/search/]</code></td></tr>\n  <tr><td><code>[attr~=<em>regex</em>]</code></td><td>elements with an attribute named \"attr\", and value matching the regular expression</td><td><code>img[src~=(?i)\\\\.(png|jpe?g)]</code></td></tr>\n  <tr><td></td><td>The above may be combined in any order</td><td><code>div.header[title]</code></td></tr>\n  <tr><td><td colspan=\"3\"><h3>Combinators</h3></td></tr>\n  <tr><td><code>E F</code></td><td>an F element descended from an E element</td><td><code>div a</code>, <code>.logo h1</code></td></tr>\n  <tr><td><code>E > F</code></td><td>an F direct child of E</td><td><code>ol > li</code></td></tr>\n  <tr><td><code>E + F</code></td><td>an F element immediately preceded by sibling E</td><td><code>li + li</code>, <code>div.head + div</code></td></tr>\n  <tr><td><code>E ~ F</code></td><td>an F element preceded by sibling E</td><td><code>h1 ~ p</code></td></tr>\n  <tr><td><code>E, F, G</code></td><td>all matching elements E, F, or G</td><td><code>a[href], div, h3</code></td></tr>\n  <tr><td><td colspan=\"3\"><h3>Pseudo selectors</h3></td></tr>\n  <tr><td><code>:lt(<em>n</em>)</code></td><td>elements whose sibling index is less than <em>n</em></td><td><code>td:lt(3)</code> finds the first 2 cells of each row</td></tr>\n  <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>\n  <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>\n  <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>\n  <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em></td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class</td></tr>\n  <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text \"jsoup\".</td></tr>\n  <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contains the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n  <tr><td><code>:matchesOwn(<em>regex</em>)</code></td><td>elements whose own text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesOwn(\\\\d+)</code> finds table cells directly containing digits. <code>div:matchesOwn((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  <tr><td></td><td>The above may be combined in any order and with other selectors</td><td><code>.light:contains(name):eq(0)</code></td></tr>\n  </table>\n\n @see Element#select(String)\n @author Jonathan Hedley, jonathan@hedley.net */\npublic class Selector {\n    private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\n    private final Element root;\n    private final LinkedHashSet<Element> elements; // LHS for unique and ordered elements\n    private final String query;\n    private final TokenQueue tq;\n\n    private Selector(String query, Element root) {\n        Validate.notNull(query);\n        query = query.trim();\n        Validate.notEmpty(query);\n        Validate.notNull(root);\n\n        this.elements = new LinkedHashSet<Element>();\n        this.query = query;\n        this.root = root;\n        this.tq = new TokenQueue(query);\n    }\n\n    /**\n     Find elements matching selector.\n     @param query CSS selector\n     @param root root element to descend into\n     @return matching elements, empty if not\n     */\n    public static Elements select(String query, Element root) {\n        return new Selector(query, root).select();\n    }\n\n    /**\n     Find elements matching selector.\n     @param query CSS selector\n     @param roots root elements to descend into\n     @return matching elements, empty if not\n     */\n    public static Elements select(String query, Iterable<Element> roots) {\n        Validate.notEmpty(query);\n        Validate.notNull(roots);\n        LinkedHashSet<Element> elements = new LinkedHashSet<Element>();\n\n        for (Element root : roots) {\n            elements.addAll(select(query, root));\n        }\n        return new Elements(elements);\n    }\n\n    private Elements select() {\n        tq.consumeWhitespace();\n        \n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            elements.add(root);\n            combinator(tq.consume().toString());\n        } else if (tq.matches(\":has(\")) {\n            elements.addAll(root.getAllElements());\n        } else {\n            addElements(findElements()); // chomp first element matcher off queue \n        }            \n               \n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n            \n            if (tq.matchChomp(\",\")) { // group or\n                while (!tq.isEmpty()) {\n                    String subQuery = tq.chompTo(\",\");\n                    elements.addAll(select(subQuery, root));\n                }\n            } else if (tq.matchesAny(combinators)) {\n                combinator(tq.consume().toString());\n            } else if (seenWhite) {\n                combinator(\" \");\n            } else { // E.class, E#id, E[attr] etc. AND\n                Elements candidates = findElements(); // take next el, #. etc off queue\n                intersectElements(filterForSelf(elements, candidates));\n            }\n        }\n        return new Elements(elements);\n    }\n    \n    private void combinator(String combinator) {\n        tq.consumeWhitespace();\n        String subQuery = tq.consumeToAny(combinators); // support multi > childs\n        \n        Elements output;\n        if (combinator.equals(\">\"))\n            output = filterForChildren(elements, select(subQuery, elements));\n        else if (combinator.equals(\" \"))\n            output = filterForDescendants(elements, select(subQuery, elements));\n        else if (combinator.equals(\"+\"))\n            output = filterForAdjacentSiblings(elements, select(subQuery, root));\n        else if (combinator.equals(\"~\"))\n            output = filterForGeneralSiblings(elements, select(subQuery, root));\n        else\n            throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n        \n        elements.clear(); elements.addAll(output);\n    }\n    \n    private Elements findElements() {\n        if (tq.matchChomp(\"#\")) {\n            return byId();\n        } else if (tq.matchChomp(\".\")) {\n            return byClass();\n        } else if (tq.matchesWord()) {\n            return byTag();\n        } else if (tq.matches(\"[\")) {\n            return byAttribute();\n        } else if (tq.matchChomp(\"*\")) {\n            return allElements();\n        } else if (tq.matchChomp(\":lt(\")) {\n            return indexLessThan();\n        } else if (tq.matchChomp(\":gt(\")) {\n            return indexGreaterThan();\n        } else if (tq.matchChomp(\":eq(\")) {\n            return indexEquals();\n        } else if (tq.matches(\":has(\")) {\n            return has();\n        } else if (tq.matches(\":contains(\")) {\n            return contains(false);\n        } else if (tq.matches(\":containsOwn(\")) {\n            return contains(true);\n        } else if (tq.matches(\":matches(\")) {\n            return matches(false);\n        } else if (tq.matches(\":matchesOwn(\")) {\n            return matches(true);\n        } else if (tq.matches(\":not(\")) {\n            return not();\n        } else { // unhandled\n            throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n        }\n    }\n    \n    private void addElements(Collection<Element> add) {\n        elements.addAll(add);\n    }\n    \n    private void intersectElements(Collection<Element> intersect) {\n        elements.retainAll(intersect);\n    }\n\n    private Elements byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n\n        Element found = root.getElementById(id);\n        Elements byId = new Elements();\n        if(found != null)\n            byId.add(found);\n        return byId;\n    }\n\n    private Elements byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n\n        return root.getElementsByClass(className);\n    }\n\n    private Elements byTag() {\n        String tagName = tq.consumeElementSelector();\n        Validate.notEmpty(tagName);\n        \n        // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n        if (tagName.contains(\"|\"))\n            tagName = tagName.replace(\"|\", \":\");\n        return root.getElementsByTag(tagName);\n    }\n\n    private Elements byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n        String key = cq.consumeToAny(\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"); // eq, not, start, end, contain, match, (no val)\n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            return key.startsWith(\"^\") ? root.getElementsByAttributeStarting(key.substring(1)) : root.getElementsByAttribute(key);\n        } else {\n            if (cq.matchChomp(\"=\"))\n                return root.getElementsByAttributeValue(key, cq.remainder());\n\n            else if (cq.matchChomp(\"!=\"))\n                return root.getElementsByAttributeValueNot(key, cq.remainder());\n\n            else if (cq.matchChomp(\"^=\"))\n                return root.getElementsByAttributeValueStarting(key, cq.remainder());\n\n            else if (cq.matchChomp(\"$=\"))\n                return root.getElementsByAttributeValueEnding(key, cq.remainder());\n\n            else if (cq.matchChomp(\"*=\"))\n                return root.getElementsByAttributeValueContaining(key, cq.remainder());\n            \n            else if (cq.matchChomp(\"~=\"))\n                return root.getElementsByAttributeValueMatching(key, cq.remainder());\n            \n            else\n                throw new SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n    private Elements allElements() {\n        return root.getAllElements();\n    }\n    \n    // pseudo selectors :lt, :gt, :eq\n    private Elements indexLessThan() {\n        return root.getElementsByIndexLessThan(consumeIndex());\n    }\n    \n    private Elements indexGreaterThan() {\n        return root.getElementsByIndexGreaterThan(consumeIndex());\n    }\n    \n    private Elements indexEquals() {\n        return root.getElementsByIndexEquals(consumeIndex());\n    }\n\n    private int consumeIndex() {\n        String indexS = tq.chompTo(\")\").trim();\n        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n        return Integer.parseInt(indexS);\n    }\n\n    // pseudo selector :has(el)\n    private Elements has() {\n        tq.consume(\":has\");\n        String subQuery = tq.chompBalanced('(',')');\n        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n\n        return filterForParentsOfDescendants(elements, select(subQuery, elements));\n    }\n    \n    // pseudo selector :contains(text), containsOwn(text)\n    private Elements contains(boolean own) {\n        tq.consume(own ? \":containsOwn\" : \":contains\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(',')'));\n        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n        \n        return own ? root.getElementsContainingOwnText(searchText) : root.getElementsContainingText(searchText);\n    }\n    \n    // :matches(regex), matchesOwn(regex)\n    private Elements matches(boolean own) {\nif(own){\n        tq.consume(own? \":matchesOwn\" : \":matches\");        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped\n        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n        \n        return own ? root.getElementsMatchingOwnText(regex) : root.getElementsMatchingText(regex);\n}\n    }\n\n    // :not(selector)\n    private Elements not() {\n        tq.consume(\":not\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        return filterOut(root.getAllElements(), select(subQuery, root));\n    }\n\n    // direct child descendants\n    private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.parent() != null && c.parent().equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }\n        }\n        return children;\n    }\n    \n    // children or lower descendants. input candidates stemmed from found elements, so are either a descendant \n    // or the original element; so check that parent is not child\n    private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    continue CHILD;\n                }\n            }\n            children.add(c);\n        }\n        return children;\n    }\n\n    // implements :has(el). Finds elements that contain the matched elements\n    private static Elements filterForParentsOfDescendants(Collection<Element> parents, Collection<Element> children) {\n        Elements filteredParents = new Elements();\n        for (Element p : parents) {\n            for (Element c : children) {\n                if (c.parents().contains(p)) {\n                    filteredParents.add(p);\n                }\n            }\n        }\n        return filteredParents;\n    }\n    \n    // adjacent siblings\n    private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements siblings = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                Element previousSib = c.previousElementSibling();\n                if (previousSib != null && previousSib.equals(e)) {\n                    siblings.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return siblings;\n    }\n    \n    // preceeding siblings\n    private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements output = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                int ePos = e.elementSiblingIndex();\n                int cPos = c.elementSiblingIndex();\n                if (cPos > ePos) {\n                    output.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return output;\n    }\n    \n    // union of both sets, for e.class type selectors\n    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }   \n        }\n        return children;\n    }\n\n    // exclude set. package open so that Elements can implement .not() selector.\n    static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {\n        Elements output = new Elements();\n        for (Element el: elements) {\n            boolean found = false;\n            for (Element out: outs) {\n                if (el.equals(out)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found)\n                output.add(el);\n        }\n        return output;\n    }\n\n    public static class SelectorParseException extends IllegalStateException {\n        public SelectorParseException(String msg, Object... params) {\n            super(String.format(msg, params));\n        }\n    }\n}"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped",
        "line": 302,
        "aftercode": "String regex = (String)tq.chompBalanced(\"null\", \"null\");"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        tq.consume(own? \":matchesOwn\" : \":matches\");",
        "line": 301,
        "aftercode": "Validate.notEmpty(regex, \"null\");"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");",
        "line": 302,
        "aftercode": "package org.jsoup.select;\n\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.TokenQueue;\n\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\n\n/**\n CSS-like element selector, that finds elements matching a query.\n\n <h2>Selector syntax</h2>\n A selector is a chain of simple selectors, seperated by combinators. Selectors are case insensitive (including against\n elements, attributes, and attribute values).\n <p/>\n The universal selector (*) is implicit when no element selector is supplied (i.e. {@code *.header} and {@code .header}\n is equivalent).\n\n <table>\n  <tr><th>Pattern</th><th>Matches</th><th>Example</th></tr>\n  <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>\n  <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>\n  <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name></code> elements</td></tr>\n  <tr><td><code>#id</code></td><td>elements with attribute ID of \"id\"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>\n  <tr><td><code>.class</code></td><td>elements with a class name of \"class\"</td><td><code>div.left</code>, <code>.result</code></td></tr>\n  <tr><td><code>[attr]</code></td><td>elements with an attribute named \"attr\" (with any value)</td><td><code>a[href]</code>, <code>[title]</code></td></tr>\n  <tr><td><code>[^attrPrefix]</code></td><td>elements with an attribute name starting with \"attrPrefix\". Use to find elements with HTML5 datasets</td><td><code>[^data-]</code>, <code>div[^data-]</code></td></tr>\n  <tr><td><code>[attr=val]</code></td><td>elements with an attribute named \"attr\", and value equal to \"val\"</td><td><code>img[width=500]</code>, <code>a[rel=nofollow]</code></td></tr>\n  <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named \"attr\", and value starting with \"valPrefix\"</td><td><code>a[href^=http:]</code></code></td></tr>\n  <tr><td><code>[attr$=valSuffix]</code></td><td>elements with an attribute named \"attr\", and value ending with \"valSuffix\"</td><td><code>img[src$=.png]</code></td></tr>\n  <tr><td><code>[attr*=valContaining]</code></td><td>elements with an attribute named \"attr\", and value containing \"valContaining\"</td><td><code>a[href*=/search/]</code></td></tr>\n  <tr><td><code>[attr~=<em>regex</em>]</code></td><td>elements with an attribute named \"attr\", and value matching the regular expression</td><td><code>img[src~=(?i)\\\\.(png|jpe?g)]</code></td></tr>\n  <tr><td></td><td>The above may be combined in any order</td><td><code>div.header[title]</code></td></tr>\n  <tr><td><td colspan=\"3\"><h3>Combinators</h3></td></tr>\n  <tr><td><code>E F</code></td><td>an F element descended from an E element</td><td><code>div a</code>, <code>.logo h1</code></td></tr>\n  <tr><td><code>E > F</code></td><td>an F direct child of E</td><td><code>ol > li</code></td></tr>\n  <tr><td><code>E + F</code></td><td>an F element immediately preceded by sibling E</td><td><code>li + li</code>, <code>div.head + div</code></td></tr>\n  <tr><td><code>E ~ F</code></td><td>an F element preceded by sibling E</td><td><code>h1 ~ p</code></td></tr>\n  <tr><td><code>E, F, G</code></td><td>all matching elements E, F, or G</td><td><code>a[href], div, h3</code></td></tr>\n  <tr><td><td colspan=\"3\"><h3>Pseudo selectors</h3></td></tr>\n  <tr><td><code>:lt(<em>n</em>)</code></td><td>elements whose sibling index is less than <em>n</em></td><td><code>td:lt(3)</code> finds the first 2 cells of each row</td></tr>\n  <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>\n  <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>\n  <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>\n  <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em></td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class</td></tr>\n  <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text \"jsoup\".</td></tr>\n  <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contains the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n  <tr><td><code>:matchesOwn(<em>regex</em>)</code></td><td>elements whose own text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesOwn(\\\\d+)</code> finds table cells directly containing digits. <code>div:matchesOwn((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  <tr><td></td><td>The above may be combined in any order and with other selectors</td><td><code>.light:contains(name):eq(0)</code></td></tr>\n  </table>\n\n @see Element#select(String)\n @author Jonathan Hedley, jonathan@hedley.net */\npublic class Selector {\n    private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\n    private final Element root;\n    private final LinkedHashSet<Element> elements; // LHS for unique and ordered elements\n    private final String query;\n    private final TokenQueue tq;\n\n    private Selector(String query, Element root) {\n        Validate.notNull(query);\n        query = query.trim();\n        Validate.notEmpty(query);\n        Validate.notNull(root);\n\n        this.elements = new LinkedHashSet<Element>();\n        this.query = query;\n        this.root = root;\n        this.tq = new TokenQueue(query);\n    }\n\n    /**\n     Find elements matching selector.\n     @param query CSS selector\n     @param root root element to descend into\n     @return matching elements, empty if not\n     */\n    public static Elements select(String query, Element root) {\n        return new Selector(query, root).select();\n    }\n\n    /**\n     Find elements matching selector.\n     @param query CSS selector\n     @param roots root elements to descend into\n     @return matching elements, empty if not\n     */\n    public static Elements select(String query, Iterable<Element> roots) {\n        Validate.notEmpty(query);\n        Validate.notNull(roots);\n        LinkedHashSet<Element> elements = new LinkedHashSet<Element>();\n\n        for (Element root : roots) {\n            elements.addAll(select(query, root));\n        }\n        return new Elements(elements);\n    }\n\n    private Elements select() {\n        tq.consumeWhitespace();\n        \n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            elements.add(root);\n            combinator(tq.consume().toString());\n        } else if (tq.matches(\":has(\")) {\n            elements.addAll(root.getAllElements());\n        } else {\n            addElements(findElements()); // chomp first element matcher off queue \n        }            \n               \n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n            \n            if (tq.matchChomp(\",\")) { // group or\n                while (!tq.isEmpty()) {\n                    String subQuery = tq.chompTo(\",\");\n                    elements.addAll(select(subQuery, root));\n                }\n            } else if (tq.matchesAny(combinators)) {\n                combinator(tq.consume().toString());\n            } else if (seenWhite) {\n                combinator(\" \");\n            } else { // E.class, E#id, E[attr] etc. AND\n                Elements candidates = findElements(); // take next el, #. etc off queue\n                intersectElements(filterForSelf(elements, candidates));\n            }\n        }\n        return new Elements(elements);\n    }\n    \n    private void combinator(String combinator) {\n        tq.consumeWhitespace();\n        String subQuery = tq.consumeToAny(combinators); // support multi > childs\n        \n        Elements output;\n        if (combinator.equals(\">\"))\n            output = filterForChildren(elements, select(subQuery, elements));\n        else if (combinator.equals(\" \"))\n            output = filterForDescendants(elements, select(subQuery, elements));\n        else if (combinator.equals(\"+\"))\n            output = filterForAdjacentSiblings(elements, select(subQuery, root));\n        else if (combinator.equals(\"~\"))\n            output = filterForGeneralSiblings(elements, select(subQuery, root));\n        else\n            throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n        \n        elements.clear(); elements.addAll(output);\n    }\n    \n    private Elements findElements() {\n        if (tq.matchChomp(\"#\")) {\n            return byId();\n        } else if (tq.matchChomp(\".\")) {\n            return byClass();\n        } else if (tq.matchesWord()) {\n            return byTag();\n        } else if (tq.matches(\"[\")) {\n            return byAttribute();\n        } else if (tq.matchChomp(\"*\")) {\n            return allElements();\n        } else if (tq.matchChomp(\":lt(\")) {\n            return indexLessThan();\n        } else if (tq.matchChomp(\":gt(\")) {\n            return indexGreaterThan();\n        } else if (tq.matchChomp(\":eq(\")) {\n            return indexEquals();\n        } else if (tq.matches(\":has(\")) {\n            return has();\n        } else if (tq.matches(\":contains(\")) {\n            return contains(false);\n        } else if (tq.matches(\":containsOwn(\")) {\n            return contains(true);\n        } else if (tq.matches(\":matches(\")) {\n            return matches(false);\n        } else if (tq.matches(\":matchesOwn(\")) {\n            return matches(true);\n        } else if (tq.matches(\":not(\")) {\n            return not();\n        } else { // unhandled\n            throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n        }\n    }\n    \n    private void addElements(Collection<Element> add) {\n        elements.addAll(add);\n    }\n    \n    private void intersectElements(Collection<Element> intersect) {\n        elements.retainAll(intersect);\n    }\n\n    private Elements byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n\n        Element found = root.getElementById(id);\n        Elements byId = new Elements();\n        if(found != null)\n            byId.add(found);\n        return byId;\n    }\n\n    private Elements byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n\n        return root.getElementsByClass(className);\n    }\n\n    private Elements byTag() {\n        String tagName = tq.consumeElementSelector();\n        Validate.notEmpty(tagName);\n        \n        // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n        if (tagName.contains(\"|\"))\n            tagName = tagName.replace(\"|\", \":\");\n        return root.getElementsByTag(tagName);\n    }\n\n    private Elements byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n        String key = cq.consumeToAny(\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"); // eq, not, start, end, contain, match, (no val)\n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            return key.startsWith(\"^\") ? root.getElementsByAttributeStarting(key.substring(1)) : root.getElementsByAttribute(key);\n        } else {\n            if (cq.matchChomp(\"=\"))\n                return root.getElementsByAttributeValue(key, cq.remainder());\n\n            else if (cq.matchChomp(\"!=\"))\n                return root.getElementsByAttributeValueNot(key, cq.remainder());\n\n            else if (cq.matchChomp(\"^=\"))\n                return root.getElementsByAttributeValueStarting(key, cq.remainder());\n\n            else if (cq.matchChomp(\"$=\"))\n                return root.getElementsByAttributeValueEnding(key, cq.remainder());\n\n            else if (cq.matchChomp(\"*=\"))\n                return root.getElementsByAttributeValueContaining(key, cq.remainder());\n            \n            else if (cq.matchChomp(\"~=\"))\n                return root.getElementsByAttributeValueMatching(key, cq.remainder());\n            \n            else\n                throw new SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n    private Elements allElements() {\n        return root.getAllElements();\n    }\n    \n    // pseudo selectors :lt, :gt, :eq\n    private Elements indexLessThan() {\n        return root.getElementsByIndexLessThan(consumeIndex());\n    }\n    \n    private Elements indexGreaterThan() {\n        return root.getElementsByIndexGreaterThan(consumeIndex());\n    }\n    \n    private Elements indexEquals() {\n        return root.getElementsByIndexEquals(consumeIndex());\n    }\n\n    private int consumeIndex() {\n        String indexS = tq.chompTo(\")\").trim();\n        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n        return Integer.parseInt(indexS);\n    }\n\n    // pseudo selector :has(el)\n    private Elements has() {\n        tq.consume(\":has\");\n        String subQuery = tq.chompBalanced('(',')');\n        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n\n        return filterForParentsOfDescendants(elements, select(subQuery, elements));\n    }\n    \n    // pseudo selector :contains(text), containsOwn(text)\n    private Elements contains(boolean own) {\n        tq.consume(own ? \":containsOwn\" : \":contains\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(',')'));\n        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n        \n        return own ? root.getElementsContainingOwnText(searchText) : root.getElementsContainingText(searchText);\n    }\n    \n    // :matches(regex), matchesOwn(regex)\n    private Elements matches(boolean own) {\n        tq.consume(own? \":matchesOwn\" : \":matches\");\n        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped\nif(own){\n        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");        \n        return own ? root.getElementsMatchingOwnText(regex) : root.getElementsMatchingText(regex);\n}\n    }\n\n    // :not(selector)\n    private Elements not() {\n        tq.consume(\":not\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        return filterOut(root.getAllElements(), select(subQuery, root));\n    }\n\n    // direct child descendants\n    private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.parent() != null && c.parent().equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }\n        }\n        return children;\n    }\n    \n    // children or lower descendants. input candidates stemmed from found elements, so are either a descendant \n    // or the original element; so check that parent is not child\n    private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    continue CHILD;\n                }\n            }\n            children.add(c);\n        }\n        return children;\n    }\n\n    // implements :has(el). Finds elements that contain the matched elements\n    private static Elements filterForParentsOfDescendants(Collection<Element> parents, Collection<Element> children) {\n        Elements filteredParents = new Elements();\n        for (Element p : parents) {\n            for (Element c : children) {\n                if (c.parents().contains(p)) {\n                    filteredParents.add(p);\n                }\n            }\n        }\n        return filteredParents;\n    }\n    \n    // adjacent siblings\n    private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements siblings = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                Element previousSib = c.previousElementSibling();\n                if (previousSib != null && previousSib.equals(e)) {\n                    siblings.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return siblings;\n    }\n    \n    // preceeding siblings\n    private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements output = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                int ePos = e.elementSiblingIndex();\n                int cPos = c.elementSiblingIndex();\n                if (cPos > ePos) {\n                    output.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return output;\n    }\n    \n    // union of both sets, for e.class type selectors\n    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }   \n        }\n        return children;\n    }\n\n    // exclude set. package open so that Elements can implement .not() selector.\n    static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {\n        Elements output = new Elements();\n        for (Element el: elements) {\n            boolean found = false;\n            for (Element out: outs) {\n                if (el.equals(out)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found)\n                output.add(el);\n        }\n        return output;\n    }\n\n    public static class SelectorParseException extends IllegalStateException {\n        public SelectorParseException(String msg, Object... params) {\n            super(String.format(msg, params));\n        }\n    }\n}"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");",
        "line": 303,
        "aftercode": "Validate.notEmpty();"
    },
    {
        "id": 24,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_11_fixed/src/main/java/org/jsoup/select/Selector.java",
        "precode": "        tq.consume(own? \":matchesOwn\" : \":matches\");",
        "line": 301,
        "aftercode": "tq.consume(true);"
    }
]