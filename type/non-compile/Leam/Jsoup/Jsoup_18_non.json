[
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        return false;",
        "line": 164,
        "aftercode": ""
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if(((c >= \"null\") || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if(((c >= \"null\") && (c <= \"null\"))){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || (c <= \"null\"))){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if(((c >= \"null\") || (c <= \"null\"))){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if(((c >= \"null\") && ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if(((c <= \"null\") || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 35,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            char c = input.charAt(pos);",
        "line": 88,
        "aftercode": "char c = input.charAt();"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || (c >= \"null\"))){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if(((c >= \"null\") || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if((c >= \"null\")){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if(!isEmpty()){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "char c = input.charAt(pos);"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if(((c >= \"null\") || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 35,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                    break OUTER;",
        "line": 91,
        "aftercode": "return;"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if(isEmpty){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((input.size() == 0)){"
    },
    {
        "id": 35,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            char c = input.charAt(pos);",
        "line": 88,
        "aftercode": "char c = charAt(pos);"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 115,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\n/**\n CharacterReader cosumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final String input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        input = input.replaceAll(\"\\r\\n?\", \"\\n\"); // normalise carriage returns to newlines\n\n        this.input = input;\n        this.length = input.length();\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input.charAt(pos);\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input.charAt(pos);\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return input.substring(pos, pos++);\n    }\n\n    String consumeTo(char c) {\n        int offset = input.indexOf(c, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = input.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(char... seq) {\n        int start = pos;\n\n        OUTER: while (!isEmpty()) {\n            char c = input.charAt(pos);\n            for (char seek : seq) {\n                if (seek == c)\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? input.substring(start, pos) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = input.substring(pos, input.length());\n        pos = input.length();\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\nif(((c >= \"null\") && (c <= \"null\"))){\n                pos++;\n            else\n\ninput.substring(start, pos);\n        }\n\n        return input.substring(start, pos);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input.charAt(pos) == c;\n\n    }\n\n    boolean matches(String seq) {\n        return input.startsWith(seq, pos);\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        return input.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input.charAt(pos);\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase();\n        String hiScan = seq.toUpperCase();\n        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return input.substring(pos);\n    }\n}"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                break;",
        "line": 112,
        "aftercode": ""
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                break;",
        "line": 112,
        "aftercode": "return;"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if(input.isEmpty()){"
    },
    {
        "id": 35,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            pos++;",
        "line": 93,
        "aftercode": "char c = input.charAt(pos);"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 115,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\n/**\n CharacterReader cosumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final String input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        input = input.replaceAll(\"\\r\\n?\", \"\\n\"); // normalise carriage returns to newlines\n\n        this.input = input;\n        this.length = input.length();\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input.charAt(pos);\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input.charAt(pos);\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return input.substring(pos, pos++);\n    }\n\n    String consumeTo(char c) {\n        int offset = input.indexOf(c, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = input.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(char... seq) {\n        int start = pos;\n\n        OUTER: while (!isEmpty()) {\n            char c = input.charAt(pos);\n            for (char seek : seq) {\n                if (seek == c)\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? input.substring(start, pos) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = input.substring(pos, input.length());\n        pos = input.length();\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\nif(((c >= \"null\") || ((c >= \"null\") && (c <= \"null\")))){\n                pos++;\n            else\n\nreturn;\n        }\n\n        return input.substring(start, pos);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input.charAt(pos) == c;\n\n    }\n\n    boolean matches(String seq) {\n        return input.startsWith(seq, pos);\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        return input.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input.charAt(pos);\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase();\n        String hiScan = seq.toUpperCase();\n        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return input.substring(pos);\n    }\n}"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if(((c >= \"null\") || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((input.size() != 0)){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if(!seq.isEmpty()){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 115,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\n/**\n CharacterReader cosumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final String input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        input = input.replaceAll(\"\\r\\n?\", \"\\n\"); // normalise carriage returns to newlines\n\n        this.input = input;\n        this.length = input.length();\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input.charAt(pos);\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input.charAt(pos);\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return input.substring(pos, pos++);\n    }\n\n    String consumeTo(char c) {\n        int offset = input.indexOf(c, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = input.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(char... seq) {\n        int start = pos;\n\n        OUTER: while (!isEmpty()) {\n            char c = input.charAt(pos);\n            for (char seek : seq) {\n                if (seek == c)\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? input.substring(start, pos) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = input.substring(pos, input.length());\n        pos = input.length();\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\nif(((c >= \"null\") || ((c >= \"null\") && (c <= \"null\")))){\n                pos++;\n            else\n\npos++;\n        }\n\n        return input.substring(start, pos);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input.charAt(pos) == c;\n\n    }\n\n    boolean matches(String seq) {\n        return input.startsWith(seq, pos);\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        return input.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input.charAt(pos);\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase();\n        String hiScan = seq.toUpperCase();\n        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return input.substring(pos);\n    }\n}"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((seek == c)){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        char c = input.charAt(pos);",
        "line": 159,
        "aftercode": "char c = input.charAt();"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((isEmpty() == false)){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if(isEmpty){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if((input.charAt(pos) || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) && (c <= \"null\"))){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if(((c == \"null\") || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if(!isEmpty()){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((isEmpty() == 0)){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || (c <= \"null\"))){"
    },
    {
        "id": 35,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            char c = input.charAt(pos);",
        "line": 88,
        "aftercode": "char c = input.charAt(\"null\");"
    },
    {
        "id": 35,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            for (char seek : seq) {",
        "line": 89,
        "aftercode": "char seek = 0;"
    },
    {
        "id": 35,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            pos++;",
        "line": 93,
        "aftercode": "return;"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((seek == c)){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                return true;",
        "line": 162,
        "aftercode": "char c = input.charAt(pos);"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if(((c >= \"null\") && (c <= \"null\"))){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if(isEmpty()){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if(((c >= \"null\") || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((pos == 0)){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if(((c >= \"null\") && (c <= \"null\"))){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((seq.size() == 0)){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if(!input.isEmpty()){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            char c = input.charAt(pos);",
        "line": 108,
        "aftercode": "char c = input.charAt();"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if(seq.isEmpty()){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((isEmpty() > 0)){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || (c <= \"null\"))){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((isEmpty() == true)){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 115,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\n/**\n CharacterReader cosumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final String input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        input = input.replaceAll(\"\\r\\n?\", \"\\n\"); // normalise carriage returns to newlines\n\n        this.input = input;\n        this.length = input.length();\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input.charAt(pos);\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input.charAt(pos);\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return input.substring(pos, pos++);\n    }\n\n    String consumeTo(char c) {\n        int offset = input.indexOf(c, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = input.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(char... seq) {\n        int start = pos;\n\n        OUTER: while (!isEmpty()) {\n            char c = input.charAt(pos);\n            for (char seek : seq) {\n                if (seek == c)\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? input.substring(start, pos) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = input.substring(pos, input.length());\n        pos = input.length();\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\nif(((c >= \"null\") && (c <= \"null\"))){\n                pos++;\n            else\n\npos++;\n        }\n\n        return input.substring(start, pos);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input.charAt(pos) == c;\n\n    }\n\n    boolean matches(String seq) {\n        return input.startsWith(seq, pos);\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        return input.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input.charAt(pos);\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase();\n        String hiScan = seq.toUpperCase();\n        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return input.substring(pos);\n    }\n}"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        char c = input.charAt(pos);",
        "line": 159,
        "aftercode": "char c = charAt(pos);"
    },
    {
        "id": 35,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            char c = input.charAt(pos);",
        "line": 88,
        "aftercode": "char c = input.charAt();"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if(!isEmpty()){"
    },
    {
        "id": 35,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            for (char seek : seq) {",
        "line": 89,
        "aftercode": "char seek = seq[i];"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 115,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\n/**\n CharacterReader cosumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final String input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        input = input.replaceAll(\"\\r\\n?\", \"\\n\"); // normalise carriage returns to newlines\n\n        this.input = input;\n        this.length = input.length();\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input.charAt(pos);\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input.charAt(pos);\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return input.substring(pos, pos++);\n    }\n\n    String consumeTo(char c) {\n        int offset = input.indexOf(c, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = input.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(char... seq) {\n        int start = pos;\n\n        OUTER: while (!isEmpty()) {\n            char c = input.charAt(pos);\n            for (char seek : seq) {\n                if (seek == c)\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? input.substring(start, pos) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = input.substring(pos, input.length());\n        pos = input.length();\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\nif(((c >= \"null\") && (c <= \"null\"))){\n                pos++;\n            else\n\nreturn;\n        }\n\n        return input.substring(start, pos);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input.charAt(pos) == c;\n\n    }\n\n    boolean matches(String seq) {\n        return input.startsWith(seq, pos);\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        return input.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input.charAt(pos);\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase();\n        String hiScan = seq.toUpperCase();\n        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return input.substring(pos);\n    }\n}"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        for (char seek : seq) {",
        "line": 160,
        "aftercode": "(char seek = ;"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "if(((c == \"null\") || (c <= \"null\"))){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": ""
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 109,
        "aftercode": "pos++;"
    },
    {
        "id": 42,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))",
        "line": 115,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\n/**\n CharacterReader cosumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final String input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        input = input.replaceAll(\"\\r\\n?\", \"\\n\"); // normalise carriage returns to newlines\n\n        this.input = input;\n        this.length = input.length();\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input.charAt(pos);\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input.charAt(pos);\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return input.substring(pos, pos++);\n    }\n\n    String consumeTo(char c) {\n        int offset = input.indexOf(c, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = input.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(char... seq) {\n        int start = pos;\n\n        OUTER: while (!isEmpty()) {\n            char c = input.charAt(pos);\n            for (char seek : seq) {\n                if (seek == c)\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? input.substring(start, pos) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = input.substring(pos, input.length());\n        pos = input.length();\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\nif(((c >= \"null\") || ((c >= \"null\") && (c <= \"null\")))){\n                pos++;\n            else\n\ninput.substring(start, pos);\n        }\n\n        return input.substring(start, pos);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input.charAt(pos) == c;\n\n    }\n\n    boolean matches(String seq) {\n        return input.startsWith(seq, pos);\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        return input.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input.charAt(pos);\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase();\n        String hiScan = seq.toUpperCase();\n        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return input.substring(pos);\n    }\n}"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((input.size() == 0)){"
    },
    {
        "id": 35,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                if (seek == c)",
        "line": 90,
        "aftercode": "if((pos > start)){"
    },
    {
        "id": 35,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        return pos > start ? input.substring(start, pos) : \"\";",
        "line": 96,
        "aftercode": "((pos > start))?input.substring(start, pos):\"null\";"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (seek == c)",
        "line": 161,
        "aftercode": "char c = input.charAt(pos);"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((input.size() > 0)){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "    boolean matchesAny(char... seq) {",
        "line": 155,
        "aftercode": ""
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((isEmpty() != false)){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                return true;",
        "line": 162,
        "aftercode": "char c = input.charAt(pos);"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if(isEmpty()){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            return false;",
        "line": 157,
        "aftercode": "char c = input.charAt(pos);"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((pos != 0)){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((isEmpty() != 0)){"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": ""
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_18_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        if (isEmpty())",
        "line": 156,
        "aftercode": "if((input.isEmpty() == 0)){"
    }
]