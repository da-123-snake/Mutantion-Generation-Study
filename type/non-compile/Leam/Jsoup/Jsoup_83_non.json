[
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || Character.isLetter(c))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                break;",
        "line": 298,
        "aftercode": ""
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (offset < bufLength && last <= bufLength) {",
        "line": 154,
        "aftercode": "if((i + seq.length())){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n\nif((c >= \"null\")){\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if((((c >= \"null\") || ((c >= \"null\") && (c <= \"null\"))) || Character.isLetter(c))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if(((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\"))) || Character.isLetter(c))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if(((c >= \"null\") || Character.isLetter(c))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 48,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                return i - bufPos;",
        "line": 133,
        "aftercode": "(i - bufPos);"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if((c >= \"null\")){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n\nif(Character.isLetter(c)){\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n\nif(((c >= \"null\") && Character.isLetter(c))){\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if(((((c >= \"null\") && (c <= \"null\")) || (c <= \"null\")) || Character.isLetter(c))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n\nif((c <= \"null\")){\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }",
        "line": 155,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if((((c >= \"null\") || Character.isLetter(c)) || Character.isLetter(c))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || Character.isLetter(c))){\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n\nif(((c >= \"null\") && Character.isLetter(c))){\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                bufPos++;",
        "line": 296,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){\n                bufPos++;\n            else\n\nif(((c >= \"null\") && (c <= \"null\"))){\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n\nif((((c >= \"null\") && (c <= \"null\")) && Character.isLetter(c))){\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (c >= '0' && c <= '9')",
        "line": 295,
        "aftercode": "if((c >= \"null\")){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if(((((c >= \"null\") && (c <= \"null\")) || Character.isLetter(c)) || Character.isLetter(c))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n\nif((bufPos < bufLength)){\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                    return offset - bufPos;",
        "line": 157,
        "aftercode": "(offset - bufPos);"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }",
        "line": 155,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){\n                bufPos++;\n            else\n\nif((((c >= \"null\") && (c <= \"null\")) || Character.isLetter(c))){\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (c >= '0' && c <= '9')",
        "line": 295,
        "aftercode": "if(Character.isLetter(c)){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if(((c >= \"null\") && (c <= \"null\"))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if(((((c >= \"null\") || ((c >= \"null\") && (c <= \"null\"))) || ((c >= \"null\") && (c <= \"null\"))) || Character.isLetter(c))){"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }",
        "line": 155,
        "aftercode": ""
    },
    {
        "id": 48,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (c == charBuf[i])",
        "line": 132,
        "aftercode": "if((i < bufLength)){"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (offset < bufLength && last <= bufLength) {",
        "line": 154,
        "aftercode": "if((seq.charAt(j) == charBuf[i])){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if((c <= \"null\")){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if((((c >= \"null\") && ((c >= \"null\") && (c <= \"null\"))) || Character.isLetter(c))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if(Character.isLetter(c)){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if(((((c >= \"null\") || (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\"))) || Character.isLetter(c))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                bufPos++;",
        "line": 296,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if(((((c >= \"null\") && (c <= \"null\")) && ((c >= \"null\") && (c <= \"null\"))) || Character.isLetter(c))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": ""
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (offset < bufLength && last <= bufLength) {",
        "line": 154,
        "aftercode": "if(((i + seq.length()) && (last <= bufLength))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif(((c >= \"null\") && (c <= \"null\"))){\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n\nif((c >= \"null\")){\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (c >= '0' && c <= '9')",
        "line": 295,
        "aftercode": "if(((c >= \"null\") && Character.isLetter(c))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                break;",
        "line": 298,
        "aftercode": "return;"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){\n                bufPos++;\n            else\n\nif((c >= \"null\")){\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if((((c >= \"null\") || (c <= \"null\")) || Character.isLetter(c))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) && Character.isLetter(c))){"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        char startChar = seq.charAt(0);",
        "line": 147,
        "aftercode": "char startChar = seq.charAt();"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if((((c >= \"null\") && (c <= \"null\")) || Character.isLetter(c))){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n\nif(!isEmptyNoBufferUp()){\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (c >= '0' && c <= '9')",
        "line": 295,
        "aftercode": "if(((c >= \"null\") && (c <= \"null\"))){"
    },
    {
        "id": 48,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (c == charBuf[i])",
        "line": 132,
        "aftercode": ""
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || Character.isLetter(c))){\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n\nif((bufPos < bufLength)){\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 288,
        "aftercode": "if(((((c >= \"null\") && ((c >= \"null\") && (c <= \"null\"))) || ((c >= \"null\") && (c <= \"null\"))) || Character.isLetter(c))){"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (startChar != charBuf[offset])",
        "line": 150,
        "aftercode": "int i = (offset + 1);"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (c >= '0' && c <= '9')",
        "line": 295,
        "aftercode": "if(!isEmptyNoBufferUp()){"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || Character.isLetter(c))){\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n\nif((c >= \"null\")){\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        bufferUp();",
        "line": 145,
        "aftercode": "break;"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || Character.isLetter(c))){\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n\nif(Character.isLetter(c)){\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 13,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))",
        "line": 298,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        if (bufPos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(bufPos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += bufPos;\n                bufPos = 0;\n                bufMark = 0;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (bufPos < remaining) {\n            for (char c : chars) {\n                if (val[bufPos] == c)\n                    break OUTER;\n            }\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\nif((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){\n                bufPos++;\n            else\n\nif((((c >= \"null\") && (c <= \"null\")) || ((c >= \"null\") && (c <= \"null\")))){\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "        bufferUp();",
        "line": 145,
        "aftercode": "continue;"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "            if (offset < bufLength && last <= bufLength) {",
        "line": 154,
        "aftercode": "if((i + seq.length())){"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_83_fixed/src/main/java/org/jsoup/parser/CharacterReader.java",
        "precode": "                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }",
        "line": 155,
        "aftercode": ""
    }
]