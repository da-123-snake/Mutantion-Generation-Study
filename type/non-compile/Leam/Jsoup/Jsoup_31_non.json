[
    {
        "id": 29,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "            appendAttributeName(String.valueOf(append));",
        "line": 113,
        "aftercode": "this.append = append;"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());",
        "line": 64,
        "aftercode": "attribute = new Attribute(attribute);"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());",
        "line": 64,
        "aftercode": "attribute = new Attribute(pendingAttributeValue.toString());"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, \"\");",
        "line": 62,
        "aftercode": "attribute = new Attribute(pendingAttributeName);"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());",
        "line": 64,
        "aftercode": "attribute = new Attribute(pendingAttributeName);"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                pendingAttributeValue.delete(0, pendingAttributeValue.length());",
        "line": 69,
        "aftercode": ""
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());",
        "line": 64,
        "aftercode": ""
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                pendingAttributeValue.delete(0, pendingAttributeValue.length());",
        "line": 69,
        "aftercode": "attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, \"\");",
        "line": 62,
        "aftercode": "attribute = new Attribute(attribute);"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());",
        "line": 64,
        "aftercode": "pendingAttributeValue.delete(0, pendingAttributeValue.length());"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, \"\");",
        "line": 62,
        "aftercode": "attributes.put(attribute);"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                pendingAttributeValue.delete(0, pendingAttributeValue.length());",
        "line": 69,
        "aftercode": "pendingAttributeValue.delete(pendingAttributeValue.length());"
    },
    {
        "id": 29,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "            appendAttributeName(String.valueOf(append));",
        "line": 113,
        "aftercode": "appendAttributeName(valueOf(append));"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                pendingAttributeValue.delete(0, pendingAttributeValue.length());",
        "line": 69,
        "aftercode": "pendingAttributeValue.delete();"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                pendingAttributeValue.delete(0, pendingAttributeValue.length());",
        "line": 69,
        "aftercode": "pendingAttributeValue.delete(attribute);"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());",
        "line": 64,
        "aftercode": "pendingAttributeValue.delete(0, pendingAttributeValue.length());"
    },
    {
        "id": 29,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "            appendAttributeName(String.valueOf(append));",
        "line": 113,
        "aftercode": "this.append = String.valueOf(append);"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                pendingAttributeValue.delete(0, pendingAttributeValue.length());",
        "line": 69,
        "aftercode": "attributes.put(attribute);"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, \"\");",
        "line": 62,
        "aftercode": "pendingAttributeValue.delete(0, pendingAttributeValue.length());"
    },
    {
        "id": 29,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "            appendAttributeName(String.valueOf(append));",
        "line": 113,
        "aftercode": "String.appendAttributeName(append);"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, \"\");",
        "line": 62,
        "aftercode": "attribute = new Attribute(pendingAttributeValue.toString());"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, \"\");",
        "line": 62,
        "aftercode": "attribute = new Attribute(\"null\");"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                pendingAttributeValue.delete(0, pendingAttributeValue.length());",
        "line": 69,
        "aftercode": "attribute = new Attribute(pendingAttributeName, \"null\");"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, \"\");",
        "line": 64,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\n\n/**\n * Parse tokens for the Tokeniser.\n */\nabstract class Token {\n    TokenType type;\n\n    private Token() {\n    }\n    \n    String tokenType() {\n        return this.getClass().getSimpleName();\n    }\n\n    static class Doctype extends Token {\n        final StringBuilder name = new StringBuilder();\n        final StringBuilder publicIdentifier = new StringBuilder();\n        final StringBuilder systemIdentifier = new StringBuilder();\n        boolean forceQuirks = false;\n\n        Doctype() {\n            type = TokenType.Doctype;\n        }\n\n        String getName() {\n            return name.toString();\n        }\n\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }\n\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }\n\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }\n    }\n\n    static abstract class Tag extends Token {\n        protected String tagName;\n        private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n        private StringBuilder pendingAttributeValue; // but values are accumulated, from e.g. & in hrefs\n\n        boolean selfClosing = false;\n        Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n\n        void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                Attribute attribute;\n                if (pendingAttributeValue == null)\nattribute = new Attribute(attribute);\n                else\n\nattribute = new Attribute(attribute);\n                attributes.put(attribute);\n            }\n            pendingAttributeName = null;\n            if (pendingAttributeValue != null)\n                pendingAttributeValue.delete(0, pendingAttributeValue.length());\n        }\n\n        void finaliseTag() {\n            // finalises for emit\n            if (pendingAttributeName != null) {\n                // todo: check if attribute name exists; if so, drop and error\n                newAttribute();\n            }\n        }\n\n        String name() {\n            Validate.isFalse(tagName.length() == 0);\n            return tagName;\n        }\n\n        Tag name(String name) {\n            tagName = name;\n            return this;\n        }\n\n        boolean isSelfClosing() {\n            return selfClosing;\n        }\n\n        @SuppressWarnings({\"TypeMayBeWeakened\"})\n        Attributes getAttributes() {\n            return attributes;\n        }\n\n        // these appenders are rarely hit in not null state-- caused by null chars.\n        void appendTagName(String append) {\n            tagName = tagName == null ? append : tagName.concat(append);\n        }\n\n        void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }\n\n        void appendAttributeName(String append) {\n            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n        }\n\n        void appendAttributeName(char append) {\n            appendAttributeName(String.valueOf(append));\n        }\n\n        void appendAttributeValue(String append) {\n            pendingAttributeValue = pendingAttributeValue == null ? new StringBuilder(append) : pendingAttributeValue.append(append);\n        }\n\n        void appendAttributeValue(char append) {\n            appendAttributeValue(String.valueOf(append));\n        }\n    }\n\n    static class StartTag extends Tag {\n        StartTag() {\n            super();\n            attributes = new Attributes();\n            type = TokenType.StartTag;\n        }\n\n        StartTag(String name) {\n            this();\n            this.tagName = name;\n        }\n\n        StartTag(String name, Attributes attributes) {\n            this();\n            this.tagName = name;\n            this.attributes = attributes;\n        }\n\n        @Override\n        public String toString() {\n            if (attributes != null && attributes.size() > 0)\n                return \"<\" + name() + \" \" + attributes.toString() + \">\";\n            else\n                return \"<\" + name() + \">\";\n        }\n    }\n\n    static class EndTag extends Tag{\n        EndTag() {\n            super();\n            type = TokenType.EndTag;\n        }\n\n        EndTag(String name) {\n            this();\n            this.tagName = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"</\" + name() + \">\";\n        }\n    }\n\n    static class Comment extends Token {\n        final StringBuilder data = new StringBuilder();\n        boolean bogus = false;\n\n        Comment() {\n            type = TokenType.Comment;\n        }\n\n        String getData() {\n            return data.toString();\n        }\n\n        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }\n    }\n\n    static class Character extends Token {\n        private final String data;\n\n        Character(String data) {\n            type = TokenType.Character;\n            this.data = data;\n        }\n\n        String getData() {\n            return data;\n        }\n\n        @Override\n        public String toString() {\n            return getData();\n        }\n    }\n\n    static class EOF extends Token {\n        EOF() {\n            type = Token.TokenType.EOF;\n        }\n    }\n\n    boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }\n\n    Doctype asDoctype() {\n        return (Doctype) this;\n    }\n\n    boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }\n\n    StartTag asStartTag() {\n        return (StartTag) this;\n    }\n\n    boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }\n\n    EndTag asEndTag() {\n        return (EndTag) this;\n    }\n\n    boolean isComment() {\n        return type == TokenType.Comment;\n    }\n\n    Comment asComment() {\n        return (Comment) this;\n    }\n\n    boolean isCharacter() {\n        return type == TokenType.Character;\n    }\n\n    Character asCharacter() {\n        return (Character) this;\n    }\n\n    boolean isEOF() {\n        return type == TokenType.EOF;\n    }\n\n    enum TokenType {\n        Doctype,\n        StartTag,\n        EndTag,\n        Comment,\n        Character,\n        EOF\n    }\n}"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, \"\");",
        "line": 64,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\n\n/**\n * Parse tokens for the Tokeniser.\n */\nabstract class Token {\n    TokenType type;\n\n    private Token() {\n    }\n    \n    String tokenType() {\n        return this.getClass().getSimpleName();\n    }\n\n    static class Doctype extends Token {\n        final StringBuilder name = new StringBuilder();\n        final StringBuilder publicIdentifier = new StringBuilder();\n        final StringBuilder systemIdentifier = new StringBuilder();\n        boolean forceQuirks = false;\n\n        Doctype() {\n            type = TokenType.Doctype;\n        }\n\n        String getName() {\n            return name.toString();\n        }\n\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }\n\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }\n\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }\n    }\n\n    static abstract class Tag extends Token {\n        protected String tagName;\n        private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n        private StringBuilder pendingAttributeValue; // but values are accumulated, from e.g. & in hrefs\n\n        boolean selfClosing = false;\n        Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n\n        void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                Attribute attribute;\n                if (pendingAttributeValue == null)\nattribute = new Attribute(pendingAttributeName);\n                else\n\nattribute = new Attribute(pendingAttributeValue.toString());\n                attributes.put(attribute);\n            }\n            pendingAttributeName = null;\n            if (pendingAttributeValue != null)\n                pendingAttributeValue.delete(0, pendingAttributeValue.length());\n        }\n\n        void finaliseTag() {\n            // finalises for emit\n            if (pendingAttributeName != null) {\n                // todo: check if attribute name exists; if so, drop and error\n                newAttribute();\n            }\n        }\n\n        String name() {\n            Validate.isFalse(tagName.length() == 0);\n            return tagName;\n        }\n\n        Tag name(String name) {\n            tagName = name;\n            return this;\n        }\n\n        boolean isSelfClosing() {\n            return selfClosing;\n        }\n\n        @SuppressWarnings({\"TypeMayBeWeakened\"})\n        Attributes getAttributes() {\n            return attributes;\n        }\n\n        // these appenders are rarely hit in not null state-- caused by null chars.\n        void appendTagName(String append) {\n            tagName = tagName == null ? append : tagName.concat(append);\n        }\n\n        void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }\n\n        void appendAttributeName(String append) {\n            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n        }\n\n        void appendAttributeName(char append) {\n            appendAttributeName(String.valueOf(append));\n        }\n\n        void appendAttributeValue(String append) {\n            pendingAttributeValue = pendingAttributeValue == null ? new StringBuilder(append) : pendingAttributeValue.append(append);\n        }\n\n        void appendAttributeValue(char append) {\n            appendAttributeValue(String.valueOf(append));\n        }\n    }\n\n    static class StartTag extends Tag {\n        StartTag() {\n            super();\n            attributes = new Attributes();\n            type = TokenType.StartTag;\n        }\n\n        StartTag(String name) {\n            this();\n            this.tagName = name;\n        }\n\n        StartTag(String name, Attributes attributes) {\n            this();\n            this.tagName = name;\n            this.attributes = attributes;\n        }\n\n        @Override\n        public String toString() {\n            if (attributes != null && attributes.size() > 0)\n                return \"<\" + name() + \" \" + attributes.toString() + \">\";\n            else\n                return \"<\" + name() + \">\";\n        }\n    }\n\n    static class EndTag extends Tag{\n        EndTag() {\n            super();\n            type = TokenType.EndTag;\n        }\n\n        EndTag(String name) {\n            this();\n            this.tagName = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"</\" + name() + \">\";\n        }\n    }\n\n    static class Comment extends Token {\n        final StringBuilder data = new StringBuilder();\n        boolean bogus = false;\n\n        Comment() {\n            type = TokenType.Comment;\n        }\n\n        String getData() {\n            return data.toString();\n        }\n\n        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }\n    }\n\n    static class Character extends Token {\n        private final String data;\n\n        Character(String data) {\n            type = TokenType.Character;\n            this.data = data;\n        }\n\n        String getData() {\n            return data;\n        }\n\n        @Override\n        public String toString() {\n            return getData();\n        }\n    }\n\n    static class EOF extends Token {\n        EOF() {\n            type = Token.TokenType.EOF;\n        }\n    }\n\n    boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }\n\n    Doctype asDoctype() {\n        return (Doctype) this;\n    }\n\n    boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }\n\n    StartTag asStartTag() {\n        return (StartTag) this;\n    }\n\n    boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }\n\n    EndTag asEndTag() {\n        return (EndTag) this;\n    }\n\n    boolean isComment() {\n        return type == TokenType.Comment;\n    }\n\n    Comment asComment() {\n        return (Comment) this;\n    }\n\n    boolean isCharacter() {\n        return type == TokenType.Character;\n    }\n\n    Character asCharacter() {\n        return (Character) this;\n    }\n\n    boolean isEOF() {\n        return type == TokenType.EOF;\n    }\n\n    enum TokenType {\n        Doctype,\n        StartTag,\n        EndTag,\n        Comment,\n        Character,\n        EOF\n    }\n}"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());",
        "line": 64,
        "aftercode": "attribute = pendingAttributeValue.toString();"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                attributes = new Attributes();",
        "line": 57,
        "aftercode": "attribute = new Attribute(pendingAttributeName, \"null\");"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, \"\");",
        "line": 62,
        "aftercode": "pendingAttributeName = null;"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, \"\");",
        "line": 64,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\n\n/**\n * Parse tokens for the Tokeniser.\n */\nabstract class Token {\n    TokenType type;\n\n    private Token() {\n    }\n    \n    String tokenType() {\n        return this.getClass().getSimpleName();\n    }\n\n    static class Doctype extends Token {\n        final StringBuilder name = new StringBuilder();\n        final StringBuilder publicIdentifier = new StringBuilder();\n        final StringBuilder systemIdentifier = new StringBuilder();\n        boolean forceQuirks = false;\n\n        Doctype() {\n            type = TokenType.Doctype;\n        }\n\n        String getName() {\n            return name.toString();\n        }\n\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }\n\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }\n\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }\n    }\n\n    static abstract class Tag extends Token {\n        protected String tagName;\n        private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n        private StringBuilder pendingAttributeValue; // but values are accumulated, from e.g. & in hrefs\n\n        boolean selfClosing = false;\n        Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n\n        void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                Attribute attribute;\n                if (pendingAttributeValue == null)\nattribute = new Attribute(pendingAttributeName);\n                else\n\nattribute = new Attribute(pendingAttributeName);\n                attributes.put(attribute);\n            }\n            pendingAttributeName = null;\n            if (pendingAttributeValue != null)\n                pendingAttributeValue.delete(0, pendingAttributeValue.length());\n        }\n\n        void finaliseTag() {\n            // finalises for emit\n            if (pendingAttributeName != null) {\n                // todo: check if attribute name exists; if so, drop and error\n                newAttribute();\n            }\n        }\n\n        String name() {\n            Validate.isFalse(tagName.length() == 0);\n            return tagName;\n        }\n\n        Tag name(String name) {\n            tagName = name;\n            return this;\n        }\n\n        boolean isSelfClosing() {\n            return selfClosing;\n        }\n\n        @SuppressWarnings({\"TypeMayBeWeakened\"})\n        Attributes getAttributes() {\n            return attributes;\n        }\n\n        // these appenders are rarely hit in not null state-- caused by null chars.\n        void appendTagName(String append) {\n            tagName = tagName == null ? append : tagName.concat(append);\n        }\n\n        void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }\n\n        void appendAttributeName(String append) {\n            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n        }\n\n        void appendAttributeName(char append) {\n            appendAttributeName(String.valueOf(append));\n        }\n\n        void appendAttributeValue(String append) {\n            pendingAttributeValue = pendingAttributeValue == null ? new StringBuilder(append) : pendingAttributeValue.append(append);\n        }\n\n        void appendAttributeValue(char append) {\n            appendAttributeValue(String.valueOf(append));\n        }\n    }\n\n    static class StartTag extends Tag {\n        StartTag() {\n            super();\n            attributes = new Attributes();\n            type = TokenType.StartTag;\n        }\n\n        StartTag(String name) {\n            this();\n            this.tagName = name;\n        }\n\n        StartTag(String name, Attributes attributes) {\n            this();\n            this.tagName = name;\n            this.attributes = attributes;\n        }\n\n        @Override\n        public String toString() {\n            if (attributes != null && attributes.size() > 0)\n                return \"<\" + name() + \" \" + attributes.toString() + \">\";\n            else\n                return \"<\" + name() + \">\";\n        }\n    }\n\n    static class EndTag extends Tag{\n        EndTag() {\n            super();\n            type = TokenType.EndTag;\n        }\n\n        EndTag(String name) {\n            this();\n            this.tagName = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"</\" + name() + \">\";\n        }\n    }\n\n    static class Comment extends Token {\n        final StringBuilder data = new StringBuilder();\n        boolean bogus = false;\n\n        Comment() {\n            type = TokenType.Comment;\n        }\n\n        String getData() {\n            return data.toString();\n        }\n\n        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }\n    }\n\n    static class Character extends Token {\n        private final String data;\n\n        Character(String data) {\n            type = TokenType.Character;\n            this.data = data;\n        }\n\n        String getData() {\n            return data;\n        }\n\n        @Override\n        public String toString() {\n            return getData();\n        }\n    }\n\n    static class EOF extends Token {\n        EOF() {\n            type = Token.TokenType.EOF;\n        }\n    }\n\n    boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }\n\n    Doctype asDoctype() {\n        return (Doctype) this;\n    }\n\n    boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }\n\n    StartTag asStartTag() {\n        return (StartTag) this;\n    }\n\n    boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }\n\n    EndTag asEndTag() {\n        return (EndTag) this;\n    }\n\n    boolean isComment() {\n        return type == TokenType.Comment;\n    }\n\n    Comment asComment() {\n        return (Comment) this;\n    }\n\n    boolean isCharacter() {\n        return type == TokenType.Character;\n    }\n\n    Character asCharacter() {\n        return (Character) this;\n    }\n\n    boolean isEOF() {\n        return type == TokenType.EOF;\n    }\n\n    enum TokenType {\n        Doctype,\n        StartTag,\n        EndTag,\n        Comment,\n        Character,\n        EOF\n    }\n}"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                pendingAttributeValue.delete(0, pendingAttributeValue.length());",
        "line": 69,
        "aftercode": "pendingAttributeValue.delete(0);"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());",
        "line": 64,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\n\n/**\n * Parse tokens for the Tokeniser.\n */\nabstract class Token {\n    TokenType type;\n\n    private Token() {\n    }\n    \n    String tokenType() {\n        return this.getClass().getSimpleName();\n    }\n\n    static class Doctype extends Token {\n        final StringBuilder name = new StringBuilder();\n        final StringBuilder publicIdentifier = new StringBuilder();\n        final StringBuilder systemIdentifier = new StringBuilder();\n        boolean forceQuirks = false;\n\n        Doctype() {\n            type = TokenType.Doctype;\n        }\n\n        String getName() {\n            return name.toString();\n        }\n\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }\n\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }\n\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }\n    }\n\n    static abstract class Tag extends Token {\n        protected String tagName;\n        private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n        private StringBuilder pendingAttributeValue; // but values are accumulated, from e.g. & in hrefs\n\n        boolean selfClosing = false;\n        Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n\n        void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                Attribute attribute;\n                if (pendingAttributeValue == null)\n                    attribute = new Attribute(pendingAttributeName, \"\");\n                else\nattribute = new Attribute(attribute);\n                attributes.put(attribute);\n            }\n            pendingAttributeName = null;\n            if (pendingAttributeValue != null)\n\npendingAttributeValue.delete(pendingAttributeValue.length());\n        }\n\n        void finaliseTag() {\n            // finalises for emit\n            if (pendingAttributeName != null) {\n                // todo: check if attribute name exists; if so, drop and error\n                newAttribute();\n            }\n        }\n\n        String name() {\n            Validate.isFalse(tagName.length() == 0);\n            return tagName;\n        }\n\n        Tag name(String name) {\n            tagName = name;\n            return this;\n        }\n\n        boolean isSelfClosing() {\n            return selfClosing;\n        }\n\n        @SuppressWarnings({\"TypeMayBeWeakened\"})\n        Attributes getAttributes() {\n            return attributes;\n        }\n\n        // these appenders are rarely hit in not null state-- caused by null chars.\n        void appendTagName(String append) {\n            tagName = tagName == null ? append : tagName.concat(append);\n        }\n\n        void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }\n\n        void appendAttributeName(String append) {\n            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n        }\n\n        void appendAttributeName(char append) {\n            appendAttributeName(String.valueOf(append));\n        }\n\n        void appendAttributeValue(String append) {\n            pendingAttributeValue = pendingAttributeValue == null ? new StringBuilder(append) : pendingAttributeValue.append(append);\n        }\n\n        void appendAttributeValue(char append) {\n            appendAttributeValue(String.valueOf(append));\n        }\n    }\n\n    static class StartTag extends Tag {\n        StartTag() {\n            super();\n            attributes = new Attributes();\n            type = TokenType.StartTag;\n        }\n\n        StartTag(String name) {\n            this();\n            this.tagName = name;\n        }\n\n        StartTag(String name, Attributes attributes) {\n            this();\n            this.tagName = name;\n            this.attributes = attributes;\n        }\n\n        @Override\n        public String toString() {\n            if (attributes != null && attributes.size() > 0)\n                return \"<\" + name() + \" \" + attributes.toString() + \">\";\n            else\n                return \"<\" + name() + \">\";\n        }\n    }\n\n    static class EndTag extends Tag{\n        EndTag() {\n            super();\n            type = TokenType.EndTag;\n        }\n\n        EndTag(String name) {\n            this();\n            this.tagName = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"</\" + name() + \">\";\n        }\n    }\n\n    static class Comment extends Token {\n        final StringBuilder data = new StringBuilder();\n        boolean bogus = false;\n\n        Comment() {\n            type = TokenType.Comment;\n        }\n\n        String getData() {\n            return data.toString();\n        }\n\n        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }\n    }\n\n    static class Character extends Token {\n        private final String data;\n\n        Character(String data) {\n            type = TokenType.Character;\n            this.data = data;\n        }\n\n        String getData() {\n            return data;\n        }\n\n        @Override\n        public String toString() {\n            return getData();\n        }\n    }\n\n    static class EOF extends Token {\n        EOF() {\n            type = Token.TokenType.EOF;\n        }\n    }\n\n    boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }\n\n    Doctype asDoctype() {\n        return (Doctype) this;\n    }\n\n    boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }\n\n    StartTag asStartTag() {\n        return (StartTag) this;\n    }\n\n    boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }\n\n    EndTag asEndTag() {\n        return (EndTag) this;\n    }\n\n    boolean isComment() {\n        return type == TokenType.Comment;\n    }\n\n    Comment asComment() {\n        return (Comment) this;\n    }\n\n    boolean isCharacter() {\n        return type == TokenType.Character;\n    }\n\n    Character asCharacter() {\n        return (Character) this;\n    }\n\n    boolean isEOF() {\n        return type == TokenType.EOF;\n    }\n\n    enum TokenType {\n        Doctype,\n        StartTag,\n        EndTag,\n        Comment,\n        Character,\n        EOF\n    }\n}"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "            if (attributes == null)",
        "line": 56,
        "aftercode": "if((pendingAttributeName != null)){"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                attributes.put(attribute);",
        "line": 65,
        "aftercode": "attributes.put();"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());",
        "line": 64,
        "aftercode": "attribute = new Attribute();"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());",
        "line": 64,
        "aftercode": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\n\n/**\n * Parse tokens for the Tokeniser.\n */\nabstract class Token {\n    TokenType type;\n\n    private Token() {\n    }\n    \n    String tokenType() {\n        return this.getClass().getSimpleName();\n    }\n\n    static class Doctype extends Token {\n        final StringBuilder name = new StringBuilder();\n        final StringBuilder publicIdentifier = new StringBuilder();\n        final StringBuilder systemIdentifier = new StringBuilder();\n        boolean forceQuirks = false;\n\n        Doctype() {\n            type = TokenType.Doctype;\n        }\n\n        String getName() {\n            return name.toString();\n        }\n\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }\n\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }\n\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }\n    }\n\n    static abstract class Tag extends Token {\n        protected String tagName;\n        private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n        private StringBuilder pendingAttributeValue; // but values are accumulated, from e.g. & in hrefs\n\n        boolean selfClosing = false;\n        Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n\n        void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                Attribute attribute;\n                if (pendingAttributeValue == null)\n                    attribute = new Attribute(pendingAttributeName, \"\");\n                else\nattribute = new Attribute(pendingAttributeValue.toString());\n                attributes.put(attribute);\n            }\n            pendingAttributeName = null;\n            if (pendingAttributeValue != null)\n\npendingAttributeValue.delete(pendingAttributeValue.length());\n        }\n\n        void finaliseTag() {\n            // finalises for emit\n            if (pendingAttributeName != null) {\n                // todo: check if attribute name exists; if so, drop and error\n                newAttribute();\n            }\n        }\n\n        String name() {\n            Validate.isFalse(tagName.length() == 0);\n            return tagName;\n        }\n\n        Tag name(String name) {\n            tagName = name;\n            return this;\n        }\n\n        boolean isSelfClosing() {\n            return selfClosing;\n        }\n\n        @SuppressWarnings({\"TypeMayBeWeakened\"})\n        Attributes getAttributes() {\n            return attributes;\n        }\n\n        // these appenders are rarely hit in not null state-- caused by null chars.\n        void appendTagName(String append) {\n            tagName = tagName == null ? append : tagName.concat(append);\n        }\n\n        void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }\n\n        void appendAttributeName(String append) {\n            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n        }\n\n        void appendAttributeName(char append) {\n            appendAttributeName(String.valueOf(append));\n        }\n\n        void appendAttributeValue(String append) {\n            pendingAttributeValue = pendingAttributeValue == null ? new StringBuilder(append) : pendingAttributeValue.append(append);\n        }\n\n        void appendAttributeValue(char append) {\n            appendAttributeValue(String.valueOf(append));\n        }\n    }\n\n    static class StartTag extends Tag {\n        StartTag() {\n            super();\n            attributes = new Attributes();\n            type = TokenType.StartTag;\n        }\n\n        StartTag(String name) {\n            this();\n            this.tagName = name;\n        }\n\n        StartTag(String name, Attributes attributes) {\n            this();\n            this.tagName = name;\n            this.attributes = attributes;\n        }\n\n        @Override\n        public String toString() {\n            if (attributes != null && attributes.size() > 0)\n                return \"<\" + name() + \" \" + attributes.toString() + \">\";\n            else\n                return \"<\" + name() + \">\";\n        }\n    }\n\n    static class EndTag extends Tag{\n        EndTag() {\n            super();\n            type = TokenType.EndTag;\n        }\n\n        EndTag(String name) {\n            this();\n            this.tagName = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"</\" + name() + \">\";\n        }\n    }\n\n    static class Comment extends Token {\n        final StringBuilder data = new StringBuilder();\n        boolean bogus = false;\n\n        Comment() {\n            type = TokenType.Comment;\n        }\n\n        String getData() {\n            return data.toString();\n        }\n\n        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }\n    }\n\n    static class Character extends Token {\n        private final String data;\n\n        Character(String data) {\n            type = TokenType.Character;\n            this.data = data;\n        }\n\n        String getData() {\n            return data;\n        }\n\n        @Override\n        public String toString() {\n            return getData();\n        }\n    }\n\n    static class EOF extends Token {\n        EOF() {\n            type = Token.TokenType.EOF;\n        }\n    }\n\n    boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }\n\n    Doctype asDoctype() {\n        return (Doctype) this;\n    }\n\n    boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }\n\n    StartTag asStartTag() {\n        return (StartTag) this;\n    }\n\n    boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }\n\n    EndTag asEndTag() {\n        return (EndTag) this;\n    }\n\n    boolean isComment() {\n        return type == TokenType.Comment;\n    }\n\n    Comment asComment() {\n        return (Comment) this;\n    }\n\n    boolean isCharacter() {\n        return type == TokenType.Character;\n    }\n\n    Character asCharacter() {\n        return (Character) this;\n    }\n\n    boolean isEOF() {\n        return type == TokenType.EOF;\n    }\n\n    enum TokenType {\n        Doctype,\n        StartTag,\n        EndTag,\n        Comment,\n        Character,\n        EOF\n    }\n}"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                if (pendingAttributeValue == null)",
        "line": 61,
        "aftercode": "if((pendingAttributeValue != null)){"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, \"\");",
        "line": 62,
        "aftercode": "attribute = new Attribute();"
    },
    {
        "id": 29,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "            appendAttributeName(String.valueOf(append));",
        "line": 113,
        "aftercode": "appendAttributeName((int)String.valueOf(append));"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());",
        "line": 64,
        "aftercode": "pendingAttributeName = null;"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "            pendingAttributeName = null;",
        "line": 67,
        "aftercode": "attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());"
    },
    {
        "id": 8,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "                Attribute attribute;",
        "line": 60,
        "aftercode": "Attribute attribute = ;"
    },
    {
        "id": 29,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "            appendAttributeName(String.valueOf(append));",
        "line": 113,
        "aftercode": "appendAttributeName(append.toString());"
    },
    {
        "id": 29,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_31_fixed/src/main/java/org/jsoup/parser/Token.java",
        "precode": "            appendAttributeName(String.valueOf(append));",
        "line": 113,
        "aftercode": "super.appendAttributeName(append);"
    }
]