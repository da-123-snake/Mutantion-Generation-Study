[
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 120,
        "aftercode": "checkCapacity();"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(\"null\"));"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(\"null\"));"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document());"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "    int indexOfKey(String key) {",
        "line": 71,
        "aftercode": ""
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        Validate.notNull(key);",
        "line": 72,
        "aftercode": "Validate.notNull();"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 120,
        "aftercode": "checkCapacity(\"null\");"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document());"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        Validate.notNull(key);",
        "line": 72,
        "aftercode": "key.notNull();"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        Validate.notNull(key);",
        "line": 72,
        "aftercode": "this.key = key;"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        Validate.notNull(key);",
        "line": 72,
        "aftercode": "notNull();"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "    public Attributes add(String key, String value) {",
        "line": 119,
        "aftercode": ""
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        Validate.notNull(key);",
        "line": 72,
        "aftercode": "notNull(key);"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 120,
        "aftercode": "size[size];"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 120,
        "aftercode": "this.size;"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb);"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 120,
        "aftercode": "this.size.checkCapacity((size + 1));"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "    public Attributes add(String key, String value) {",
        "line": 119,
        "aftercode": ""
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            if (key.equals(keys[i]))",
        "line": 74,
        "aftercode": "if(key.equals(\"null\")){"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(\"null\"));"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 120,
        "aftercode": "checkCapacity((\"null\" + size));"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document());"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 122,
        "aftercode": "package org.jsoup.nodes;\n\nimport org.jsoup.SerializationException;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.parser.ParseSettings;\n\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.jsoup.internal.Normalizer.lowerCase;\n\n/**\n * The attributes of an Element.\n * <p>\n * Attributes are treated as a map: there can be only one value associated with an attribute key/name.\n * </p>\n * <p>\n * Attribute name and value comparisons are  generally <b>case sensitive</b>. By default for HTML, attribute names are\n * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by\n * name.\n * </p>\n *\n * @author Jonathan Hedley, jonathan@hedley.net\n */\npublic class Attributes implements Iterable<Attribute>, Cloneable {\n    protected static final String dataPrefix = \"data-\";\n    private static final int InitialCapacity = 4; // todo - analyze Alexa 1MM sites, determine best setting\n\n    // manages the key/val arrays\n    private static final int GrowthFactor = 2;\n    private static final String[] Empty = {};\n    static final int NotFound = -1;\n    private static final String EmptyString = \"\";\n\n    private int size = 0; // number of slots used (not capacity, which is keys.length\n    String[] keys = Empty;\n    String[] vals = Empty;\n\n    // check there's room for more\n    private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }\n\n    // simple implementation of Arrays.copy, for support of Android API 8.\n    private static String[] copyOf(String[] orig, int size) {\n        final String[] copy = new String[size];\n        System.arraycopy(orig, 0, copy, 0,\n                Math.min(orig.length, size));\n        return copy;\n    }\n\n    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    // we track boolean attributes as null in values - they're just keys. so returns empty for consumers\n    static String checkNotNull(String val) {\n        return val == null ? EmptyString : val;\n    }\n\n    /**\n     Get an attribute value by key.\n     @param key the (case-sensitive) attribute key\n     @return the attribute value if set; or empty string if not set (or a boolean attribute).\n     @see #hasKey(String)\n     */\n    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Get an attribute's value by case-insensitive key\n     * @param key the attribute name\n     * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).\n     */\n    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Adds a new attribute. Will produce duplicates if the key already exists.\n     * @see Attributes#put(String, String)\n     */\n    public Attributes add(String key, String value) {\ncheckCapacity();\n        keys[size] = key;\n\ncheckCapacity();\n        size++;\n        return this;\n    }\n\n    /**\n     * Set a new attribute, or replace an existing one by key.\n     * @param key case sensitive attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, String value) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }\n\n    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) // case changed, update\n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }\n\n    /**\n     * Set a new boolean attribute, remove attribute if value is false.\n     * @param key case <b>insensitive</b> attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }\n\n    /**\n     Set a new attribute, or replace an existing one by key.\n     @param attribute attribute with case sensitive key\n     @return these attributes, for chaining\n     */\n    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }\n\n    // removes and shifts up\n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; // release hold\n        vals[size] = null;\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }\n\n    /**\n     Get the number of attributes in this set.\n     @return size\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Test if this Attributes list is empty (size==0).\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     Add all the attributes from the incoming set to this set.\n     @param incoming attributes to add to these attributes.\n     */\n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        for (Attribute attr : incoming) {\n            // todo - should this be case insensitive?\n            put(attr);\n        }\n\n    }\n\n    public Iterator<Attribute> iterator() {\n        return new Iterator<Attribute>() {\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); // next() advanced, so rewind\n            }\n        };\n    }\n\n    /**\n     Get the attributes as a List, for iteration.\n     @return an view of the attributes as an unmodifialbe List.\n     */\n    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : // deprecated class, but maybe someone still wants it\n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Retrieves a filtered view of attributes that are HTML5 custom data attributes; that is, attributes with keys\n     * starting with {@code data-}.\n     * @return map of custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }\n\n    /**\n     Get the HTML representation of these attributes.\n     @return HTML\n     @throws SerializationException if the HTML representation of the attributes cannot be constructed.\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\n            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n        } catch (IOException e) { // ought never happen\n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            // inlined from Attribute.html()\n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            // collapse checked=null, checked=\"\", checked=checked; write out others\n            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    /**\n     * Checks if these attributes are equal to another set of attributes, by comparing the two sets\n     * @param o attributes to compare with\n     * @return if both sets of attributes have the same content\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }\n\n    /**\n     * Calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.\n     * @return calculated hashcode\n     */\n    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }\n\n    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }\n\n    /**\n     * Internal method. Lowercases all keys.\n     */\n    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }\n\n    /**\n     * Internal method. Removes duplicate attribute by name. Settings for case sensitivity of key names.\n     * @param settings case sensitivity\n     * @return number of removed dupes\n     */\n    public int deduplicate(ParseSettings settings) {\n        if (isEmpty())\n            return 0;\n        boolean preserve = settings.preserveAttributeCase();\n        int dupes = 0;\n        OUTER: for (int i = 0; i < keys.length; i++) {\n            for (int j = i + 1; j < keys.length; j++) {\n                if (keys[j] == null)\n                    continue OUTER; // keys.length doesn't shrink when removing, so re-test\n                if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) {\n                    dupes++;\n                    remove(j);\n                    j--;\n                }\n            }\n        }\n        return dupes;\n    }\n\n    private static class Dataset extends AbstractMap<String, String> {\n        private final Attributes attributes;\n\n        private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> {\n\n            @Override\n            public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> {\n            private Iterator<Attribute> attrIter = attributes.iterator();\n            private Attribute attr;\n            public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n}"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(\"null\"));"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(e));"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "sb.html(sb, new Document(\"null\"));"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 120,
        "aftercode": "this;"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "    int indexOfKey(String key) {",
        "line": 71,
        "aftercode": ""
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(\"null\"));"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 120,
        "aftercode": "this.size.checkCapacity(size);"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(e);"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(\"null\"));"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "package org.jsoup.nodes;\n\nimport org.jsoup.SerializationException;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.parser.ParseSettings;\n\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.jsoup.internal.Normalizer.lowerCase;\n\n/**\n * The attributes of an Element.\n * <p>\n * Attributes are treated as a map: there can be only one value associated with an attribute key/name.\n * </p>\n * <p>\n * Attribute name and value comparisons are  generally <b>case sensitive</b>. By default for HTML, attribute names are\n * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by\n * name.\n * </p>\n *\n * @author Jonathan Hedley, jonathan@hedley.net\n */\npublic class Attributes implements Iterable<Attribute>, Cloneable {\n    protected static final String dataPrefix = \"data-\";\n    private static final int InitialCapacity = 4; // todo - analyze Alexa 1MM sites, determine best setting\n\n    // manages the key/val arrays\n    private static final int GrowthFactor = 2;\n    private static final String[] Empty = {};\n    static final int NotFound = -1;\n    private static final String EmptyString = \"\";\n\n    private int size = 0; // number of slots used (not capacity, which is keys.length\n    String[] keys = Empty;\n    String[] vals = Empty;\n\n    // check there's room for more\n    private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }\n\n    // simple implementation of Arrays.copy, for support of Android API 8.\n    private static String[] copyOf(String[] orig, int size) {\n        final String[] copy = new String[size];\n        System.arraycopy(orig, 0, copy, 0,\n                Math.min(orig.length, size));\n        return copy;\n    }\n\n    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    // we track boolean attributes as null in values - they're just keys. so returns empty for consumers\n    static String checkNotNull(String val) {\n        return val == null ? EmptyString : val;\n    }\n\n    /**\n     Get an attribute value by key.\n     @param key the (case-sensitive) attribute key\n     @return the attribute value if set; or empty string if not set (or a boolean attribute).\n     @see #hasKey(String)\n     */\n    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Get an attribute's value by case-insensitive key\n     * @param key the attribute name\n     * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).\n     */\n    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Adds a new attribute. Will produce duplicates if the key already exists.\n     * @see Attributes#put(String, String)\n     */\n    public Attributes add(String key, String value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n        return this;\n    }\n\n    /**\n     * Set a new attribute, or replace an existing one by key.\n     * @param key case sensitive attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, String value) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }\n\n    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) // case changed, update\n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }\n\n    /**\n     * Set a new boolean attribute, remove attribute if value is false.\n     * @param key case <b>insensitive</b> attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }\n\n    /**\n     Set a new attribute, or replace an existing one by key.\n     @param attribute attribute with case sensitive key\n     @return these attributes, for chaining\n     */\n    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }\n\n    // removes and shifts up\n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; // release hold\n        vals[size] = null;\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }\n\n    /**\n     Get the number of attributes in this set.\n     @return size\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Test if this Attributes list is empty (size==0).\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     Add all the attributes from the incoming set to this set.\n     @param incoming attributes to add to these attributes.\n     */\n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        for (Attribute attr : incoming) {\n            // todo - should this be case insensitive?\n            put(attr);\n        }\n\n    }\n\n    public Iterator<Attribute> iterator() {\n        return new Iterator<Attribute>() {\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); // next() advanced, so rewind\n            }\n        };\n    }\n\n    /**\n     Get the attributes as a List, for iteration.\n     @return an view of the attributes as an unmodifialbe List.\n     */\n    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : // deprecated class, but maybe someone still wants it\n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Retrieves a filtered view of attributes that are HTML5 custom data attributes; that is, attributes with keys\n     * starting with {@code data-}.\n     * @return map of custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }\n\n    /**\n     Get the HTML representation of these attributes.\n     @return HTML\n     @throws SerializationException if the HTML representation of the attributes cannot be constructed.\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\nhtml(sb, new Document(\"null\"));\n        } catch (IOException e) { // ought never happen\n            throw new SerializationException(e);\n        }\n\nStringUtil.releaseBuilder(sb);\n    }\n\n    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            // inlined from Attribute.html()\n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            // collapse checked=null, checked=\"\", checked=checked; write out others\n            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    /**\n     * Checks if these attributes are equal to another set of attributes, by comparing the two sets\n     * @param o attributes to compare with\n     * @return if both sets of attributes have the same content\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }\n\n    /**\n     * Calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.\n     * @return calculated hashcode\n     */\n    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }\n\n    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }\n\n    /**\n     * Internal method. Lowercases all keys.\n     */\n    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }\n\n    /**\n     * Internal method. Removes duplicate attribute by name. Settings for case sensitivity of key names.\n     * @param settings case sensitivity\n     * @return number of removed dupes\n     */\n    public int deduplicate(ParseSettings settings) {\n        if (isEmpty())\n            return 0;\n        boolean preserve = settings.preserveAttributeCase();\n        int dupes = 0;\n        OUTER: for (int i = 0; i < keys.length; i++) {\n            for (int j = i + 1; j < keys.length; j++) {\n                if (keys[j] == null)\n                    continue OUTER; // keys.length doesn't shrink when removing, so re-test\n                if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) {\n                    dupes++;\n                    remove(j);\n                    j--;\n                }\n            }\n        }\n        return dupes;\n    }\n\n    private static class Dataset extends AbstractMap<String, String> {\n        private final Attributes attributes;\n\n        private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> {\n\n            @Override\n            public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> {\n            private Iterator<Attribute> attrIter = attributes.iterator();\n            private Attribute attr;\n            public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n}"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        Validate.notNull(key);",
        "line": 72,
        "aftercode": "key = Validate.notNull(key);"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(\"null\"));"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(\"null\"));"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(\"null\"));"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 120,
        "aftercode": "checkCapacity((\"null\" + 1));"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(e));"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "    int indexOfKey(String key) {",
        "line": 71,
        "aftercode": ""
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(\"null\"));"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "sb.html(sb);"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        vals[size] = value;",
        "line": 122,
        "aftercode": "value++;"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "package org.jsoup.nodes;\n\nimport org.jsoup.SerializationException;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.parser.ParseSettings;\n\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.jsoup.internal.Normalizer.lowerCase;\n\n/**\n * The attributes of an Element.\n * <p>\n * Attributes are treated as a map: there can be only one value associated with an attribute key/name.\n * </p>\n * <p>\n * Attribute name and value comparisons are  generally <b>case sensitive</b>. By default for HTML, attribute names are\n * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by\n * name.\n * </p>\n *\n * @author Jonathan Hedley, jonathan@hedley.net\n */\npublic class Attributes implements Iterable<Attribute>, Cloneable {\n    protected static final String dataPrefix = \"data-\";\n    private static final int InitialCapacity = 4; // todo - analyze Alexa 1MM sites, determine best setting\n\n    // manages the key/val arrays\n    private static final int GrowthFactor = 2;\n    private static final String[] Empty = {};\n    static final int NotFound = -1;\n    private static final String EmptyString = \"\";\n\n    private int size = 0; // number of slots used (not capacity, which is keys.length\n    String[] keys = Empty;\n    String[] vals = Empty;\n\n    // check there's room for more\n    private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }\n\n    // simple implementation of Arrays.copy, for support of Android API 8.\n    private static String[] copyOf(String[] orig, int size) {\n        final String[] copy = new String[size];\n        System.arraycopy(orig, 0, copy, 0,\n                Math.min(orig.length, size));\n        return copy;\n    }\n\n    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    // we track boolean attributes as null in values - they're just keys. so returns empty for consumers\n    static String checkNotNull(String val) {\n        return val == null ? EmptyString : val;\n    }\n\n    /**\n     Get an attribute value by key.\n     @param key the (case-sensitive) attribute key\n     @return the attribute value if set; or empty string if not set (or a boolean attribute).\n     @see #hasKey(String)\n     */\n    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Get an attribute's value by case-insensitive key\n     * @param key the attribute name\n     * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).\n     */\n    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Adds a new attribute. Will produce duplicates if the key already exists.\n     * @see Attributes#put(String, String)\n     */\n    public Attributes add(String key, String value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n        return this;\n    }\n\n    /**\n     * Set a new attribute, or replace an existing one by key.\n     * @param key case sensitive attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, String value) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }\n\n    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) // case changed, update\n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }\n\n    /**\n     * Set a new boolean attribute, remove attribute if value is false.\n     * @param key case <b>insensitive</b> attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }\n\n    /**\n     Set a new attribute, or replace an existing one by key.\n     @param attribute attribute with case sensitive key\n     @return these attributes, for chaining\n     */\n    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }\n\n    // removes and shifts up\n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; // release hold\n        vals[size] = null;\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }\n\n    /**\n     Get the number of attributes in this set.\n     @return size\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Test if this Attributes list is empty (size==0).\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     Add all the attributes from the incoming set to this set.\n     @param incoming attributes to add to these attributes.\n     */\n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        for (Attribute attr : incoming) {\n            // todo - should this be case insensitive?\n            put(attr);\n        }\n\n    }\n\n    public Iterator<Attribute> iterator() {\n        return new Iterator<Attribute>() {\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); // next() advanced, so rewind\n            }\n        };\n    }\n\n    /**\n     Get the attributes as a List, for iteration.\n     @return an view of the attributes as an unmodifialbe List.\n     */\n    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : // deprecated class, but maybe someone still wants it\n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Retrieves a filtered view of attributes that are HTML5 custom data attributes; that is, attributes with keys\n     * starting with {@code data-}.\n     * @return map of custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }\n\n    /**\n     Get the HTML representation of these attributes.\n     @return HTML\n     @throws SerializationException if the HTML representation of the attributes cannot be constructed.\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\nhtml(sb);\n        } catch (IOException e) { // ought never happen\n            throw new SerializationException(e);\n        }\n\nStringUtil.releaseBuilder(sb);\n    }\n\n    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            // inlined from Attribute.html()\n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            // collapse checked=null, checked=\"\", checked=checked; write out others\n            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    /**\n     * Checks if these attributes are equal to another set of attributes, by comparing the two sets\n     * @param o attributes to compare with\n     * @return if both sets of attributes have the same content\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }\n\n    /**\n     * Calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.\n     * @return calculated hashcode\n     */\n    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }\n\n    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }\n\n    /**\n     * Internal method. Lowercases all keys.\n     */\n    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }\n\n    /**\n     * Internal method. Removes duplicate attribute by name. Settings for case sensitivity of key names.\n     * @param settings case sensitivity\n     * @return number of removed dupes\n     */\n    public int deduplicate(ParseSettings settings) {\n        if (isEmpty())\n            return 0;\n        boolean preserve = settings.preserveAttributeCase();\n        int dupes = 0;\n        OUTER: for (int i = 0; i < keys.length; i++) {\n            for (int j = i + 1; j < keys.length; j++) {\n                if (keys[j] == null)\n                    continue OUTER; // keys.length doesn't shrink when removing, so re-test\n                if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) {\n                    dupes++;\n                    remove(j);\n                    j--;\n                }\n            }\n        }\n        return dupes;\n    }\n\n    private static class Dataset extends AbstractMap<String, String> {\n        private final Attributes attributes;\n\n        private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> {\n\n            @Override\n            public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> {\n            private Iterator<Attribute> attrIter = attributes.iterator();\n            private Attribute attr;\n            public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n}"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        StringBuilder sb = StringUtil.borrowBuilder();",
        "line": 314,
        "aftercode": "StringBuilder sb = borrowBuilder();"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        vals[size] = value;",
        "line": 122,
        "aftercode": "vals[size];"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            if (key.equals(keys[i]))",
        "line": 74,
        "aftercode": "if(key.equals(i)){"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        Validate.notNull(key);",
        "line": 72,
        "aftercode": "Validate.notNull((int)key);"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document());"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        Validate.notNull(key);",
        "line": 72,
        "aftercode": "Validate.notNull(key, 0);"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb);"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(sb));"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            if (key.equals(keys[i]))",
        "line": 74,
        "aftercode": ""
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        StringBuilder sb = StringUtil.borrowBuilder();",
        "line": 314,
        "aftercode": "StringBuilder sb = \"null\";"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb);"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        Validate.notNull(key);",
        "line": 72,
        "aftercode": "Validate.notNull(String);"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb, new Document(\"null\"));"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(sb);"
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": ""
    },
    {
        "id": 32,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used",
        "line": 316,
        "aftercode": "html(\"null\");"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 120,
        "aftercode": "checkCapacity((size + \"null\"));"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        Validate.notNull(key);",
        "line": 75,
        "aftercode": "package org.jsoup.nodes;\n\nimport org.jsoup.SerializationException;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.parser.ParseSettings;\n\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.jsoup.internal.Normalizer.lowerCase;\n\n/**\n * The attributes of an Element.\n * <p>\n * Attributes are treated as a map: there can be only one value associated with an attribute key/name.\n * </p>\n * <p>\n * Attribute name and value comparisons are  generally <b>case sensitive</b>. By default for HTML, attribute names are\n * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by\n * name.\n * </p>\n *\n * @author Jonathan Hedley, jonathan@hedley.net\n */\npublic class Attributes implements Iterable<Attribute>, Cloneable {\n    protected static final String dataPrefix = \"data-\";\n    private static final int InitialCapacity = 4; // todo - analyze Alexa 1MM sites, determine best setting\n\n    // manages the key/val arrays\n    private static final int GrowthFactor = 2;\n    private static final String[] Empty = {};\n    static final int NotFound = -1;\n    private static final String EmptyString = \"\";\n\n    private int size = 0; // number of slots used (not capacity, which is keys.length\n    String[] keys = Empty;\n    String[] vals = Empty;\n\n    // check there's room for more\n    private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }\n\n    // simple implementation of Arrays.copy, for support of Android API 8.\n    private static String[] copyOf(String[] orig, int size) {\n        final String[] copy = new String[size];\n        System.arraycopy(orig, 0, copy, 0,\n                Math.min(orig.length, size));\n        return copy;\n    }\n\n    int indexOfKey(String key) {\nif(Validate.equals(key)){\n        Validate.notNull(key);        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n}\n    }\n\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    // we track boolean attributes as null in values - they're just keys. so returns empty for consumers\n    static String checkNotNull(String val) {\n        return val == null ? EmptyString : val;\n    }\n\n    /**\n     Get an attribute value by key.\n     @param key the (case-sensitive) attribute key\n     @return the attribute value if set; or empty string if not set (or a boolean attribute).\n     @see #hasKey(String)\n     */\n    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Get an attribute's value by case-insensitive key\n     * @param key the attribute name\n     * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).\n     */\n    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Adds a new attribute. Will produce duplicates if the key already exists.\n     * @see Attributes#put(String, String)\n     */\n    public Attributes add(String key, String value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n        return this;\n    }\n\n    /**\n     * Set a new attribute, or replace an existing one by key.\n     * @param key case sensitive attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, String value) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }\n\n    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) // case changed, update\n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }\n\n    /**\n     * Set a new boolean attribute, remove attribute if value is false.\n     * @param key case <b>insensitive</b> attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }\n\n    /**\n     Set a new attribute, or replace an existing one by key.\n     @param attribute attribute with case sensitive key\n     @return these attributes, for chaining\n     */\n    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }\n\n    // removes and shifts up\n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; // release hold\n        vals[size] = null;\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }\n\n    /**\n     Get the number of attributes in this set.\n     @return size\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Test if this Attributes list is empty (size==0).\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     Add all the attributes from the incoming set to this set.\n     @param incoming attributes to add to these attributes.\n     */\n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        for (Attribute attr : incoming) {\n            // todo - should this be case insensitive?\n            put(attr);\n        }\n\n    }\n\n    public Iterator<Attribute> iterator() {\n        return new Iterator<Attribute>() {\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); // next() advanced, so rewind\n            }\n        };\n    }\n\n    /**\n     Get the attributes as a List, for iteration.\n     @return an view of the attributes as an unmodifialbe List.\n     */\n    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : // deprecated class, but maybe someone still wants it\n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Retrieves a filtered view of attributes that are HTML5 custom data attributes; that is, attributes with keys\n     * starting with {@code data-}.\n     * @return map of custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }\n\n    /**\n     Get the HTML representation of these attributes.\n     @return HTML\n     @throws SerializationException if the HTML representation of the attributes cannot be constructed.\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\n            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n        } catch (IOException e) { // ought never happen\n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            // inlined from Attribute.html()\n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            // collapse checked=null, checked=\"\", checked=checked; write out others\n            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    /**\n     * Checks if these attributes are equal to another set of attributes, by comparing the two sets\n     * @param o attributes to compare with\n     * @return if both sets of attributes have the same content\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }\n\n    /**\n     * Calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.\n     * @return calculated hashcode\n     */\n    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }\n\n    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }\n\n    /**\n     * Internal method. Lowercases all keys.\n     */\n    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }\n\n    /**\n     * Internal method. Removes duplicate attribute by name. Settings for case sensitivity of key names.\n     * @param settings case sensitivity\n     * @return number of removed dupes\n     */\n    public int deduplicate(ParseSettings settings) {\n        if (isEmpty())\n            return 0;\n        boolean preserve = settings.preserveAttributeCase();\n        int dupes = 0;\n        OUTER: for (int i = 0; i < keys.length; i++) {\n            for (int j = i + 1; j < keys.length; j++) {\n                if (keys[j] == null)\n                    continue OUTER; // keys.length doesn't shrink when removing, so re-test\n                if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) {\n                    dupes++;\n                    remove(j);\n                    j--;\n                }\n            }\n        }\n        return dupes;\n    }\n\n    private static class Dataset extends AbstractMap<String, String> {\n        private final Attributes attributes;\n\n        private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> {\n\n            @Override\n            public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> {\n            private Iterator<Attribute> attrIter = attributes.iterator();\n            private Attribute attr;\n            public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n}"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        keys[size] = key;",
        "line": 121,
        "aftercode": "key++;"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 120,
        "aftercode": "checkCapacity(key);"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 122,
        "aftercode": "package org.jsoup.nodes;\n\nimport org.jsoup.SerializationException;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.parser.ParseSettings;\n\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.jsoup.internal.Normalizer.lowerCase;\n\n/**\n * The attributes of an Element.\n * <p>\n * Attributes are treated as a map: there can be only one value associated with an attribute key/name.\n * </p>\n * <p>\n * Attribute name and value comparisons are  generally <b>case sensitive</b>. By default for HTML, attribute names are\n * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by\n * name.\n * </p>\n *\n * @author Jonathan Hedley, jonathan@hedley.net\n */\npublic class Attributes implements Iterable<Attribute>, Cloneable {\n    protected static final String dataPrefix = \"data-\";\n    private static final int InitialCapacity = 4; // todo - analyze Alexa 1MM sites, determine best setting\n\n    // manages the key/val arrays\n    private static final int GrowthFactor = 2;\n    private static final String[] Empty = {};\n    static final int NotFound = -1;\n    private static final String EmptyString = \"\";\n\n    private int size = 0; // number of slots used (not capacity, which is keys.length\n    String[] keys = Empty;\n    String[] vals = Empty;\n\n    // check there's room for more\n    private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }\n\n    // simple implementation of Arrays.copy, for support of Android API 8.\n    private static String[] copyOf(String[] orig, int size) {\n        final String[] copy = new String[size];\n        System.arraycopy(orig, 0, copy, 0,\n                Math.min(orig.length, size));\n        return copy;\n    }\n\n    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    // we track boolean attributes as null in values - they're just keys. so returns empty for consumers\n    static String checkNotNull(String val) {\n        return val == null ? EmptyString : val;\n    }\n\n    /**\n     Get an attribute value by key.\n     @param key the (case-sensitive) attribute key\n     @return the attribute value if set; or empty string if not set (or a boolean attribute).\n     @see #hasKey(String)\n     */\n    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Get an attribute's value by case-insensitive key\n     * @param key the attribute name\n     * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).\n     */\n    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Adds a new attribute. Will produce duplicates if the key already exists.\n     * @see Attributes#put(String, String)\n     */\n    public Attributes add(String key, String value) {\ncheckCapacity();\n        keys[size] = key;\n        vals[size] = value;\n\nsize();\n        return this;\n    }\n\n    /**\n     * Set a new attribute, or replace an existing one by key.\n     * @param key case sensitive attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, String value) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }\n\n    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) // case changed, update\n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }\n\n    /**\n     * Set a new boolean attribute, remove attribute if value is false.\n     * @param key case <b>insensitive</b> attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }\n\n    /**\n     Set a new attribute, or replace an existing one by key.\n     @param attribute attribute with case sensitive key\n     @return these attributes, for chaining\n     */\n    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }\n\n    // removes and shifts up\n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; // release hold\n        vals[size] = null;\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }\n\n    /**\n     Get the number of attributes in this set.\n     @return size\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Test if this Attributes list is empty (size==0).\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     Add all the attributes from the incoming set to this set.\n     @param incoming attributes to add to these attributes.\n     */\n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        for (Attribute attr : incoming) {\n            // todo - should this be case insensitive?\n            put(attr);\n        }\n\n    }\n\n    public Iterator<Attribute> iterator() {\n        return new Iterator<Attribute>() {\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); // next() advanced, so rewind\n            }\n        };\n    }\n\n    /**\n     Get the attributes as a List, for iteration.\n     @return an view of the attributes as an unmodifialbe List.\n     */\n    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : // deprecated class, but maybe someone still wants it\n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Retrieves a filtered view of attributes that are HTML5 custom data attributes; that is, attributes with keys\n     * starting with {@code data-}.\n     * @return map of custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }\n\n    /**\n     Get the HTML representation of these attributes.\n     @return HTML\n     @throws SerializationException if the HTML representation of the attributes cannot be constructed.\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\n            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n        } catch (IOException e) { // ought never happen\n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            // inlined from Attribute.html()\n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            // collapse checked=null, checked=\"\", checked=checked; write out others\n            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    /**\n     * Checks if these attributes are equal to another set of attributes, by comparing the two sets\n     * @param o attributes to compare with\n     * @return if both sets of attributes have the same content\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }\n\n    /**\n     * Calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.\n     * @return calculated hashcode\n     */\n    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }\n\n    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }\n\n    /**\n     * Internal method. Lowercases all keys.\n     */\n    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }\n\n    /**\n     * Internal method. Removes duplicate attribute by name. Settings for case sensitivity of key names.\n     * @param settings case sensitivity\n     * @return number of removed dupes\n     */\n    public int deduplicate(ParseSettings settings) {\n        if (isEmpty())\n            return 0;\n        boolean preserve = settings.preserveAttributeCase();\n        int dupes = 0;\n        OUTER: for (int i = 0; i < keys.length; i++) {\n            for (int j = i + 1; j < keys.length; j++) {\n                if (keys[j] == null)\n                    continue OUTER; // keys.length doesn't shrink when removing, so re-test\n                if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) {\n                    dupes++;\n                    remove(j);\n                    j--;\n                }\n            }\n        }\n        return dupes;\n    }\n\n    private static class Dataset extends AbstractMap<String, String> {\n        private final Attributes attributes;\n\n        private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> {\n\n            @Override\n            public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> {\n            private Iterator<Attribute> attrIter = attributes.iterator();\n            private Attribute attr;\n            public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n}"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 122,
        "aftercode": "package org.jsoup.nodes;\n\nimport org.jsoup.SerializationException;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.parser.ParseSettings;\n\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.jsoup.internal.Normalizer.lowerCase;\n\n/**\n * The attributes of an Element.\n * <p>\n * Attributes are treated as a map: there can be only one value associated with an attribute key/name.\n * </p>\n * <p>\n * Attribute name and value comparisons are  generally <b>case sensitive</b>. By default for HTML, attribute names are\n * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by\n * name.\n * </p>\n *\n * @author Jonathan Hedley, jonathan@hedley.net\n */\npublic class Attributes implements Iterable<Attribute>, Cloneable {\n    protected static final String dataPrefix = \"data-\";\n    private static final int InitialCapacity = 4; // todo - analyze Alexa 1MM sites, determine best setting\n\n    // manages the key/val arrays\n    private static final int GrowthFactor = 2;\n    private static final String[] Empty = {};\n    static final int NotFound = -1;\n    private static final String EmptyString = \"\";\n\n    private int size = 0; // number of slots used (not capacity, which is keys.length\n    String[] keys = Empty;\n    String[] vals = Empty;\n\n    // check there's room for more\n    private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }\n\n    // simple implementation of Arrays.copy, for support of Android API 8.\n    private static String[] copyOf(String[] orig, int size) {\n        final String[] copy = new String[size];\n        System.arraycopy(orig, 0, copy, 0,\n                Math.min(orig.length, size));\n        return copy;\n    }\n\n    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    // we track boolean attributes as null in values - they're just keys. so returns empty for consumers\n    static String checkNotNull(String val) {\n        return val == null ? EmptyString : val;\n    }\n\n    /**\n     Get an attribute value by key.\n     @param key the (case-sensitive) attribute key\n     @return the attribute value if set; or empty string if not set (or a boolean attribute).\n     @see #hasKey(String)\n     */\n    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Get an attribute's value by case-insensitive key\n     * @param key the attribute name\n     * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).\n     */\n    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Adds a new attribute. Will produce duplicates if the key already exists.\n     * @see Attributes#put(String, String)\n     */\n    public Attributes add(String key, String value) {\nif(size){\n        checkCapacity(size + 1);        keys[size] = key;\n        vals[size] = value;\n        size++;\n        return this;\n}\n    }\n\n    /**\n     * Set a new attribute, or replace an existing one by key.\n     * @param key case sensitive attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, String value) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }\n\n    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) // case changed, update\n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }\n\n    /**\n     * Set a new boolean attribute, remove attribute if value is false.\n     * @param key case <b>insensitive</b> attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }\n\n    /**\n     Set a new attribute, or replace an existing one by key.\n     @param attribute attribute with case sensitive key\n     @return these attributes, for chaining\n     */\n    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }\n\n    // removes and shifts up\n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; // release hold\n        vals[size] = null;\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }\n\n    /**\n     Get the number of attributes in this set.\n     @return size\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Test if this Attributes list is empty (size==0).\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     Add all the attributes from the incoming set to this set.\n     @param incoming attributes to add to these attributes.\n     */\n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        for (Attribute attr : incoming) {\n            // todo - should this be case insensitive?\n            put(attr);\n        }\n\n    }\n\n    public Iterator<Attribute> iterator() {\n        return new Iterator<Attribute>() {\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); // next() advanced, so rewind\n            }\n        };\n    }\n\n    /**\n     Get the attributes as a List, for iteration.\n     @return an view of the attributes as an unmodifialbe List.\n     */\n    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : // deprecated class, but maybe someone still wants it\n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Retrieves a filtered view of attributes that are HTML5 custom data attributes; that is, attributes with keys\n     * starting with {@code data-}.\n     * @return map of custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }\n\n    /**\n     Get the HTML representation of these attributes.\n     @return HTML\n     @throws SerializationException if the HTML representation of the attributes cannot be constructed.\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\n            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n        } catch (IOException e) { // ought never happen\n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            // inlined from Attribute.html()\n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            // collapse checked=null, checked=\"\", checked=checked; write out others\n            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    /**\n     * Checks if these attributes are equal to another set of attributes, by comparing the two sets\n     * @param o attributes to compare with\n     * @return if both sets of attributes have the same content\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }\n\n    /**\n     * Calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.\n     * @return calculated hashcode\n     */\n    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }\n\n    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }\n\n    /**\n     * Internal method. Lowercases all keys.\n     */\n    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }\n\n    /**\n     * Internal method. Removes duplicate attribute by name. Settings for case sensitivity of key names.\n     * @param settings case sensitivity\n     * @return number of removed dupes\n     */\n    public int deduplicate(ParseSettings settings) {\n        if (isEmpty())\n            return 0;\n        boolean preserve = settings.preserveAttributeCase();\n        int dupes = 0;\n        OUTER: for (int i = 0; i < keys.length; i++) {\n            for (int j = i + 1; j < keys.length; j++) {\n                if (keys[j] == null)\n                    continue OUTER; // keys.length doesn't shrink when removing, so re-test\n                if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) {\n                    dupes++;\n                    remove(j);\n                    j--;\n                }\n            }\n        }\n        return dupes;\n    }\n\n    private static class Dataset extends AbstractMap<String, String> {\n        private final Attributes attributes;\n\n        private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> {\n\n            @Override\n            public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> {\n            private Iterator<Attribute> attrIter = attributes.iterator();\n            private Attribute attr;\n            public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n}"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 120,
        "aftercode": "\"null\";"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        Validate.notNull(key);",
        "line": 72,
        "aftercode": "Validate.notNull(Validate.notNull(key));"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 122,
        "aftercode": "package org.jsoup.nodes;\n\nimport org.jsoup.SerializationException;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.parser.ParseSettings;\n\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.jsoup.internal.Normalizer.lowerCase;\n\n/**\n * The attributes of an Element.\n * <p>\n * Attributes are treated as a map: there can be only one value associated with an attribute key/name.\n * </p>\n * <p>\n * Attribute name and value comparisons are  generally <b>case sensitive</b>. By default for HTML, attribute names are\n * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by\n * name.\n * </p>\n *\n * @author Jonathan Hedley, jonathan@hedley.net\n */\npublic class Attributes implements Iterable<Attribute>, Cloneable {\n    protected static final String dataPrefix = \"data-\";\n    private static final int InitialCapacity = 4; // todo - analyze Alexa 1MM sites, determine best setting\n\n    // manages the key/val arrays\n    private static final int GrowthFactor = 2;\n    private static final String[] Empty = {};\n    static final int NotFound = -1;\n    private static final String EmptyString = \"\";\n\n    private int size = 0; // number of slots used (not capacity, which is keys.length\n    String[] keys = Empty;\n    String[] vals = Empty;\n\n    // check there's room for more\n    private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }\n\n    // simple implementation of Arrays.copy, for support of Android API 8.\n    private static String[] copyOf(String[] orig, int size) {\n        final String[] copy = new String[size];\n        System.arraycopy(orig, 0, copy, 0,\n                Math.min(orig.length, size));\n        return copy;\n    }\n\n    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    // we track boolean attributes as null in values - they're just keys. so returns empty for consumers\n    static String checkNotNull(String val) {\n        return val == null ? EmptyString : val;\n    }\n\n    /**\n     Get an attribute value by key.\n     @param key the (case-sensitive) attribute key\n     @return the attribute value if set; or empty string if not set (or a boolean attribute).\n     @see #hasKey(String)\n     */\n    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Get an attribute's value by case-insensitive key\n     * @param key the attribute name\n     * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).\n     */\n    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Adds a new attribute. Will produce duplicates if the key already exists.\n     * @see Attributes#put(String, String)\n     */\n    public Attributes add(String key, String value) {\nif(!size){\n        checkCapacity(size + 1);        keys[size] = key;\n        vals[size] = value;\n        size++;\n        return this;\n}\n    }\n\n    /**\n     * Set a new attribute, or replace an existing one by key.\n     * @param key case sensitive attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, String value) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }\n\n    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) // case changed, update\n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }\n\n    /**\n     * Set a new boolean attribute, remove attribute if value is false.\n     * @param key case <b>insensitive</b> attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }\n\n    /**\n     Set a new attribute, or replace an existing one by key.\n     @param attribute attribute with case sensitive key\n     @return these attributes, for chaining\n     */\n    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }\n\n    // removes and shifts up\n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; // release hold\n        vals[size] = null;\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }\n\n    /**\n     Get the number of attributes in this set.\n     @return size\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Test if this Attributes list is empty (size==0).\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     Add all the attributes from the incoming set to this set.\n     @param incoming attributes to add to these attributes.\n     */\n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        for (Attribute attr : incoming) {\n            // todo - should this be case insensitive?\n            put(attr);\n        }\n\n    }\n\n    public Iterator<Attribute> iterator() {\n        return new Iterator<Attribute>() {\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); // next() advanced, so rewind\n            }\n        };\n    }\n\n    /**\n     Get the attributes as a List, for iteration.\n     @return an view of the attributes as an unmodifialbe List.\n     */\n    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : // deprecated class, but maybe someone still wants it\n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Retrieves a filtered view of attributes that are HTML5 custom data attributes; that is, attributes with keys\n     * starting with {@code data-}.\n     * @return map of custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }\n\n    /**\n     Get the HTML representation of these attributes.\n     @return HTML\n     @throws SerializationException if the HTML representation of the attributes cannot be constructed.\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\n            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n        } catch (IOException e) { // ought never happen\n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            // inlined from Attribute.html()\n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            // collapse checked=null, checked=\"\", checked=checked; write out others\n            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    /**\n     * Checks if these attributes are equal to another set of attributes, by comparing the two sets\n     * @param o attributes to compare with\n     * @return if both sets of attributes have the same content\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }\n\n    /**\n     * Calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.\n     * @return calculated hashcode\n     */\n    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }\n\n    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }\n\n    /**\n     * Internal method. Lowercases all keys.\n     */\n    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }\n\n    /**\n     * Internal method. Removes duplicate attribute by name. Settings for case sensitivity of key names.\n     * @param settings case sensitivity\n     * @return number of removed dupes\n     */\n    public int deduplicate(ParseSettings settings) {\n        if (isEmpty())\n            return 0;\n        boolean preserve = settings.preserveAttributeCase();\n        int dupes = 0;\n        OUTER: for (int i = 0; i < keys.length; i++) {\n            for (int j = i + 1; j < keys.length; j++) {\n                if (keys[j] == null)\n                    continue OUTER; // keys.length doesn't shrink when removing, so re-test\n                if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) {\n                    dupes++;\n                    remove(j);\n                    j--;\n                }\n            }\n        }\n        return dupes;\n    }\n\n    private static class Dataset extends AbstractMap<String, String> {\n        private final Attributes attributes;\n\n        private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> {\n\n            @Override\n            public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> {\n            private Iterator<Attribute> attrIter = attributes.iterator();\n            private Attribute attr;\n            public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n}"
    },
    {
        "id": 30,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        checkCapacity(size + 1);",
        "line": 120,
        "aftercode": "checkCapacity(checkCapacity((size + 1)));"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "            if (key.equals(keys[i]))",
        "line": 74,
        "aftercode": "if(i.equals(key)){"
    },
    {
        "id": 34,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_92_fixed/src/main/java/org/jsoup/nodes/Attributes.java",
        "precode": "        Validate.notNull(key);",
        "line": 72,
        "aftercode": "key.notNull(key);"
    }
]