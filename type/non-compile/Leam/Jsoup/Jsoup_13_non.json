[
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.isTrue(out.parentNode == this);",
        "line": 355,
        "aftercode": "Validate.isTrue(out.parentNode);"
    },
    {
        "id": 45,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "                    base = new URL(baseUri);",
        "line": 173,
        "aftercode": "base = new URL();"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.isTrue(out.parentNode == this);",
        "line": 355,
        "aftercode": "Validate.isTrue(out);"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        childNodes.set(index, in);",
        "line": 361,
        "aftercode": "childNodes.set(in);"
    },
    {
        "id": 45,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "                    return abs.toExternalForm();",
        "line": 177,
        "aftercode": "abs.toExternalForm();"
    },
    {
        "id": 45,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.notEmpty(attributeKey);",
        "line": 164,
        "aftercode": "Validate.notEmpty();"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.notNull(index);",
        "line": 438,
        "aftercode": "Validate.notNull();"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        childNodes.set(index, in);",
        "line": 361,
        "aftercode": "childNodes.set(index);"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "            return null;",
        "line": 442,
        "aftercode": "break;"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void replaceChild(Node out, Node in) {",
        "line": 354,
        "aftercode": "Node out        Validate.isTrue(out.parentNode == this);"
    },
    {
        "id": 45,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "                    return abs.toExternalForm();",
        "line": 177,
        "aftercode": "URL abs = new URL(relUrl);"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.isTrue(out.parentNode == this);",
        "line": 355,
        "aftercode": "Validate.isTrue(null);"
    },
    {
        "id": 45,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "                return \"\";",
        "line": 185,
        "aftercode": "relUrl = (base.getPath() + relUrl);"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.isTrue(out.parentNode == this);",
        "line": 355,
        "aftercode": "Validate.isTrue(in);"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.isTrue(out.parentNode == this);",
        "line": 355,
        "aftercode": "Validate.isTrue(index);"
    },
    {
        "id": 45,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "                    return abs.toExternalForm();",
        "line": 177,
        "aftercode": "abs.toExternalForm();"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.isTrue(out.parentNode == this);",
        "line": 355,
        "aftercode": "Validate.isTrue();"
    },
    {
        "id": 45,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "                    URL abs = new URL(relUrl);",
        "line": 176,
        "aftercode": "URL abs = new URL();"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.isTrue(out.parentNode == this);",
        "line": 355,
        "aftercode": "in.setSiblingIndex(index);"
    },
    {
        "id": 45,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "                    return abs.toExternalForm();",
        "line": 177,
        "aftercode": "break;"
    },
    {
        "id": 45,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "                if (relUrl.startsWith(\"?\"))",
        "line": 180,
        "aftercode": "URL abs = new URL(base, relUrl);"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        if (in.parentNode != null)",
        "line": 357,
        "aftercode": "if((in.parentNode != null)){"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        childNodes.set(index, in);",
        "line": 361,
        "aftercode": "set(index, in);"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.isTrue(out.parentNode == this);",
        "line": 360,
        "aftercode": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n The base, abstract Node model. Elements, Documents, Comments etc are all Node instances.\n\n @author Jonathan Hedley, jonathan@hedley.net */\npublic abstract class Node implements Cloneable {\n    Node parentNode;\n    List<Node> childNodes;\n    Attributes attributes;\n    String baseUri;\n    int siblingIndex;\n\n    /**\n     Create a new Node.\n     @param baseUri base URI\n     @param attributes attributes (not null, but may be empty)\n     */\n    protected Node(String baseUri, Attributes attributes) {\n        Validate.notNull(baseUri);\n        Validate.notNull(attributes);\n        \n        childNodes = new ArrayList<Node>(4);\n        this.baseUri = baseUri.trim();\n        this.attributes = attributes;\n    }\n\n    protected Node(String baseUri) {\n        this(baseUri, new Attributes());\n    }\n\n    /**\n     * Default constructor. Doesn't setup base uri, children, or attributes; use with caution.\n     */\n    protected Node() {\n        childNodes = Collections.emptyList();\n        attributes = null;\n    }\n\n    /**\n     Get the node name of this node. Use for debugging purposes and not logic switching (for that, use instanceof).\n     @return node name\n     */\n    public abstract String nodeName();\n\n    /**\n     * Get an attribute's value by its key.\n     * <p/>\n     * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,\n     * which is a shortcut to the {@link #absUrl} method.\n     * E.g.: <blockquote><code>String url = a.attr(\"abs:href\");</code></blockquote>\n     * @param attributeKey The attribute key.\n     * @return The attribute, or empty string if not present (to avoid nulls).\n     * @see #attributes()\n     * @see #hasAttr(String)\n     * @see #absUrl(String)\n     */\n    public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributes.hasKey(attributeKey))\n            return attributes.get(attributeKey);\n        else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }\n\n    /**\n     * Get all of the element's attributes.\n     * @return attributes (which implements iterable, in same order as presented in original HTML).\n     */\n    public Attributes attributes() {\n        return attributes;\n    }\n\n    /**\n     * Set an attribute (key=value). If the attribute already exists, it is replaced.\n     * @param attributeKey The attribute key.\n     * @param attributeValue The attribute value.\n     * @return this (for chaining)\n     */\n    public Node attr(String attributeKey, String attributeValue) {\n        attributes.put(attributeKey, attributeValue);\n        return this;\n    }\n\n    /**\n     * Test if this element has an attribute.\n     * @param attributeKey The attribute key to check.\n     * @return true if the attribute exists, false if not.\n     */\n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributeKey.toLowerCase().startsWith(\"abs:\")) {\n            String key = attributeKey.substring(\"abs:\".length());\n            if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n                return true;\n        }\n        return attributes.hasKey(attributeKey);\n    }\n\n    /**\n     * Remove an attribute from this element.\n     * @param attributeKey The attribute to remove.\n     * @return this (for chaining)\n     */\n    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        attributes.remove(attributeKey);\n        return this;\n    }\n\n    /**\n     Get the base URI of this node.\n     @return base URI\n     */\n    public String baseUri() {\n        return baseUri;\n    }\n\n    /**\n     Update the base URI of this node.\n     @param baseUri base URI to set\n     */\n    public void setBaseUri(String baseUri) {\n        Validate.notNull(baseUri);\n        this.baseUri = baseUri;\n    }\n\n    /**\n     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n     * <code>&lt;img src></code>).\n     * <p/>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * <p/>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n     * absolute using that.\n     * <p/>\n     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n     * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n     *\n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     */\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        String relUrl = attr(attributeKey);\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        } else {\n            URL base;\n            try {\n                try {\n                    base = new URL(baseUri);\n                } catch (MalformedURLException e) {\n                    // the base is unsuitable, but the attribute may be abs on its own, so try that\n                    URL abs = new URL(relUrl);\n                    return abs.toExternalForm();\n                }\n                // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n                if (relUrl.startsWith(\"?\"))\n                    relUrl = base.getPath() + relUrl;\n                URL abs = new URL(base, relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                return \"\";\n            }\n        }\n    }\n\n    /**\n     Get a child node by index\n     @param index index of child node\n     @return the child node at this index.\n     */\n    public Node childNode(int index) {\n        return childNodes.get(index);\n    }\n\n    /**\n     Get this node's children. Presented as an unmodifiable list: new children can not be added, but the child nodes\n     themselves can be manipulated.\n     @return list of children. If no children, returns an empty list.\n     */\n    public List<Node> childNodes() {\n        return Collections.unmodifiableList(childNodes);\n    }\n    \n    protected Node[] childNodesAsArray() {\n        return childNodes.toArray(new Node[childNodes().size()]);\n    }\n\n    /**\n     Gets this node's parent node.\n     @return parent node; or null if no parent.\n     */\n    public Node parent() {\n        return parentNode;\n    }\n    \n    /**\n     * Gets the Document associated with this Node. \n     * @return the Document associated with this Node, or null if there is no such Document.\n     */\n    public Document ownerDocument() {\n        if (this instanceof Document)\n            return (Document) this;\n        else if (parentNode == null)\n            return null;\n        else\n            return parentNode.ownerDocument();\n    }\n    \n    /**\n     * Remove (delete) this node from the DOM tree. If this node has children, they are also removed.\n     */\n    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }\n\n    /**\n     * Insert the specified HTML into the DOM before this node (i.e. as a preceeding sibling).\n     * @param html HTML to add before this node\n     * @return this node, for chaining\n     * @see #after(String)\n     */\n    public Node before(String html) {\n        addSiblingHtml(siblingIndex(), html);\n        return this;\n    }\n\n    /**\n     * Insert the specified node into the DOM before this node (i.e. as a preceeding sibling).\n     * @param node to add before this node\n     * @return this node, for chaining\n     * @see #after(Node)\n     */\n    public Node before(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex(), node);\n        return this;\n    }\n\n    /**\n     * Insert the specified HTML into the DOM after this node (i.e. as a following sibling).\n     * @param html HTML to add after this node\n     * @return this node, for chaining\n     * @see #before(String)\n     */\n    public Node after(String html) {\n        addSiblingHtml(siblingIndex()+1, html);\n        return this;\n    }\n\n    /**\n     * Insert the specified node into the DOM after this node (i.e. as a following sibling).\n     * @param node to add after this node\n     * @return this node, for chaining\n     * @see #before(Node)\n     */\n    public Node after(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex()+1, node);\n        return this;\n    }\n\n    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;        \n        List<Node> nodes = Parser.parseFragment(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n    }\n\n    /**\n     Wrap the supplied HTML around this node.\n     @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n     @return this node, for chaining.\n     */\n    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;\n        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());\n        Node wrapNode = wrapChildren.get(0);\n        if (wrapNode == null || !(wrapNode instanceof Element)) // nothing to wrap with; noop\n            return null;\n\n        Element wrap = (Element) wrapNode;\n        Element deepest = getDeepChild(wrap);\n        parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this);\n\n        // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder\n        if (wrapChildren.size() > 0) {\n            for (int i = 0; i < wrapChildren.size(); i++) {\n                Node remainder = wrapChildren.get(i);\n                remainder.parentNode.removeChild(remainder);\n                wrap.appendChild(remainder);\n            }\n        }\n        return this;\n    }\n\n    private Element getDeepChild(Element el) {\n        List<Element> children = el.children();\n        if (children.size() > 0)\n            return getDeepChild(children.get(0));\n        else\n            return el;\n    }\n    \n    /**\n     * Replace this node in the DOM with the supplied node.\n     * @param in the node that will will replace the existing node.\n     */\n    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }\n\n    protected void setParentNode(Node parentNode) {\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }\n\n    protected void replaceChild(Node out, Node in) {\nValidate.isTrue(out.parentNode);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n        \n        Integer index = out.siblingIndex();\n\nchildNodes.set(index);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }\n\n    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        int index = out.siblingIndex();\n        childNodes.remove(index);\n        reindexChildren();\n        out.parentNode = null;\n    }\n\n    protected void addChildren(Node... children) {\n        //most used. short circuit addChildren(int), which hits reindex children and array copy\n        for (Node child: children) {\n            reparentChild(child);\n            childNodes.add(child);\n            child.setSiblingIndex(childNodes.size()-1);\n        }\n    }\n\n    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n        }\n        reindexChildren();\n    }\n\n    private void reparentChild(Node child) {\n        if (child.parentNode != null)\n            child.parentNode.removeChild(child);\n        child.setParentNode(this);\n    }\n    \n    private void reindexChildren() {\n        for (int i = 0; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }\n    \n    /**\n     Retrieves this node's sibling nodes. Effectively, {@link #childNodes()  node.parent.childNodes()}.\n     @return node siblings, including this node\n     */\n    public List<Node> siblingNodes() {\n        return parent().childNodes(); // TODO: should this strip out this node? i.e. not a sibling of self?\n    }\n\n    /**\n     Get this node's next sibling.\n     @return next sibling, or null if this is the last sibling\n     */\n    public Node nextSibling() {\n        if (parentNode == null)\n            return null; // root\n        \n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    /**\n     Get this node's previous sibling.\n     @return the previous sibling, or null if this is the first sibling\n     */\n    public Node previousSibling() {\n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    /**\n     * Get the list index of this node in its node sibling list. I.e. if this is the first node\n     * sibling, returns 0.\n     * @return position in node sibling list\n     * @see org.jsoup.nodes.Element#elementSiblingIndex()\n     */\n    public int siblingIndex() {\n        return siblingIndex;\n    }\n    \n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }\n\n    /**\n     Get the outer HTML of this node.\n     @return HTML\n     */\n    public String outerHtml() {\n        StringBuilder accum = new StringBuilder(32*1024);\n        outerHtml(accum);\n        return accum.toString();\n    }\n\n    protected void outerHtml(StringBuilder accum) {\n        new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this);\n    }\n\n    // if this node has no document (or parent), retrieve the default output settings\n    private Document.OutputSettings getOutputSettings() {\n        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n    }\n\n    /**\n     Get the outer HTML of this node.\n     @param accum accumulator to place HTML into\n     */\n    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        // todo: have nodes hold a child index, compare against that and parent (not children)\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = parentNode != null ? parentNode.hashCode() : 0;\n        // not children, or will block stack as they go back up to parent)\n        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n        return result;\n    }\n\n    /**\n     * Create a stand-alone, deep copy of this node, and all of its children. The cloned node will have no siblings or\n     * parent node. As a stand-alone object, any changes made to the clone or any of its children will not impact the\n     * original node.\n     * <p>\n     * The cloned node may be adopted into another Document or node structure using {@link Element#appendChild(Node)}.\n     * @return stand-alone cloned node\n     */\n    @Override\n    public Node clone() {\n        return doClone(null); // splits for orphan\n    }\n\n    protected Node doClone(Node parent) {\n        Node clone;\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; // can be null, to create an orphan split\n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new ArrayList<Node>(childNodes.size());\n        for (Node child: childNodes)\n            clone.childNodes.add(child.doClone(clone)); // clone() creates orphans, doClone() keeps parent\n\n        return clone;\n    }\n\n    private static class OuterHtmlVisitor implements NodeVisitor {\n        private StringBuilder accum;\n        private Document.OutputSettings out;\n\n        OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out) {\n            this.accum = accum;\n            this.out = out;\n        }\n\n        public void head(Node node, int depth) {\n            node.outerHtmlHead(accum, depth, out);\n        }\n\n        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) // saves a void hit.\n                node.outerHtmlTail(accum, depth, out);\n        }\n    }\n}"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.isTrue(out.parentNode == this);",
        "line": 355,
        "aftercode": "Validate.isTrue(this);"
    },
    {
        "id": 45,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.notEmpty(attributeKey);",
        "line": 164,
        "aftercode": "Validate.notEmpty();"
    },
    {
        "id": 45,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.notEmpty(attributeKey);",
        "line": 164,
        "aftercode": "base = new URL(baseUri);"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        if (index > 0)",
        "line": 439,
        "aftercode": "Integer index = siblingIndex();"
    },
    {
        "id": 41,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        List<Node> siblings = parentNode.childNodes;",
        "line": 436,
        "aftercode": "List<Node> siblings = new Node<Node>();"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.isTrue(out.parentNode == this);",
        "line": 355,
        "aftercode": "childNodes.set(index, in);"
    },
    {
        "id": 45,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.notEmpty(attributeKey);",
        "line": 164,
        "aftercode": "base = new URL(baseUri);"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.isTrue(out.parentNode == this);",
        "line": 360,
        "aftercode": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n The base, abstract Node model. Elements, Documents, Comments etc are all Node instances.\n\n @author Jonathan Hedley, jonathan@hedley.net */\npublic abstract class Node implements Cloneable {\n    Node parentNode;\n    List<Node> childNodes;\n    Attributes attributes;\n    String baseUri;\n    int siblingIndex;\n\n    /**\n     Create a new Node.\n     @param baseUri base URI\n     @param attributes attributes (not null, but may be empty)\n     */\n    protected Node(String baseUri, Attributes attributes) {\n        Validate.notNull(baseUri);\n        Validate.notNull(attributes);\n        \n        childNodes = new ArrayList<Node>(4);\n        this.baseUri = baseUri.trim();\n        this.attributes = attributes;\n    }\n\n    protected Node(String baseUri) {\n        this(baseUri, new Attributes());\n    }\n\n    /**\n     * Default constructor. Doesn't setup base uri, children, or attributes; use with caution.\n     */\n    protected Node() {\n        childNodes = Collections.emptyList();\n        attributes = null;\n    }\n\n    /**\n     Get the node name of this node. Use for debugging purposes and not logic switching (for that, use instanceof).\n     @return node name\n     */\n    public abstract String nodeName();\n\n    /**\n     * Get an attribute's value by its key.\n     * <p/>\n     * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,\n     * which is a shortcut to the {@link #absUrl} method.\n     * E.g.: <blockquote><code>String url = a.attr(\"abs:href\");</code></blockquote>\n     * @param attributeKey The attribute key.\n     * @return The attribute, or empty string if not present (to avoid nulls).\n     * @see #attributes()\n     * @see #hasAttr(String)\n     * @see #absUrl(String)\n     */\n    public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributes.hasKey(attributeKey))\n            return attributes.get(attributeKey);\n        else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }\n\n    /**\n     * Get all of the element's attributes.\n     * @return attributes (which implements iterable, in same order as presented in original HTML).\n     */\n    public Attributes attributes() {\n        return attributes;\n    }\n\n    /**\n     * Set an attribute (key=value). If the attribute already exists, it is replaced.\n     * @param attributeKey The attribute key.\n     * @param attributeValue The attribute value.\n     * @return this (for chaining)\n     */\n    public Node attr(String attributeKey, String attributeValue) {\n        attributes.put(attributeKey, attributeValue);\n        return this;\n    }\n\n    /**\n     * Test if this element has an attribute.\n     * @param attributeKey The attribute key to check.\n     * @return true if the attribute exists, false if not.\n     */\n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributeKey.toLowerCase().startsWith(\"abs:\")) {\n            String key = attributeKey.substring(\"abs:\".length());\n            if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n                return true;\n        }\n        return attributes.hasKey(attributeKey);\n    }\n\n    /**\n     * Remove an attribute from this element.\n     * @param attributeKey The attribute to remove.\n     * @return this (for chaining)\n     */\n    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        attributes.remove(attributeKey);\n        return this;\n    }\n\n    /**\n     Get the base URI of this node.\n     @return base URI\n     */\n    public String baseUri() {\n        return baseUri;\n    }\n\n    /**\n     Update the base URI of this node.\n     @param baseUri base URI to set\n     */\n    public void setBaseUri(String baseUri) {\n        Validate.notNull(baseUri);\n        this.baseUri = baseUri;\n    }\n\n    /**\n     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n     * <code>&lt;img src></code>).\n     * <p/>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * <p/>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n     * absolute using that.\n     * <p/>\n     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n     * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n     *\n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     */\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        String relUrl = attr(attributeKey);\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        } else {\n            URL base;\n            try {\n                try {\n                    base = new URL(baseUri);\n                } catch (MalformedURLException e) {\n                    // the base is unsuitable, but the attribute may be abs on its own, so try that\n                    URL abs = new URL(relUrl);\n                    return abs.toExternalForm();\n                }\n                // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n                if (relUrl.startsWith(\"?\"))\n                    relUrl = base.getPath() + relUrl;\n                URL abs = new URL(base, relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                return \"\";\n            }\n        }\n    }\n\n    /**\n     Get a child node by index\n     @param index index of child node\n     @return the child node at this index.\n     */\n    public Node childNode(int index) {\n        return childNodes.get(index);\n    }\n\n    /**\n     Get this node's children. Presented as an unmodifiable list: new children can not be added, but the child nodes\n     themselves can be manipulated.\n     @return list of children. If no children, returns an empty list.\n     */\n    public List<Node> childNodes() {\n        return Collections.unmodifiableList(childNodes);\n    }\n    \n    protected Node[] childNodesAsArray() {\n        return childNodes.toArray(new Node[childNodes().size()]);\n    }\n\n    /**\n     Gets this node's parent node.\n     @return parent node; or null if no parent.\n     */\n    public Node parent() {\n        return parentNode;\n    }\n    \n    /**\n     * Gets the Document associated with this Node. \n     * @return the Document associated with this Node, or null if there is no such Document.\n     */\n    public Document ownerDocument() {\n        if (this instanceof Document)\n            return (Document) this;\n        else if (parentNode == null)\n            return null;\n        else\n            return parentNode.ownerDocument();\n    }\n    \n    /**\n     * Remove (delete) this node from the DOM tree. If this node has children, they are also removed.\n     */\n    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }\n\n    /**\n     * Insert the specified HTML into the DOM before this node (i.e. as a preceeding sibling).\n     * @param html HTML to add before this node\n     * @return this node, for chaining\n     * @see #after(String)\n     */\n    public Node before(String html) {\n        addSiblingHtml(siblingIndex(), html);\n        return this;\n    }\n\n    /**\n     * Insert the specified node into the DOM before this node (i.e. as a preceeding sibling).\n     * @param node to add before this node\n     * @return this node, for chaining\n     * @see #after(Node)\n     */\n    public Node before(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex(), node);\n        return this;\n    }\n\n    /**\n     * Insert the specified HTML into the DOM after this node (i.e. as a following sibling).\n     * @param html HTML to add after this node\n     * @return this node, for chaining\n     * @see #before(String)\n     */\n    public Node after(String html) {\n        addSiblingHtml(siblingIndex()+1, html);\n        return this;\n    }\n\n    /**\n     * Insert the specified node into the DOM after this node (i.e. as a following sibling).\n     * @param node to add after this node\n     * @return this node, for chaining\n     * @see #before(Node)\n     */\n    public Node after(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex()+1, node);\n        return this;\n    }\n\n    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;        \n        List<Node> nodes = Parser.parseFragment(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n    }\n\n    /**\n     Wrap the supplied HTML around this node.\n     @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n     @return this node, for chaining.\n     */\n    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;\n        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());\n        Node wrapNode = wrapChildren.get(0);\n        if (wrapNode == null || !(wrapNode instanceof Element)) // nothing to wrap with; noop\n            return null;\n\n        Element wrap = (Element) wrapNode;\n        Element deepest = getDeepChild(wrap);\n        parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this);\n\n        // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder\n        if (wrapChildren.size() > 0) {\n            for (int i = 0; i < wrapChildren.size(); i++) {\n                Node remainder = wrapChildren.get(i);\n                remainder.parentNode.removeChild(remainder);\n                wrap.appendChild(remainder);\n            }\n        }\n        return this;\n    }\n\n    private Element getDeepChild(Element el) {\n        List<Element> children = el.children();\n        if (children.size() > 0)\n            return getDeepChild(children.get(0));\n        else\n            return el;\n    }\n    \n    /**\n     * Replace this node in the DOM with the supplied node.\n     * @param in the node that will will replace the existing node.\n     */\n    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }\n\n    protected void setParentNode(Node parentNode) {\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }\n\n    protected void replaceChild(Node out, Node in) {\nValidate.isTrue((out.parentNode == this));\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n        \n        Integer index = out.siblingIndex();\n\nchildNodes.set(index);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }\n\n    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        int index = out.siblingIndex();\n        childNodes.remove(index);\n        reindexChildren();\n        out.parentNode = null;\n    }\n\n    protected void addChildren(Node... children) {\n        //most used. short circuit addChildren(int), which hits reindex children and array copy\n        for (Node child: children) {\n            reparentChild(child);\n            childNodes.add(child);\n            child.setSiblingIndex(childNodes.size()-1);\n        }\n    }\n\n    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n        }\n        reindexChildren();\n    }\n\n    private void reparentChild(Node child) {\n        if (child.parentNode != null)\n            child.parentNode.removeChild(child);\n        child.setParentNode(this);\n    }\n    \n    private void reindexChildren() {\n        for (int i = 0; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }\n    \n    /**\n     Retrieves this node's sibling nodes. Effectively, {@link #childNodes()  node.parent.childNodes()}.\n     @return node siblings, including this node\n     */\n    public List<Node> siblingNodes() {\n        return parent().childNodes(); // TODO: should this strip out this node? i.e. not a sibling of self?\n    }\n\n    /**\n     Get this node's next sibling.\n     @return next sibling, or null if this is the last sibling\n     */\n    public Node nextSibling() {\n        if (parentNode == null)\n            return null; // root\n        \n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    /**\n     Get this node's previous sibling.\n     @return the previous sibling, or null if this is the first sibling\n     */\n    public Node previousSibling() {\n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    /**\n     * Get the list index of this node in its node sibling list. I.e. if this is the first node\n     * sibling, returns 0.\n     * @return position in node sibling list\n     * @see org.jsoup.nodes.Element#elementSiblingIndex()\n     */\n    public int siblingIndex() {\n        return siblingIndex;\n    }\n    \n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }\n\n    /**\n     Get the outer HTML of this node.\n     @return HTML\n     */\n    public String outerHtml() {\n        StringBuilder accum = new StringBuilder(32*1024);\n        outerHtml(accum);\n        return accum.toString();\n    }\n\n    protected void outerHtml(StringBuilder accum) {\n        new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this);\n    }\n\n    // if this node has no document (or parent), retrieve the default output settings\n    private Document.OutputSettings getOutputSettings() {\n        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n    }\n\n    /**\n     Get the outer HTML of this node.\n     @param accum accumulator to place HTML into\n     */\n    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        // todo: have nodes hold a child index, compare against that and parent (not children)\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = parentNode != null ? parentNode.hashCode() : 0;\n        // not children, or will block stack as they go back up to parent)\n        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n        return result;\n    }\n\n    /**\n     * Create a stand-alone, deep copy of this node, and all of its children. The cloned node will have no siblings or\n     * parent node. As a stand-alone object, any changes made to the clone or any of its children will not impact the\n     * original node.\n     * <p>\n     * The cloned node may be adopted into another Document or node structure using {@link Element#appendChild(Node)}.\n     * @return stand-alone cloned node\n     */\n    @Override\n    public Node clone() {\n        return doClone(null); // splits for orphan\n    }\n\n    protected Node doClone(Node parent) {\n        Node clone;\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; // can be null, to create an orphan split\n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new ArrayList<Node>(childNodes.size());\n        for (Node child: childNodes)\n            clone.childNodes.add(child.doClone(clone)); // clone() creates orphans, doClone() keeps parent\n\n        return clone;\n    }\n\n    private static class OuterHtmlVisitor implements NodeVisitor {\n        private StringBuilder accum;\n        private Document.OutputSettings out;\n\n        OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out) {\n            this.accum = accum;\n            this.out = out;\n        }\n\n        public void head(Node node, int depth) {\n            node.outerHtmlHead(accum, depth, out);\n        }\n\n        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) // saves a void hit.\n                node.outerHtmlTail(accum, depth, out);\n        }\n    }\n}"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        in.setSiblingIndex(index);",
        "line": 363,
        "aftercode": "index.setSiblingIndex();"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.isTrue(out.parentNode == this);",
        "line": 355,
        "aftercode": "Validate.isTrue(Validate.isTrue((out.parentNode == this)));"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        if (in.parentNode != null)",
        "line": 357,
        "aftercode": "if(((in.parentNode != null) && (in.parentNode != null))){"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.notNull(in);",
        "line": 356,
        "aftercode": "Validate.notNull();"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.isTrue(out.parentNode == this);",
        "line": 355,
        "aftercode": "Validate.isTrue(out.siblingIndex());"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "        Validate.notNull(in);",
        "line": 356,
        "aftercode": "Integer index = out.siblingIndex();"
    },
    {
        "id": 36,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Jsoup/Jsoup_13_fixed/src/main/java/org/jsoup/nodes/Node.java",
        "precode": "    protected void replaceChild(Node out, Node in) {",
        "line": 354,
        "aftercode": "Node out        Validate.isTrue(out.parentNode == this);"
    }
]