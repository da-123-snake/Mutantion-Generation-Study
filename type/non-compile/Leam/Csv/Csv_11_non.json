[
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 385,
        "aftercode": "if((nextRecord != null)){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 385,
        "aftercode": "if(){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 385,
        "aftercode": "if((nextRecord != null)){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport static org.apache.commons.csv.Token.Type.*;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * <p><strong>Note:</strong> This method internally creates a FileReader using\n     * {@link FileReader#FileReader(java.io.File)} which in turn relies on the default encoding of the JVM that\n     * is executing the code. If this is insufficient create a URL to the file and use\n     * {@link #parse(URL, Charset, CSVFormat)}</p>\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        // Use the default Charset explicitly\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    /**\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\nif((!emptyHeader || (emptyHeader && this.format.getIgnoreEmptyHeaders()))){\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n\nhdrMap.put(header);\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport static org.apache.commons.csv.Token.Type.*;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * <p><strong>Note:</strong> This method internally creates a FileReader using\n     * {@link FileReader#FileReader(java.io.File)} which in turn relies on the default encoding of the JVM that\n     * is executing the code. If this is insufficient create a URL to the file and use\n     * {@link #parse(URL, Charset, CSVFormat)}</p>\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        // Use the default Charset explicitly\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    /**\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\nif((!emptyHeader || (emptyHeader && this.format.getIgnoreEmptyHeaders()))){\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n\nhdrMap.put(i);\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    this.nextRecord();",
        "line": 374,
        "aftercode": "nextRecord.values();"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    hdrMap.put(header, Integer.valueOf(i));",
        "line": 389,
        "aftercode": "hdrMap.put(header);"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    hdrMap.put(header, Integer.valueOf(i));",
        "line": 389,
        "aftercode": "hdrMap.put(Integer.valueOf(i));"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport static org.apache.commons.csv.Token.Type.*;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * <p><strong>Note:</strong> This method internally creates a FileReader using\n     * {@link FileReader#FileReader(java.io.File)} which in turn relies on the default encoding of the JVM that\n     * is executing the code. If this is insufficient create a URL to the file and use\n     * {@link #parse(URL, Charset, CSVFormat)}</p>\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        // Use the default Charset explicitly\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    /**\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\nif((!emptyHeader || (emptyHeader && this.format.getIgnoreEmptyHeaders()))){\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n\nhdrMap.put(Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            hdrMap = new LinkedHashMap<String, Integer>();",
        "line": 363,
        "aftercode": "hdrMap = new String []();"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    hdrMap.put(header, Integer.valueOf(i));",
        "line": 389,
        "aftercode": "hdrMap.put(i);"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        return hdrMap;",
        "line": 393,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 385,
        "aftercode": "if(( && (!emptyHeader || (emptyHeader && this.format.getIgnoreEmptyHeaders())))){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        final String[] formatHeader = this.format.getHeader();",
        "line": 361,
        "aftercode": "final String [] formatHeader = new String []();"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport static org.apache.commons.csv.Token.Type.*;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * <p><strong>Note:</strong> This method internally creates a FileReader using\n     * {@link FileReader#FileReader(java.io.File)} which in turn relies on the default encoding of the JVM that\n     * is executing the code. If this is insufficient create a URL to the file and use\n     * {@link #parse(URL, Charset, CSVFormat)}</p>\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        // Use the default Charset explicitly\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    /**\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\nif((!emptyHeader || (emptyHeader && this.format.getIgnoreEmptyHeaders()))){\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n\nhdrMap.put(containsHeader);\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport static org.apache.commons.csv.Token.Type.*;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * <p><strong>Note:</strong> This method internally creates a FileReader using\n     * {@link FileReader#FileReader(java.io.File)} which in turn relies on the default encoding of the JVM that\n     * is executing the code. If this is insufficient create a URL to the file and use\n     * {@link #parse(URL, Charset, CSVFormat)}</p>\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        // Use the default Charset explicitly\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    /**\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\nif((!emptyHeader || (emptyHeader && this.format.getIgnoreEmptyHeaders()))){\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n\nhdrMap.put(headerRecord);\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport static org.apache.commons.csv.Token.Type.*;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * <p><strong>Note:</strong> This method internally creates a FileReader using\n     * {@link FileReader#FileReader(java.io.File)} which in turn relies on the default encoding of the JVM that\n     * is executing the code. If this is insufficient create a URL to the file and use\n     * {@link #parse(URL, Charset, CSVFormat)}</p>\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        // Use the default Charset explicitly\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    /**\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\nif(emptyHeader){\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n\nhdrMap.put(header);\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 385,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport static org.apache.commons.csv.Token.Type.*;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * <p><strong>Note:</strong> This method internally creates a FileReader using\n     * {@link FileReader#FileReader(java.io.File)} which in turn relies on the default encoding of the JVM that\n     * is executing the code. If this is insufficient create a URL to the file and use\n     * {@link #parse(URL, Charset, CSVFormat)}</p>\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        // Use the default Charset explicitly\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    /**\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\nif(containsHeader){\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n\nhdrMap.put(header);\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 385,
        "aftercode": "if((emptyHeader && )){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport static org.apache.commons.csv.Token.Type.*;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * <p><strong>Note:</strong> This method internally creates a FileReader using\n     * {@link FileReader#FileReader(java.io.File)} which in turn relies on the default encoding of the JVM that\n     * is executing the code. If this is insufficient create a URL to the file and use\n     * {@link #parse(URL, Charset, CSVFormat)}</p>\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        // Use the default Charset explicitly\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    /**\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\nif(emptyHeader){\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n\nhdrMap.put(i);\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_11_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {",
        "line": 385,
        "aftercode": "hdrMap.put(header, Integer.valueOf(i));"
    }
]