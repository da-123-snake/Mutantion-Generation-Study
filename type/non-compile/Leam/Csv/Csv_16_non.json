[
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {",
        "line": 367,
        "aftercode": "if(input.trim()){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));",
        "line": 357,
        "aftercode": "this.lexer = new Lexer(new ExtendedBufferedReader(reader));"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": "Reader reader,CSVFormat format,long characterOffset            throws IOException {"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {",
        "line": 367,
        "aftercode": "if((input && this.format.getTrailingDelimiter())){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));",
        "line": 357,
        "aftercode": "this.lexer = new Lexer(format);"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));",
        "line": 357,
        "aftercode": "this.lexer = new Lexer(reader);"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": "Reader reader,CSVFormat format,long recordNumber            throws IOException {"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));",
        "line": 357,
        "aftercode": "this.lexer = new ExtendedBufferedReader(reader);"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {",
        "line": 367,
        "aftercode": "if(inputClean.equals(nullString)){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));",
        "line": 357,
        "aftercode": "this.lexer = new Lexer(new ExtendedBufferedReader(reader), format);"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {",
        "line": 367,
        "aftercode": "if(((input && inputClean.isEmpty()) && this.format.getTrailingDelimiter())){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {",
        "line": 367,
        "aftercode": "if((inputClean && this.format.getTrailingDelimiter())){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            if (CSVParser.this.isClosed()) {",
        "line": 554,
        "aftercode": "if((next == null)){"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                next = this.getNextRecord();",
        "line": 562,
        "aftercode": "next = 0;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        this.recordNumber = recordNumber - 1;",
        "line": 361,
        "aftercode": "this.recordNumber = format;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": "Reader reader,CSVFormat format,long characterOffset            throws IOException {"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            this.current = null;",
        "line": 558,
        "aftercode": "CSVRecord next = this.current;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": "Reader reader,CSVFormat format,long characterOffset            throws IOException {"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": "Reader reader,CSVFormat format,long characterOffset            throws IOException {"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        final String inputClean = this.format.getTrim() ? input.trim() : input;",
        "line": 366,
        "aftercode": "final String inputClean = (String)this.format.getTrim();"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            CSVRecord next = this.current;",
        "line": 557,
        "aftercode": "CSVRecord next = new CSVRecord();"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                next = this.getNextRecord();",
        "line": 562,
        "aftercode": "next = \"null\";"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n            throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\nif((lastRecord && inputClean.isEmpty())){\n            return;\n        }\n\nfinal String nullString = this.format.getTrailingDelimiter();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n    \n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n  \n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            if (CSVParser.this.isClosed()) {",
        "line": 554,
        "aftercode": "this.current = null;"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                next = this.getNextRecord();",
        "line": 568,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n            throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n    \n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n  \n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                // hasNext() wasn't called before\nif((next == null)){\ncontinue;\n}\n                next = this.getNextRecord();                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": "CSVFormat format,long characterOffset,long recordNumber            throws IOException {"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n            throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\nif((lastRecord && inputClean.isEmpty())){\n            return;\n        }\n\nfinal String nullString = inputClean.isEmpty();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n    \n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n  \n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));",
        "line": 354,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n            throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\nthis.lexer = new Lexer(new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n\nthis.recordNumber = characterOffset;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n    \n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n  \n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                next = this.getNextRecord();",
        "line": 562,
        "aftercode": "next = true;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": "Reader reader,CSVFormat format,long characterOffset            throws IOException {"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));",
        "line": 354,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n            throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\nthis.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n\nthis.recordNumber = format;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n    \n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n  \n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            this.current = null;",
        "line": 558,
        "aftercode": "if((next == null)){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    private void addRecordValue(final boolean lastRecord) {",
        "line": 364,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n            throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\nif(input.trim()){\n            return;\n        }\n        final String nullString = this.format.getNullString();\n\nthis.recordList.add(inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n    \n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n  \n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        this.recordNumber = recordNumber - 1;",
        "line": 361,
        "aftercode": "this.recordNumber = ;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));",
        "line": 354,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n            throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\nthis.lexer = new Lexer(format);\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n\nthis.recordNumber = recordNumber;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n    \n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n  \n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            this.current = null;",
        "line": 558,
        "aftercode": "this.current;"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            if (CSVParser.this.isClosed()) {",
        "line": 554,
        "aftercode": "if(CSVParser.isClosed()){"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            CSVRecord next = this.current;",
        "line": 557,
        "aftercode": "CSVRecord next = ;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": ""
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": "Reader reader,long characterOffset,long recordNumber            throws IOException {"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        final String inputClean = this.format.getTrim() ? input.trim() : input;",
        "line": 366,
        "aftercode": "final String inputClean = (this.format.getTrim())?true:input;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)",
        "line": 351,
        "aftercode": "Reader reader,CSVFormat format,long characterOffset            throws IOException {"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            if (next == null) {",
        "line": 560,
        "aftercode": "CSVRecord next = this.current;"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n            throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\nif(input.trim()){\n            return;\n        }\n\nfinal String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n    \n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n  \n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                next = this.getNextRecord();",
        "line": 562,
        "aftercode": "next = false;"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        final String inputClean = this.format.getTrim() ? input.trim() : input;",
        "line": 366,
        "aftercode": "final String inputClean = (input.trim())?input.trim():input;"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));",
        "line": 357,
        "aftercode": "this.lexer = new Lexer(format, new ExtendedBufferedReader());"
    },
    {
        "id": 3,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));",
        "line": 354,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n            throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\nthis.lexer = new Lexer(format);\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n\nthis.recordNumber = characterOffset;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n    \n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n  \n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "                next = this.getNextRecord();",
        "line": 562,
        "aftercode": "next = next.getNextRecord();"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n            throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\nif((lastRecord && inputClean.isEmpty())){\n            return;\n        }\n\nfinal String nullString = this.recordList;\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n    \n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n  \n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            if (next == null) {",
        "line": 560,
        "aftercode": "if(next){"
    },
    {
        "id": 2,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {",
        "line": 368,
        "aftercode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n            throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\nif((lastRecord && inputClean.isEmpty())){\n            return;\n        }\n\nfinal String nullString = inputClean.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n    \n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n  \n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            if (next == null) {",
        "line": 560,
        "aftercode": "next = this.getNextRecord();"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            if (CSVParser.this.isClosed()) {",
        "line": 554,
        "aftercode": "isClosed();"
    },
    {
        "id": 4,
        "filepath": "/mnt/disk1/cmd/defects4j_fixed/Csv/Csv_16_fixed/src/main/java/org/apache/commons/csv/CSVParser.java",
        "precode": "            this.current = null;",
        "line": 558,
        "aftercode": "this.current = \"null\";"
    }
]